# <a id="main"></a>C++ 核心指导方针

2022/10/6

编辑：

* [Bjarne Stroustrup](http://www.stroustrup.com)
* [Herb Sutter](http://herbsutter.com/)

翻译

* 李一楠 (li_yinan AT 163 DOT com)

本文档是处于持续改进之中的在线文档。
本文档作为开源项目，发布版本为 0.8。
复制，使用，修改，以及创建本项目的衍生物，受到一份 MIT 风格的版权授权。
向本项目作出贡献需要同意一份贡献者授权。详情参见附属的 [LICENSE](LICENSE) 文件。
我们将本项目开放给“友好用户”进行使用，复制，修改，以及生产衍生物，并希望能够获得建设性的资源投入。

十分欢迎大家提出意见和改进建议。
随着我们的知识增长，随着语言和可用的程序库的改进，我们计划对这份文档不断进行修改和扩充。
当提出您的意见时，请关注[导言](#s-introduction)部分，其中概述了我们的目标和所采用的一般方法。
贡献者的列表请参见[这里](#ss-ack)。

已知问题：

* 仍未对规则集合的完整性、一致性和可强制实施性加以全面的检查。
* 三问号 (???) 用于标记已知的信息缺失。
* 需要更新参考部分；许多前 C++11 的源代码都过于老旧。
* [To-do: 未分类的规则原型](#s-unclassified) 是一份基本上保持最新状态的 to-do 列表。

您可以[阅读本指南的范围和结构的说明](#s-abstract)，或者直接跳转到：

* [In: 导言](#s-introduction)
* [P: 理念](#s-philosophy)
* [I: 接口](#s-interfaces)
* [F: 函数](#s-functions)
* [C: 类和类层次](#s-class)
* [Enum: 枚举](#s-enum)
* [R: 资源管理](#s-resource)
* [ES: 表达式和语句](#s-expr)
* [Per: 性能](#s-performance)
* [CP: 并发与并行](#s-concurrency)
* [E: 错误处理](#s-errors)
* [Con: 常量和不可变性](#s-const)
* [T: 模板和泛型编程](#s-templates)
* [CPL: C 风格的编程](#s-cpl)
* [SF: 源文件](#s-source)
* [SL: 标准库](#sl-the-standard-library)

配套章节：

* [A: 架构相关理念](#s-a)
* [NR: 伪规则和错误的看法](#s-not)
* [RF: 参考资料](#s-references)
* [PRO: 剖面配置](#s-profile)
* [GSL: 指导方针支持库](#gsl-guidelines-support-library)
* [NL: 命名和代码布局建议](#s-naming)
* [FAQ: 常见问题的解答](#s-faq)
* [附录 A: 程序库](#s-libraries)
* [附录 B: 代码的现代化转换](#s-modernizing)
* [附录 C: 相关讨论](#s-discussion)
* [附录 D: 支持工具](#s-tools)
* [词汇表](#s-glossary)
* [To-do: 未分类的规则原型](#s-unclassified)

您可以查看有关某个具体的语言特性的一些规则：

* 赋值：
[正规类型](#rc-regular) --
[优先采用初始化](#rc-initialize) --
[复制](#rc-copy-semantic) --
[移动](#rc-move-semantic) --
[以及其他操作](#rc-matched) --
[缺省操作](#rc-eqdefault)
* `class`：
[数据](#rc-org) --
[不变式](#rc-struct) --
[成员](#rc-member) --
[辅助函数](#rc-helper) --
[具体类型](#ss-concrete) --
[构造函数，=，和析构函数](#s-ctor) --
[类层次](#ss-hier) --
[运算符](#ss-overload)
* `concept`：
[规则](#ss-concepts) --
[泛型编程中](#rt-raise) --
[模板实参](#rt-concepts) --
[语义](#rt-low)
* 构造函数：
[不变式](#rc-struct) --
[建立不变式](#rc-ctor) --
[`throw`](#rc-throw) --
[缺省操作](#rc-default0) --
[不需要](#rc-default) --
[`explicit`](#rc-explicit) --
[委派](#rc-delegating) --
[`virtual`](#rc-ctor-virtual)
* 派生 `class`：
[何时使用](#rh-domain) --
[作为接口](#rh-abstract) --
[析构函数](#rh-dtor) --
[复制](#rh-copy) --
[取值和设值](#rh-get) --
[多继承](#rh-mi-interface) --
[重载](#rh-using) --
[分片](#rc-copy-virtual) --
[`dynamic_cast`](#rh-dynamic_cast)
* 析构函数：
[以及构造函数](#rc-matched) --
[何时需要？](#rc-dtor) --
[不可失败](#rc-dtor-fail)
* 异常：
[错误](#s-errors) --
[`throw`](#re-throw) --
[仅用于错误](#re-errors) --
[`noexcept`](#re-noexcept) --
[最少化 `try`](#re-catch) --
[无异常如何？](#re-no-throw-codes)
* `for`：
[范围式 `for` 和 `for`](#res-for-range) --
[`for` 和 `while`](#res-for-while) --
[`for`-初始化式](#res-for-init) --
[空循环体](#res-empty) --
[循环变量](#res-loop-counter) --
[循环变量的类型 ???](#res-???)
* 函数：
[命名](#rf-package) --
[单操作](#rf-logical) --
[不能抛出异常](#rf-noexcept) --
[实参](#rf-smart) --
[实参传递](#rf-conventional) --
[多返回值](#rf-out-multi) --
[指针](#rf-return-ptr) --
[lambda](#rf-capture-vs-overload)
* `inline`:
[小型函数](#rf-inline) --
[头文件中](#rs-inline)
* 初始化：
[总是](#res-always) --
[优先采用 `{}`](#res-list) --
[lambda](#res-lambda-init) --
[类内初始化式](#rc-in-class-initializer) --
[类成员](#rc-initialize) --
[工厂函数](#rc-factory)
* lambda 表达式：
[何时使用](#ss-lambdas)
* 运算符：
[约定](#ro-conventional) --
[避免转换运算符](#ro-conversion) --
[与 lambda](#ro-lambda)
* `public`, `private`, 和 `protected`：
[信息隐藏](#rc-private) --
[一致性](#rh-public) --
[`protected`](#rh-protected)
* `static_assert`：
[编译时检查](#rp-compile-time) --
[和概念](#rt-check-class)
* `struct`：
[用于组织数据](#rc-org) --
[没有不变式时使用](#rc-struct) --
[不能有私有成员](#rc-class)
* `template`：
[抽象](#rt-raise) --
[容器](#rt-cont) --
[概念](#rt-concepts)
* `unsigned`：
[和 `signed`](#res-mix) --
[位操作](#res-unsigned)
* `virtual`：
[接口](#ri-abstract) --
[非 `virtual`](#rc-concrete) --
[析构函数](#rc-dtor-virtual) --
[不能失败](#rc-dtor-fail)

您可以查看用于表达这些规则的一些设计概念：

* 断言：???
* 错误：???
* 异常：异常保证 (???)
* 故障：???
* 不变式：???
* 泄漏：???
* 程序库：???
* 前条件：???
* 后条件：???
* 资源：???

# <a id="s-abstract"></a>概要

本文档是一组有关如何更好使用 C++ 的指导方针的集合。
本文档的目标是帮助人们更有效地使用现代 C++。
所谓“现代 C++”的含义是指有效使用 ISO C++ 标准（目前是 C++20，但几乎所有的推荐也适用于 C++17，C++14 和 C++11）。
换句话说，如果你从现在开始算起，五年后你的代码看起来是怎么样的？十年呢？

这些指导方针所关注的是一些相对高层次的问题，比如接口，资源管理，内存管理，以及并发等等。
这样的规则会对应用的架构，以及程序库的设计都造成影响。
如果遵循这些规则，代码将会是静态类型安全的，没有资源泄露，并且能够捕捉到比当今的代码通常所能捕捉到的多得多的编程逻辑错误。
还能更快速地运行——你不必牺牲程序的正确性。

我们对于如命名约定和缩进风格一类的低层次的问题不那么关注。
当然，对程序员有帮助的任何话题都是可接受的。

我们最初的规则集合强调的是（各种形式的）安全性以及简单性。
它们也许有些过于严格了。
我们预期将会引入更多的例外情况， 以便使它们更好地适应现实世界的需要。
我们也需要更多的规则。

您可能会发现，有的规则与您的预期相反，甚至是与您的经验相违背。
其实如果我们没建议您在任何方面改变您的编码风格，那其实就是我们的失败！
请您尝试验证或者证伪这些规则吧！
尤其是，我们十分期望让一些规则能够建立在真实的测量数据上，或者是一些更好的例子之上。

您可能会觉得一些规则很显然，甚至没有什么价值。
但请记住，指导方针的目的之一就在于帮助那些经验不足的，或来自其他背景或使用其他语言的人，能够迅速行动起来。

这里的许多规则有意设计成可以由分析工具提供支持的。
违反规则的代码会打上标记，以引用（或者链接）到相关的规则。
您在开始编码前并不需要记住所有这些规则。
一种看待这些指导方针的方式，是一份恰好可以让人类读懂的针对这些工具的规范文件。

这些规则都是为了逐步引入一个代码库而设计的。
我们计划建立这样的工具，并希望其他人也能提供它们。

十分欢迎大家提出意见和改进建议。
随着我们的知识增长，随着语言和可用的程序库的改进，我们计划对这份文档不断进行修改和扩充。

# <a id="s-introduction"></a>In: 导言

本文档是一组核心指导方针，针对现代 C++（目前为 C++20 和 C++17），还考虑到了语言将来有希望的增强，以及 ISO 技术规范（TS）。
其目标是帮助 C++ 程序员编写更简单、更高效、更加可维护的代码。

导言概览：

* [In.target: 目标读者](#ss-readers)
* [In.aims: 目标](#ss-aims)
* [In.not: 非目标](#ss-non)
* [In.force: 强制实施](#ss-force)
* [In.struct: 本文档的结构](#ss-struct)
* [In.sec: 主要章节](#ss-sec)

## <a id="ss-readers"></a>In.target: 目标读者

所有 C++ 程序员。其中也包括[考虑采用 C 语言的程序员](#s-cpl)。

## <a id="ss-aims"></a>In.aims: 目标

本文档的目标是帮助开发者采用现代 C++（目前是 C++20 和 C++17），并在各个代码库之间达成更加统一的编码风格。

我们并不妄想这些规则中的每一条都能有效地在任何代码库中进行实施。对老旧系统进行升级是很困难的。不过我们确实认为，采纳了一条规则的程序总会比不这样做的程序更加不易出错也更加便于维护。通常，采用规则也会带来更快速或更容易的初始开发活动。
就我们所能说的，这些规则能够使得代码的性能，相对于更传统的技术来说同样好甚至更好；它们都是依照零开销原则设立的——“不使用就没有负担”（"what you don't use, you don't pay for"）或“当恰当地使用抽象机制时，所得的性能至少与使用低级语言构造手工编码的结果一样好”。
我们认为这些规则对新代码来说是理想的，也有很多机会在老代码中实施，并试图尽可能接近并灵活地对这些理想情况进行近似。
请记住：

### <a id="r0"></a>In.0: 不要慌张！

请花些时间理解一下指南规则对你的程序能够造成的影响。

这些指导方针都是遵循“超集的子集”原则（[Stroustrup05](#stroustrup05)）而设计的。
它们并非仅仅定义了 C++ 的一个可以使用的子集（以获得比如说可靠性，安全性，性能，或者别的什么）。
它们强烈地推崇使用一些简单的“扩展”（[程序库组件](#gsl-guidelines-support-library)），
使得最易出错的 C++ 特性变得不再必须，并且可以（通过这些规则）禁止再使用它们。

这些规则都强调静态类型安全性和资源安全性。
鉴于此，它们强调了进行范围检查，避免对 `nullptr` 解引用，避免悬挂指针，以及（通过 RAII）系统性地使用异常的可能性。
部分地为达成这点，也部分地为了最小化会带来错误的晦涩难懂的代码，这些规则同样强调了简单性，以及将必须的复杂性隐藏于经过充分说明的接口后面。

有许多规则都是约定性质的。
我们认为，那些单纯说“禁止这样！”而又不提供替代方案的规则是不可取的。
但这样的后果就是让一些规则只能以启发式方法，而不是精确地和机械化地进行验证检查。
还有一些规则所表达的是一些一般性的原则。对于这些一般性规则，我们会提供一些更精细和更特定的规则来进行不完全的检查。

这些指导方针所关注的是 C++ 的核心部分及其使用方式。
我们认为大多数的大型团体，特定的应用领域，甚至一些大型项目都会需要更多的规则，也许是更多的限制规则，或是更多的库支持。
例如说，硬实时开发人员通常都无法随意使用自由存储（动态内存），并且在选择程序库上也有许多限制。
我们鼓励各方开发这样的专门规则，以作为我们的核心指导方针的补充。
请构建你自己的基础程序库并使用它，而不要把你的开发层次降低到汇编代码之中。

这些规则的设计使其能够进行[渐进式的采纳](#s-modernizing)。

一些规则的目标是提升各种形式的安全性，而另外一些的目标是减少意外的发生，还有许多则同时兼顾。
目标是避免意外事故的指导方针通常会禁止完全合法的 C++ 用法。
不管怎样，每当存在两种达成效果的方式，其中一种被证实是常见的错误来源，而另外一种并非如此时，我们都会努力引导程序员采纳后者。

## <a id="ss-non"></a>In.not: 非目标

我们没打算让这些规则保持精简或正交。
特别地说，一般性规则可以很简单，但却没办法强制实施。
而且要搞清楚一条一般性规则所造成的影响通常是很困难的。
通常更专门的规则都更易于理解清楚，也更易于实施，但如果没有那些一般性规则的话，它们不过是一大堆特殊情况而已。
我们既要提供能够帮到新手的规则，也要提供能够支持专家使用的规则。
其中的一些规则是完全可以强制实行的，而另外的一些则是基于启发式方案的规则。

并不需要像读书一样从头到尾地阅读这些规则。
您可以利用链接来进行浏览。
不过，这些规则的主要预期用途是作为工具的检查目标。
就是说，由工具来查找规则的违反情况，然后工具会返回指向所违反的规则的链接。
而规则之中则提供了其理由，违反规则的潜在后果的例子，以及一些改正建议。

这些指导方针并不是用来替代 C++ 的教程材料的。
如果您需要针对某个经验水平的教程，请参见[参考资料](#s-references)。

本文档并不是一份如何把老旧 C++ 代码转化为更加现代的代码的指南。
而是旨在以一种具体化的方式来阐明对于新代码的设想。
当然，对于进行代码现代化转换，使其恢复活力或者升级的可行方式，可以参考[代码现代化章节](#s-modernizing)。
重要的是，这些规则是允许渐进式采纳的：对大型代码库进行一次性全部转化通常都是不可行的。

这些指导方针并不会对于语言技术的每个细节上都保持完整和精确。
如果需要，请参考 C++ 标准，关于语言定义上的最终文本，其中包括一般性规则的每种例外情况，也包括所有特性。

这些规则不是为了强迫你使用 C++ 的某个阉割子集来编写代码的。
它们*尤其着重*避免去定义一种像（比如）Java 一样的 C++ 子集。
它们也避免去定义一个单一的所谓“真正的 C++”的语言。
我们重视语言的表达能力和不打折扣的性能。

这些规则并不是价值观中立的。
它们旨在使代码变得相对于现有大多数 C++ 代码来说更简单，并且更加正确和安全，又不会有任何性能损失。
它们旨在约束对那些完全合法的，但却与错误、虚假的复杂性以及不良性能有关的 C++ 代码的使用。

这些规则并未精炼到人们（或机器）可以无脑实施的程度。
“强制实施”部分试图做到这点，但相对于给出一些精确但却错误的东西来说，
我们更倾向于使得一条规则或者定义略微含糊，并允许不同的解读。
有时候，只有经历时间和经验的凝炼才能带来精确性。
设计（还）并不是数学的某种形式。

这些规则并不完美。
某条规则可能有害，因其可能制止了在特定情形中有益的事物。
某条规则可能有害，因其可能无法制止在特定情形中会导致某种严重错误的事物。
某条规则可能有许多害处，因其含混，有歧义，无法实施，或者对一个问题给出了所有的解决方案。
完全满足“无害”的准则是不可能的。
相对来讲，我们的目标并没那么大野心：“对大多数数程序员有最多的好处”；
如果某条规则使你无法工作，你反对它，忽略掉它，但请不要削弱它，除非它已经变得没有意义。
同样，也请给出改进的建议。

## <a id="ss-force"></a>In.force: 强制实施

无法强制实施的规则对于大型代码库来说是难以操作的。
所有规则都强制实施，则仅对于一个小的规则集合，或者对于某些特定用户群来说是可行的。

* 但我们需要大量的规则，需要每个人都能使用的规则。
* 不同的人的要求都不一样。
* 人们不想阅读大量的规则。
* 人们也无法记住太多规则。

因此，我们需要建立规则子集以满足各种不同的需要。

* 但任意性地建立子集也会导致混乱。

我们想要的是可以帮助到许多人的指导方针，使代码更加统一，并有力地促进人们将他们的代码现代化。
我们想要促进最佳实践，而不是让人们陷入大量选项之中而增加管理压力。
理想情况是使用全部规则；这会带来极大的好处。

但这样也带来了一些困难之处。
我们试图通过使用工具来解决它们。
每条规则都包括一个**强制实施**小节，列出了进行强制实施的一些建议。
所谓强制实施，可以是通过代码评审，通过静态分析，通过编译器，或者通过运行时检查来进行的。
只要可行，我们都倾向于“机械性的”检查（人类是缓慢的，不精确的，而且很容易疲倦）和静态检查。
只有当不存在其他方案时，我们才偶尔建议进行运行时检查；我们并不想带来所谓“分布式代码爆炸”。
如果适当的话，我们会（在**强制实施**小节中）将规则标以相关的规则组的名字（所谓“剖面配置”）。
一条规则可以属于多个剖面配置，也可以不属于任何剖面配置。
首先，我们有一些对应于常规需求（期望、理想目标）的剖面配置：

* **type**: 消除类型违规（如通过强制转换（cast），联合体（union），或者变参（varargs）把 `T` 重解释为 `U`）
* **bounds**: 消除边界违规（如越过数组范围的访问）
* **lifetime**: 消除泄漏（如未能 `delete` 或者进行多次 `delete`），以及消除对无效对象的访问（如解引用 `nullptr`，或使用悬挂引用）。

这些剖面配置是为工具的使用而准备的，但对人类读者也能有所帮助。
我们不打算把**强制实施**小节中的评述限定在我们了解如何强制实施的方面；其中的一些说明仅仅是一些愿望，它们可能会对一些工具构建者们造成影响。

实现这些规则的工具应当遵循下面的语法以明确抑制一条规则：

    [[gsl::suppress(tag)]]

或可选地带有一条消息（遵循常规的 C++11 标准标注语法）：

    [[gsl::suppress(tag, justification: "message")]]

其中

* `tag` 是包含强制规则的条目的锚定名字（例如，[C.134](#rh-public) 的锚定名字为 "Rh-public"），
剖面配置的规则组的名字（如 "type"，"bounds"，或 "lifetime"），
或者剖面配置中的特定规则（[type.4](#pro-type-cstylecast) 或 [bounds.2](#pro-bounds-arrayindex)）

* `"message"` 是字符串字面量

## <a id="ss-struct"></a>In.struct: 本文档的结构

每条规则（指导方针，建议）可以包含几个部分：

* 规则本身 —— 例如，**不要使用裸 `new`**
* 一个规则参考编号 —— 例如，**C.7**（与类相关的第七条规则）。
  因为大章节之间天然是无序的，所以我们用字母来当作规则参考“编号”的第一个部分。
  我们在编号之间保留了一些间隔，以便当添加或删减规则时尽量减少“断裂”。
* **理由**（原理） —— 程序员对于他们不理解的规则是难于遵守的
* **示例** —— 抽象地理解规则是很难的；示例有正面的和负面的
* **替代方案** —— 针对“请勿……”规则
* **例外** —— 我们更喜欢简单的一般性规则。但是许多规则都是广泛适用，但并不是普遍适用的，因此必须列出例外情况
* **强制实施** —— 关于这条规则如何“机械性”地进行检查的建议
* **参见** —— 指向相关的规则，以及（本文档中或者别处的）进一步讨论
* **注解** —— 需要说明的一些内容，无法被归类到其他部分
* **探讨** —— 指向规则主列表之外的更加全面的原理说明和实例

一些规则难于机械地进行检查，但它们都满足一条最小准则，即专家程序员可以不费太多力气就能找出许多违反情况。
我们希望“机械性”工具能够随着时间获得改进，以接近这种专家程序员所能发觉的程度。
而且，我们还认为这些规则也会随着时间获得提炼，以变得更明确和易于检查。

规则应当简明，而不是谨慎地列出每种变化和特殊情况。
这些信息应当出现在**替代方案**段落和[探讨](#s-discussion)章节中。
如果您不理解或者反对一条规则，请您访问它的**探讨**部分。
如果您觉得一份探讨有缺漏或不完整，请填写一条 [Issue](https://github.com/isocpp/CppCoreGuidelines/issues)
来解释您的关切，亦或一条相应的问题报告。

各个示例用于演示规则。

* 这些示例并非意图具有产品级的质量，或覆盖所有的教学维度。
例如，许多的例子都是语言技巧，并使用了诸如 `f`，`base`，和 `x` 这样的名字。
* 我们尝试保证使下文中“好”的示例都遵守《核心指导方针》。
* 注释通常用于演示规则，它们可能是不必要的，或者会干扰“真正的代码”。
* 我们假设读者具有标准程序库的知识。例如我们使用普通的 `vector` 而不是 `std::vector`。

本文档不是语言手册。
它旨在能够对人有所帮助，而不是变得完整，在技术细节上完全准确，或对现存代码的指南。
可以在[参考资料](#s-references)中找到一些推荐的信息来源。

## <a id="ss-sec"></a>In.sec: 主章节

* [In: 导言](#s-introduction)
* [P: 理念](#s-philosophy)
* [I: 接口](#s-interfaces)
* [F: 函数](#s-functions)
* [C: 类和类层次](#s-class)
* [Enum: 枚举](#s-enum)
* [R: 资源管理](#s-resource)
* [ES: 表达式和语句](#s-expr)
* [Per: 性能](#s-performance)
* [CP: 并发与并行](#s-concurrency)
* [E: 错误处理](#s-errors)
* [Con: 常量和不可变性](#s-const)
* [T: 模板和泛型编程](#s-templates)
* [CPL: C 风格的编程](#s-cpl)
* [SF: 源文件](#s-source)
* [SL: 标准库](#sl-the-standard-library)

配套章节：

* [A: 架构相关的理念](#s-a)
* [NR: 伪规则和错误的看法](#s-not)
* [RF: 参考资料](#s-references)
* [Pro: 剖面配置](#s-profile)
* [GSL: 指导方针支持库](#gsl-guidelines-support-library)
* [NL: 命名和代码布局建议](#s-naming)
* [FAQ: 常见问题的解答](#s-faq)
* [附录 A: 程序库](#s-libraries)
* [附录 B: 代码的现代化转换](#s-modernizing)
* [附录 C: 相关讨论](#s-discussion)
* [附录 D: 支持工具](#s-tools)
* [词汇表](#s-glossary)
* [To-do: 未分类的规则原型](#s-unclassified)

章节之间并非是正交的。

每个章节（比如，"P" 代表“理念”），以及每个子章节（比如，"C.hier" 代表“类层次（OOP）”）都有一个用以简化搜索和引用的缩写。
主章节的缩写也出现在规则编号之中（比如，"C.11" 代表“使具体类型正规化”）。

# <a id="s-philosophy"></a>P: 理念

本章节中的规则都非常具有一般性。

理念性规则概览：

* [P.1: 在代码中直接表达你的想法](#rp-direct)
* [P.2: 用 ISO 标准 C++ 来编码](#rp-cplusplus)
* [P.3: 表达你的设计意图](#rp-what)
* [P.4: 理想情况下，程序应当是静态类型安全的](#rp-typesafe)
* [P.5: 编译期检查优先于运行时检查](#rp-compile-time)
* [P.6: 应当使无法在编译期进行的检查能够在运行时实施](#rp-run-time)
* [P.7: 尽早识别运行时错误](#rp-early)
* [P.8: 不要泄漏任何资源](#rp-leak)
* [P.9: 不要浪费时间或空间](#rp-waste)
* [P.10: 不可变数据优先于可变数据](#rp-mutable)
* [P.11: 把杂乱的构造封装起来，而别让其散布到代码中](#rp-library)
* [P.12: 适当采用支持工具](#rp-tools)
* [P.13: 适当采用支持程序库](#rp-lib)

通常，理念性的规则都无法机械性地进行检查。
不过，这些理念主题在各个规则中都有体现。
如果没有一个理念基础的话，那些更具体、专门和可检查的规则就是缺少理论根据的了。

### <a id="rp-direct"></a>P.1: 在代码中直接表达你的想法

##### 理由

编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。
而代码中所表达的东西是带有明确的语义的，并且（原则上）是可以由编译器和其他工具进行检验的。

##### 示例

    class Date {
    public:
        Month month() const;  // 好
        int month();          // 不好
        // ...
    };

`month` 的第一个声明式，显然是要返回一个 `Month`，而且不会修改 `Date` 对象的状态。
而第二个版本则需要读者进行猜测，同时带来了更多的出现难于发现 BUG 的可能性。

##### 示例，不好

这个循环是 `std::find` 的一种能力有限的形式：

    void f(vector<string>& v)
    {
        string val;
        cin >> val;
        // ...
        int index = -1;                    // 不好，而且应该使用 gsl::index
        for (int i = 0; i < v.size(); ++i) {
            if (v[i] == val) {
                index = i;
                break;
            }
        }
        // ...
    }

##### 示例，好

要清晰得多地表达其设计意图，可以这样：

    void f(vector<string>& v)
    {
        string val;
        cin >> val;
        // ...
        auto p = find(begin(v), end(v), val);  // 好多了
        // ...
    }

用恰当设计的程序库来表达设计意图（要做什么，而不只是怎么做这些事），要远比直接使用语言功能好得多。

C++ 程序员应当熟知标准库的基本知识，并在适当的时候加以利用。
任何程序员都应当熟知其所工作的项目中的基础程序库的基本知识，并适当加以利用。
使用本文档的指导方针的程序员，应当熟知[指导方针支持库](#gsl-guidelines-support-library)，并适当加以利用。

##### 示例

    change_speed(double s);   // bad: s 代表什么？
    // ...
    change_speed(2.3);

更好的方案是明确给出这个 double 的含义（新的速度还是对旧速度的增量？）以及所用单位：

    change_speed(Speed s);    // 好多了：说明了 s 的含义
    // ...
    change_speed(2.3);        // 错误：没有单位
    change_speed(23_m / 10s);  // 米每秒

确实可以用普通的（没有单位的）`double` 作为增量值，但这样是易于出错的。
如果绝对速度值和增量值都需要的话，我们应当定义一个 `Delta` 类型。

##### 强制实施

通常非常困难。

* 坚持一贯地使用 `const`（检查成员函数是否会修改对象；检查函数是否会修改以指针或引用形式传递的实参）
* 将强制转换标示出来（强制转换阉割了类型系统）
* 检测模仿标准库的代码（困难）

### <a id="rp-cplusplus"></a>P.2: 用 ISO 标准 C++ 来编码

##### 理由

本文档正是关于用 ISO 标准 C++ 来编码的一组指导方针。

##### 注解

有些环境下是需要使用语言扩展的，例如有关访问系统资源的语言扩展。
这些情况下，应当将对所需语言扩展的使用局部化，并把它们的使用置于非核心的编码指导方针的控制之下。如果可能的话，应当构建一些接口来封装这些语言扩展，以使其能够被关闭，并当针对不支持这些语言扩展的系统时免除它们的编译。

语言扩展通常是没有严密定义的语义的。即便语言扩展很常见，
并且在多种编译器上都有实现，它们也可能有略微不一致的行为
以及边界情形下的行为，这是*缺乏*一个严格的标准定义的
直接后果。大量使用任何这样的语言扩展，都会对代码的可移植性
造成不良影响。

##### 注解

使用合法的 C++ 并不能保证可移植性（不管其正确性）。
应当避免依赖于未定义的行为（例如，[未定义的求值顺序](#res-order)）
并应当关注带有由实现定义的含义的构造（例如，`sizeof(int)`）。

##### 注解

有些环境下是需要对标准 C++ 语言或者程序库的功能特性的使用进行限制的，例如，飞行器控制软件标准要求避免动态内存分配。
这些情况下，应当将对它们的使用（或废弃）置于对本文档针对特定环境所定制的扩充的编码指导方针之下。

##### 强制实施

使用最新版的 C++ 编译器（目前支持 C++20 或 C++17），并打开禁用语言扩展的选项。

### <a id="rp-what"></a>P.3: 表达你的设计意图

##### 理由

一些代码如果不（比如通过命名或者代码注释）说明其设计意图的话，是不可能搞清楚代码是否达成其预定目标的。

##### 示例

    gsl::index i = 0;
    while (i < v.size()) {
        // ... 在 v[i] 上做一些事 ...
    }

这里并未表明其意图是“单纯地”循环访问 `v` 的元素。使用一个索引的实现细节被暴露了出来（因而可能导致被误用），而且 `i` 的存在超出了循环的范围，这也许符合也许违背了设计意图。读者仅从这段代码中是无法了解清楚的。

更好的方式是：

    for (const auto& x : v) { /* 用 x 的值做一些事 */ }

现在，循环机制不明确给出，而且循环的操作针对的是 `const` 元素，以防止发生意外的修改。如果需要进行修改的话，则可以这样：

    for (auto& x : v) { /* 修改 x */ }

`for` 语句的更多细节，请参见 [ES.71](#res-for-range)。
有时候，使用具名的算法会更好。 这个示例使用 Ranges TS 中的 `for_each`，因为它直接表达了意图：

    for_each(v, [](int x) { /* 用 x 的值做一些事 */ });
    for_each(par, v, [](int x) { /* 用 x 的值做一些事 */ });

最后一种写法让人明白，我们对按照何种顺序来处理 `v` 的各个元素并不关心。

程序员应当熟悉：

* [指导方针支持库](#gsl-guidelines-support-library)
* [ISO C++ 标准库](#sl-the-standard-library)
* 当前项目所使用的任何基础程序库

##### 注解

其他形式：说明要做什么，而不只是怎么做这些事。

##### 注解

一些语言构造比另一些可以更好地表达设计意图。

##### 示例

如果要用两个 `int` 来代表二维点的坐标值，应当这样：

    draw_line(int, int, int, int);  // 含混的：(x1,y1,x2,y2)? (x,y,h,w)? ...?
                                    // 查看文档才能得知

    draw_line(Point, Point);        // 清晰的

##### 强制实施

查找具有更加替代方案的一般模式：

* 简单 `for` 循环 vs. 范围式 `for` 循环
* `f(T*, int)` 接口 vs. `f(span<T>)` 接口
* 循环变量出现在过大的范围中
* 裸的 `new` 和 `delete`
* 带有大量内建类型的形参的函数

在聪敏的人工处理和半自动的程序变换之间存在巨大的空间。

### <a id="rp-typesafe"></a>P.4: 理想情况下，程序应当是静态类型安全的

##### 理由

理想情况下，程序应当完全是静态（编译期）类型安全的。
不幸的是，这是不可能的。有问题的领域：

* `union`
* 强制转换
* 数组退化
* 范围错误
* 窄化转换

##### 注解

这些领域是许多严重问题（如程序崩溃和安全性违规）的来源。
我们争取为它们给出替代技术。

##### 强制实施

如果程序各自需要或者条件允许的话，我们可以逐个对这些问题类型分别进行阻止、克制或者检测。
我们总会给出替代方案。
例如：

* `union` - 使用 `variant`（C++17 提供）
* 强制转换 - 尽可能减少其使用；使用模板有助于这点
* 数组退化 - 使用 `span`（来自 GSL）
* 范围错误 - 使用 `span`
* 窄化转换 - 尽可能减少其使用，必须使用时则使用 `narrow` 或者 `narrow_cast`（来自 GSL）

### <a id="rp-compile-time"></a>P.5: 编译期检查优先于运行时检查

##### 理由

为了代码清晰性和性能。
对于编译期识别的错误是不需要编写错误处理的。

##### 示例

    // Int 被用作整数的别名
    int bits = 0;         // 请勿如此: 可以避免的代码
    for (Int i = 1; i; i <<= 1)
        ++bits;
    if (bits < 32)
        cerr << "Int too small\n";

这个例子并没有达成其所要达成的目的（因为溢出是未定义行为），应当被替换为简单的 `static_assert`：

    // Int 被用作整数的别名
    static_assert(sizeof(Int) >= 4);    // do: 编译时检查

或者更好的方式是直接利用类型系统，将 `int` 替换 `int32_t`。

##### 示例

    void read(int* p, int n);   // 读取至多 n 个整数到 *p 之中

    int a[100];
    read(a, 1000);    // 不好，超过末尾了

更好的做法是

    void read(span<int> r); // 读取到整数区域范围 r 之中

    int a[100];
    read(a);        // 好多了: 让编译器确定元素数量

**替代形式**: 不要把可以在编译期搞定的事推后到运行时进行。

##### 强制实施

* 查找指针参数。
* 查找运行时进行的范围违反检查。

### <a id="rp-run-time"></a>P.6: 应当使无法在编译期进行的检查能够在运行时实施

##### 理由

把难于检测的错误遗留在程序中，总会带来程序崩溃或得到错误的运行结果。

##### 注解

理想情况下我们可以在编译期或者运行时识别所有的错误（它们并非程序员的逻辑错误）。但是要在编译期识别所有的错误是不可能的，而通常也负担不起在运行时识别剩余的全部错误的代价。不过我们编写程序，应当尽量使其在原则上是可以在充足的（分析程序，运行时检查，机器资源，时间等）资源下进行检查的。

##### 示例，不好

    // 分离编译，可能会被动态加载
    extern void f(int* p);

    void g(int n)
    {
        // 不好的：并未把元素数量传递给 f()
        f(new int[n]);
    }

此处，关键性的信息（元素数量）被完全掩盖起来，使其无法进行静态分析，而如果 `f()` 属于某个 ABI 的一部分的话，由于无法对这个指针进行“测量插装”，运行时检查也是不可行的。我们确实可以在自由存储中插入有助于检查的信息，但这需要对系统甚至是编译器做出整体改动。这就是一个能让错误检查变得非常困难的设计。

##### 示例，不好

当然可以把元素数量和指针一起进行传递：

    // 分离编译，可能会被动态加载
    extern void f2(int* p, int n);

    void g2(int n)
    {
        f2(new int[n], m);  // 不好的：可能会把错误的元素数量传递给 f()
    }

把元素数量作为一个参数进行传递，比只传递指针而依靠某种（不明确的）对已知元素个数的约定或者找出元素个数的方式，要好得多，而且是更加常见的做法。但是如上所示，一个简单的错字就可以引入一个严重的错误。`f2()` 的两个参数之间的关联是基于约定的，而并不明确。

而且，这里还隐含假定 `f2()` 应当 `delete` 其参数（要不然就是调用者又犯了另一个错误）。

##### 示例，不好

使用标准库的资源管理指针指向对象时，也不能传递其大小：

    // 分离编译，可能会被动态加载
    // NB: 这里假定调用代码是 ABI 兼容的，使用的是
    // 兼容的 C++ 编译器和同一个 stdlib 实现
    extern void f3(unique_ptr<int[]>, int n);

    void g3(int n)
    {
        f3(make_unique<int[]>(n), m);    // 不好的：把所有权和大小分开进行传递
    }

##### 示例

我们得把指针和元素数量作为一个对象整体来进行传递：

    extern void f4(vector<int>&);   // 分离编译，可能会被动态加载
    extern void f4(span<int>);      // 分离编译，可能会被动态加载
                                    // NB: 这里假定调用代码是 ABI 兼容的，使用的是
                                    // 兼容的 C++ 编译器和同一个 stdlib 实现

    void g3(int n)
    {
        vector<int> v(n);
        f4(v);                     // 传递引用，保留所有权
        f4(span<int>{v});          // 传递视图，保留所有权
    }

这个设计将元素数量作为对象的固有部分，因此不太可能有错误，动态（运行时的）检查即使不总是可承担的，也总是可行的。

##### 示例

如果把所有权和验证所需的全部信息一起传递的话会怎么样呢？

    vector<int> f5(int n)    // OK: 移动
    {
        vector<int> v(n);
        // ... 初始化 v ...
        return v;
    }

    unique_ptr<int[]> f6(int n)    // 不好的：缺失了 n
    {
        auto p = make_unique<int[]>(n);
        // ... 初始化 *p ...
        return p;
    }

    owner<int*> f7(int n)    // 不好的：缺失了 n 并且我们可能会忘记 delete
    {
        owner<int*> p = new int[n];
        // ... 初始化 *p ...
        return p;
    }

##### 示例

* ???
* 展示传递多态基类的接口是如何避开可能进行的检查的，但它们实际上直到它们需要的类型？
  还有用字符串当作“自由式”选项的做法

##### 强制实施

* 标示出 (pointer, count) 形式的接口（这将标示出大量的因为兼容性原因而无法进行修正的实例）
* ???

### <a id="rp-early"></a>P.7: 尽早识别运行时错误

##### 理由

避免“神秘的”程序崩溃。
避免能够产生（也许无法识别的）错误结果的程序错误。

##### 示例

    void increment1(int* p, int n)    // 不好的：易于出错
    {
        for (int i = 0; i < n; ++i) ++p[i];
    }

    void use1(int m)
    {
        const int n = 10;
        int a[n] = {};
        // ...
        increment1(a, m);   // 可能是打错字，可能假定有 m <= n
                            // 不过让我们假设 m == 20
        // ...
    }

我们在 `use1` 里面犯了一个能够导致数据损坏或程序崩溃的小错误。
这个 (pointer, count) 形式的接口让 `increment1()` 没有可以使其防范越界错误的任何现实可行的方式。
如果我们可以检测到越界访问的下标的话，那么这个错误直到对 `p[10]` 进行访问之前都不会被发现。
我们可以提早进行检查来改进这个代码：

    void increment2(span<int> p)
    {
        for (int& x : p) ++x;
    }

    void use2(int m)
    {
        const int n = 10;
        int a[n] = {};
        // ...
        increment2({a, m});    // 可能是打错字，可能假定有 m<=n
        // ...
    }

现在，就可以在调用点（提早地）检查 `m <= n`，而不是更晚进行了。
如果我们只是打错了字而本想用 `n` 作为边界值的话，代码还可以进一步简化（来消除一处错误的可能性）：

    void use3(int m)
    {
        const int n = 10;
        int a[n] = {};
        // ...
        increment2(a);   // 不需要重复给出 a 的元素数量
        // ...
    }

##### 示例，不好

不要对同一个值重复进行检查。不要用字符串来传递有结构的数据：

    Date read_date(istream& is);    // 从 istream 读取日期

    Date extract_date(const string& s);    // 从 string 中抽取日期

    void user1(const string& date)    // 操作 date
    {
        auto d = extract_date(date);
        // ...
    }

    void user2()
    {
        Date d = read_date(cin);
        // ...
        user1(d.to_string());
        // ...
    }

这个日期被（`Date` 的构造函数）验证了两次，并以字符串（无结构的数据）的形式来传递。

##### 示例

过量的检查可能是代价昂贵的。
有些情况下提早检查可能会很低效，因为你可能根本不需要这个值，或者可能仅需要值的一部分，而这要比进行整体的检查容易得多。同样来说，不要添加能够改变接口的渐进式行为的验证性检查（例如，不要在平均复杂度为 `O(1)` 的接口中添加一个 `O(n)` 的检查）。

    class Jet {    // 物理规则是: e * e < x * x + y * y + z * z
        float x;
        float y;
        float z;
        float e;
    public:
        Jet(float x, float y, float z, float e)
            :x(x), y(y), z(z), e(e)
        {
            // 应不应该在这里检查这些值是物理上有意义的？
        }

        float m() const
        {
            // 应不应该处理这里的退化情形？
            return sqrt(x * x + y * y + z * z - e * e);
        }

        ???
    };

喷流（Jet）的物理定律（`e * e < x * x + y * y + z * z`），由于可能存在测量误差的缘故并不是不变式。

???

##### 强制实施

* 查找指针和数组：提早且不要重复进行范围检查
* 查找类型转换：消除或标示出窄化转换
* 查找未经检查的来自输入的值。
* 查找被转换成字符串的结构化数据（带有不变式的类的对象）
* ???

### <a id="rp-leak"></a>P.8: 不要泄漏任何资源

##### 理由

即使是缓慢的资源增长，随着时间推移，也会耗尽这些资源的可用性。
这对于长时间运行的程序来说尤其重要，而且是负责任的编程行为的基础方面。

##### 示例，不好

    void f(char* name)
    {
        FILE* input = fopen(name, "r");
        // ...
        if (something) return;   // 不好的：如果 something == true 的话，将会泄漏一个文件句柄
        // ...
        fclose(input);
    }

建议采用 [RAII](#rr-raii)：

    void f(char* name)
    {
        ifstream input {name};
        // ...
        if (something) return;   // OK: 没有泄漏
        // ...
    }

**参见**: [资源管理相关章节](#s-resource)

##### 注解

通俗地说，泄漏就是“有东西没清理干净”。
一种更重要的分类方式是“有东西无法再被清理干净”。
例如，在堆上分配一个对象，然后又丢失了最后一个指向这份分配物的指针。
不应当将这条规则误读为，要求在程序终止时必须把长期存活的对象中的分配物进行回收。
例如，依赖于系统所保证的进程停止时进行的文件关闭和内存回收行为可以简化代码。
然而，依赖于进行隐式清理的抽象机制同样简单，而且通常更加安全。

##### 注解

强制实行[生存期安全性剖面配置](#ss-lifetime)可以消除泄漏的发生。
如果和 [RAII](#rr-raii) 所提供的资源安全性组合到一起，也可以（通过不产生任何垃圾而）消除对“垃圾收集”的需要。
如果将之和[类型和边界剖面配置](#ss-force) 组合到一起强制实施的话，你将会得到完全的类型和资源安全性，这是通过使用工具来保证的。

##### 强制实施

* 查找指针：把它们分成非所有者（默认情形）和所有者。
  如果可行的话，把所有者替换为标准库的资源封装类（如上例所示）。
  或者，也可以把这种所有者用 [GSL](#gsl-guidelines-support-library) 中的 `owner` 进行标记。
* 查找裸露的 `new` 和 `delete`
* 查找已知的返回原始指针的资源分配函数（诸如 `fopen`，`malloc`，和 `strdup` 等）

### <a id="rp-waste"></a>P.9: 不要浪费时间或空间

##### 理由

你用的语言是 C++。

##### 注解

为达成某个目标（例如开发速度，资源安全性，或者测试的简化等）而正当花费的时间和空间是不会被浪费的。
“力求高效的另一种好处是，这一过程将强迫你更深入地理解问题。”—— Alex Stepanov

##### 示例，不好

    struct X {
        char ch;
        int i;
        string s;
        char ch2;

        X& operator=(const X& a);
        X(const X&);
    };

    X waste(const char* p)
    {
        if (!p) throw Nullptr_error{};
        int n = strlen(p);
        auto buf = new char[n];
        if (!buf) throw Allocation_error{};
        for (int i = 0; i < n; ++i) buf[i] = p[i];
        // ... 对缓冲区进行操作 ...
        X x;
        x.ch = 'a';
        x.s = string(n);    // 在 x.s 上预留 *p 的空间
        for (gsl::index i = 0; i < x.s.size(); ++i) x.s[i] = buf[i];  // 把 buf 复制给 x.s
        delete[] buf;
        return x;
    }

    void driver()
    {
        X x = waste("Typical argument");
        // ...
    }

这个确实有些夸张，但我们在产品代码中能够见到这里所犯的每个错误，甚至更糟糕。
注意，`X` 的布局保证会浪费至少 6 个字节，而且很可能更多。
错误的复制操作的定义式废掉了移动语义，使返回操作变得更慢
（请注意这里并不会保证进行返回值优化（RVO））。
为 `buf` 使用的 `new` 和 `delete` 是多余的；如果确实想要一个局部的字符串的话，我们应当使用局部的 `string`。
还有几个其他的性能 BUG 和无理由的复杂性。

##### 示例，不好

    void lower(zstring s)
    {
        for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]);
    }

这个其实是一个来自产品代码的例子。
可以看到这里有一句 `i < strlen(s)`。这个表达式在循环的每次重复中都要求值，这意味着每次循环中 `strlen` 都必须走完字符串以确定其长度。我们假定在改动字符串内容过程中`tolower` 不会影响字符串的长度，因此最好在循环外面缓存长度值，而不是在每次重复中都承担其代价。

##### 注解

单个造成浪费的范例很少是显著的，而一旦它是显著的，通常也可以被高手轻易地清除掉。
但是，代码库中放任地到处散布的浪费情况，则很容易变得显著，而高手们又不像我们期望那样总是有空的。
本条规则（以及其他配套的更加具体的规则）的目的是，将与 C++ 语言的使用有关的大多数浪费情况，在其发生之前就将之清除掉。
在这之后，我们就可以查找与算法和需求有关的浪费情况了，但这超出了我们的指导方针的范畴。

##### 强制实施

许多更加具体的规则都是针对追求简单性并清除无理由浪费的总体目标的。

* 当用户定义的非预置后缀 `operator++` 或 `operator--` 函数的返回值未被使用时进行标记。优先代之以采用前缀形式。（注：使用“用户定义的非预置”是为了减弱噪声。若实践中噪声还是很显著则需要重新审视这条强制措施。）


### <a id="rp-mutable"></a>P.10: 不可变数据优先于可变数据

##### 理由

对常量进行推理要比变量简单得多。
不可变的事物是不可能被意外改变的。
不可变性有时候也带来更好地进行优化的机会。
在常量上不会出现数据竞争。

另见 [Con: 常量和不可变性](#s-const)

### <a id="rp-library"></a>P.11: 把杂乱的构造封装起来，而别让其散布到代码中

##### 理由

杂乱的代码更有可能隐藏有 Bug 而且难于编写。
而好的接口使用起来更容易和安全。
杂乱的，底层的代码会混杂出更多这样的代码。

##### 示例

    int sz = 100;
    int* p = (int*) malloc(sizeof(int) * sz);
    int count = 0;
    // ...
    for (;;) {
        // ... 读取一个 int 到 x 中，如果达到文件尾就退出循环 ...
        // ... 检查 x 有效 ...
        if (count == sz)
            p = (int*) realloc(p, sizeof(int) * sz * 2);
        p[count++] = x;
        // ...
    }

这段代码是低层的，啰嗦的，而且易错的。
比如说，我们就“忘了”检查内存耗尽情况。
我们可以代之以使用 `vector`：

    vector<int> v;
    v.reserve(100);
    // ...
    for (int x; cin >> x; ) {
        // ... 检查 x is 有效 ...
        v.push_back(x);
    }

##### 注解

标准库和 GSL 都是这种理念的例子。
例如，我们并不使用混乱的数组，联合体，强制转换，麻烦的生存期问题，`gsl::owner`，等等，
它们用于实现一些关键抽象，诸如 `vector`，`span`，`lock_guard`，以及 `future`，我们使用的是
一般来说比我们有更多时间和专业能力的人所设计和实现的程序库。
类似地，我们也能够而且应该设计并实现更专门的程序库，而不是将其留给用户（通常是我们自己）
来面对需要重复把低级代码搞正确的挑战。
这是作为指导方针基石的[超集的子集原则](#r0)的一种变体。

##### 强制实施

* 查找如复杂指针操作和在抽象的实现外面进行强制转换这样的“混乱代码”。


### <a id="rp-tools"></a>P.12: 适当采用支持工具

##### 理由

许多事情机器都比人做得更好。
对于重复劳动，计算机既不会累也不会厌烦。
相对于重复性的例行任务，我们通常可以做一些更有意义的事情。

##### 示例

运行静态分析工具来验证你的代码是否遵循了你想要遵循的指导方针。

##### 注解

参见

* [静态分析工具](???)
* [并发工具](#rconc-tools)
* [测试工具](???)

还有许多其他种类的工具，诸如源代码仓库和构建工具等等，
但这些超出了本指导方针的范围。

##### 注解

当心不要变得对过于详细定制的或者过于专门的工具链产生依赖。
它们会使得你本来可移植的代码变得不可移植。


### <a id="rp-lib"></a>P.13: 适当采用支持程序库

##### 理由

使用设计良好，文档全面，并且有良好支持的程序库可以节省时间和工作量；
如果你的大部分工时都必须耗费在实现上的话，
程序库的质量和文档很可能要比你能做到的要好得多。
程序库的成本（时间，工作量和资金等等）可以由大量的用户所分担。
一个被广泛应用的程序库，远比一个独立的应用程序更加能够保持为最新状态，并被移植到新的系统之上。
对于被广泛应用的程序库的相关知识，也可以节省其他或未来的项目中的时间。
因此，如果你的应用领域中存在合适的程序库的话，请使用它。

##### 示例

    std::sort(begin(v), end(v), std::greater<>());

如果你不是排序算法方面的专家而且有大量时间的话，
这样的代码比你为特定的应用所编写的任何代码都更可能正确并且运行得更快。
不使用标准库（或者你的应用所采用的基础程序库）是需要明确理由的，而不是反过来。

##### 注解

默认应当优先使用

* [ISO C++ 标准库](#sl-the-standard-library)
* [指导方针支持库](#gsl-guidelines-support-library)

##### 注解

如果某个重要的领域中不存在设计良好，文档全面，并且有良好支持的程序库的话，
可能应当由你来设计并实现它，再进行使用了。



# <a id="s-interfaces"></a>I: 接口

接口是程序中的两个部分之间的契约。严格地规定服务提供者和该服务使用者的预期是必要的。
在代码的组织中，良好的接口（易于理解，促进高效的使用方式，不易出错，支持进行测试，等等）可能是最重要的单个方面了。

接口规则概览：

* [I.1: 使接口明确](#ri-explicit)
* [I.2: 避免非 `const` 全局变量](#ri-global)
* [I.3: 避免使用单例](#ri-singleton)
* [I.4: 使接口严格和强类型化](#ri-typed)
* [I.5: 说明前条件（如果有）](#ri-pre)
* [I.6: 优先使用 `Expects()` 来表达前条件](#ri-expects)
* [I.7: 说明后条件](#ri-post)
* [I.8: 优先使用 `Ensures()` 来表达后条件](#ri-ensures)
* [I.9: 当接口是模板时，用概念来文档化其参数](#ri-concepts)
* [I.10: 使用异常来表明无法实施所要求的任务](#ri-except)
* [I.11: 决不以原始指针（`T*`）或引用（`T&`）来传递所有权](#ri-raw)
* [I.12: 把不能为空的指针声明为 `not_null`](#ri-nullptr)
* [I.13: 不要只用一个指针来传递数组](#ri-array)
* [I.22: 避免全局对象之间进行复杂的初始化](#ri-global-init)
* [I.23: 保持较少的函数参数数量](#ri-nargs)
* [I.24: 避免可以由同一组实参以不同顺序调用造成不同含义的相邻形参](#ri-unrelated)
* [I.25: 优先以空抽象类作为类层次的接口](#ri-abstract)
* [I.26: 当想要跨编译器的 ABI 时，使用一个 C 风格的语言子集](#ri-abi)
* [I.27: 对于稳定的程序库 ABI，考虑使用 Pimpl 手法](#ri-pimpl)
* [I.30: 将有违规则的部分封装](#ri-encapsulate)

**参见**

* [F: 函数](#s-functions)
* [C.concrete: 具体类型](#ss-concrete)
* [C.hier: 类层次](#ss-hier)
* [C.over: 函数重载和重载运算符](#ss-overload)
* [C.con: 容器和其他资源封装类](#ss-containers)
* [E: 错误处理](#s-errors)
* [T: 模板和泛型编程](#s-templates)

### <a id="ri-explicit"></a>I.1: 使接口明确

##### 理由

正确性。未在接口中规定的假设很容易被忽视而且难于测试。

##### 示例，不好

通过全局（命名空间作用域）变量（调用模式）来控制函数的行为，是隐含的，而且潜在会造成困惑。例如：

    int round(double d)
    {
        return (round_up) ? ceil(d) : d;    // 请勿：“不可见的”依赖
    }

两次调用 `round(7.2)` 的含义可能给出不同的结果，这对于调用者来说是不明显的。

##### 例外

我们有时候会通过环境变量来控制一组操作的细节，比如常规/详细的输出，或者调试/优化版本。
使用非局部的控制方式可能带来困惑，但可以只用来控制实现的细节，否则就只有固定的语义了。

##### 示例，不好

通过非局部变量（比如 `errno`）进行的报告经常被忽略。例如：

    // 请勿如此：fprintf 的返回值未进行检查
    fprintf(connection, "logging: %d %d %d\n", x, y, s);

要是连接已经关闭而导致没有产生日志输出的话会怎么样？参见 I.???。

**替代方案**: 抛出异常。异常是无法被忽略的。

**其他形式**: 避免通过非局部或者隐含的状态来跨越接口传递信息。
注意，非 `const` 的成员函数会通过对象的状态来向其他成员函数传递信息。

**其他形式**: 接口应当是函数或者一组函数集合。
函数可以是函数模板，而函数集合可以是类或者类模板。

##### 强制实施

* 【简单】 函数不能基于声明于命名空间作用域的变量来作出影响控制流的决定。
* 【简单】 函数不能对声明于命名空间作用域的变量进行写入操作。

### <a id="ri-global"></a>I.2: 避免非 `const` 全局变量

##### 理由

非 `const` 全局变量能够隐藏依赖关系，并使这些依赖项可能出现无法预测的变动。

##### 示例

    struct Data {
        // ... 大量成员 ...
    } data;            //  非 const 数据

    void compute()     // 请勿这样做
    {
        // ... 使用 data ...
    }

    void output()     // 请勿这样做
    {
        // ... 使用 data ...
    }

哪个可能会修改 `data` 呢？

**警告**: 全局对象的初始化并不是完全有序的。
当使用全局对象时，应当用常量为之初始化。
还要注意，即便对于 `const` 对象，也可能发生未定义的初始化顺序。

##### 例外

全局对象通常优于单例。

##### 注解

全局常量是有益的。

##### 注解

针对全局变量的规则同样适用于命名空间作用域的变量。

**替代方案**: 如果你用全局（或者更一般地说命名空间作用域）数据来避免复制操作的话，请考虑把数据以 `const` 引用的形式进行传递的方案。
另一种方案是把数据定义为某个对象的状态，而把操作定义为其成员函数。

**警告**: 请关注数据竞争：当一个线程能够访问非局部数据（或以引用传递的数据），而另一个线程执行被调用的函数时，就可能带来数据竞争。
指向可变数据的每个指针或引用都是潜在的数据竞争。

使用全局指针或引用来访问和修改非 const 且非局部的数据，并非是比非 const 全局变量更好的替代方案，
这是因为它并不能解决隐藏依赖性或潜在竞争条件的问题。

##### 注解

不可变数据是不会带来数据竞争条件的。

**参见**: 另见[关于调用函数的规则](#ss-call)。

#### 注解

这条规则是“避免”，而不是“不要用”。当然是有（罕见）例外的，比如 `cin`、`cout` 和 `cerr`。

##### 强制实施

【简单】 报告所有在命名空间作用域中声明的非 `const` 变量和全局的指向非 const 数据的指针/引用。


### <a id="ri-singleton"></a>I.3: 避免使用单例

##### 理由

单例基本上就是经过伪装的更复杂的全局对象。

##### 示例

    class Singleton {
        // ... 大量代码，用于确保只创建一个 Singleton，
        // 进行正确地初始化，等等
    };

单例的想法有许多变种。
这也是问题的一方面。

##### 注解

如果不想让全局对象被改变，请将其声明为 `const` 或 `constexpr`。

##### 例外

你可以使用最简单的“单例”形式（简单到通常不被当作单例）来获得首次使用时进行初始化的效果：

    X& myX()
    {
        static X my_x {3};
        return my_x;
    }

这是解决初始化顺序相关问题的最有效方案之一。
在多线程环境中，静态对象的初始化并不会引入数据竞争条件
（除非你不小心在其构造函数中访问了某个共享对象）。

注意局部的 `static` 对象初始化并不会蕴含竞争条件。
不过，如果 `X` 的销毁中涉及了需要进行同步的操作的话，我们就得用一个不那么简单的方案。
例如：

    X& myX()
    {
        static auto p = new X {3};
        return *p;  // 有可能泄漏
    }

这样就必须有人以某种适当的线程安全方式来 `delete` 这个对象了。
这是容易出错的，因此除了以下情况外我们并不使用这种技巧：

* `myX` 是在多线程代码中，
* 这个 `X` 对象需要销毁（比如由于它要释放某个资源），而且
* `X` 的析构函数的代码需要进行同步。

如果你和许多人一样把单例定义为只能创建一个对象的类的话，像 `myX` 这样的函数并非单例，而且这种好用的技巧并不算无单例规则的例外。

##### 强制实施

通常非常困难。

* 查找名字中包含 `singleton` 的类。
* 查找只创建一个对象的类（通过对对象计数或者检查其构造函数）。
* 如果某个类 X 具有公开的静态函数，并且它包含具有该类 X 类型的函数级局部静态变量并返回指向它的指针或者引用，就禁止它。

### <a id="ri-typed"></a>I.4: 使接口严格和强类型化

##### 理由

类型是最简单和最好的文档，它们有定义明确的含义并因而提高了易读性，并且是在编译期进行检查的。
而且，严格类型化的代码通常也能更好地进行优化。

##### 示例，请勿这样做

考虑：

    void pass(void* data);    // 使用弱的并且缺乏明确性的类型 void* 是有问题的

调用者无法确定它允许使用哪些类型，而且因为它并没有指定 `const`，
也不确定其数据是否会被改动。注意，任何指针类型都可以隐式转换为 `void*`，
因此调用者很容易提供这样的值给它。

被调用方必须以 `static_cast` 将数据强制转换为某个无验证的类型以使用它。
这样做易于犯错，而且啰嗦。

应当仅在设计中无法以 C++ 来予以描述的数据的传递时才使用 `const void*`。请考虑使用 `variant` 或指向基类的指针来代替它。

**替代方案**: 通常，利用模板形参可以把 `void*` 排除而改为 `T*` 或者 `T&`。
对于泛型代码，这些个 `T` 可以是一般模板参数或者是概念约束的模板参数。

##### 示例，不好

考虑：

    draw_rect(100, 200, 100, 500); // 这些数值什么意思？

    draw_rect(p.x, p.y, 10, 20); // 10 和 20 的单位是什么？

很明显调用者在描述一个矩形，不明确的是它们都和其哪些部分相关。而且 `int` 可以表示任何形式的信息，包括各种不同单位的值，因此我们必须得猜测这四个 `int` 的含义。前两个很可能代表坐标对偶 `x` 和 `y`，但后两个是什么呢？

注释和参数的名字可以有所帮助，但我们可以直截了当：

    void draw_rectangle(Point top_left, Point bottom_right);
    void draw_rectangle(Point top_left, Size height_width);

    draw_rectangle(p, Point{10, 20});  // 两个角点
    draw_rectangle(p, Size{10, 20});   // 一个角和一对 (height, width)

显然，我们是无法利用静态类型系统识别所有的错误的，
例如，假定第一个参数是左上角这一点就依赖于约定（命名或者注释）。

##### 示例，不好

考虑：

    set_settings(true, false, 42); // 这些数值什么意思？

各参数类型及其值并不能表明其所指定的设置项是什么以及它们的值所代表的含义。

下面的设计则更加明确，安全且易读：

    alarm_settings s{};
    s.enabled = true;
    s.displayMode = alarm_settings::mode::spinning_light;
    s.frequency = alarm_settings::every_10_seconds;
    set_settings(s);

对于一组布尔值的情况，可以考虑使用某种标记 `enum`；这是一种用于表示一组布尔值的模式。

    enable_lamp_options(lamp_option::on | lamp_option::animate_state_transitions);

##### 示例，不好

下例中，接口中并未明确给出 `time_to_blink` 的含义：按秒还是按毫秒算？

    void blink_led(int time_to_blink) // 不好 -- 在单位上含糊
    {
        // ...
        // 对 time_to_blink 做一些事
        // ...
    }

    void use()
    {
        blink_led(2);
    }

##### 示例，好

`std::chrono::duration` 类型可以让时间段的单位明确下来。

    void blink_led(milliseconds time_to_blink) // 好 -- 单位明确
    {
        // ...
        // 对 time_to_blink 做一些事
        // ...
    }

    void use()
    {
        blink_led(1500ms);
    }

这个函数还可以写成使其接受任何时间段单位的形式。

    template<class rep, class period>
    void blink_led(duration<rep, period> time_to_blink) // 好 -- 接受任何单位
    {
        // 假设最小的有意义单位是毫秒
        auto milliseconds_to_blink = duration_cast<milliseconds>(time_to_blink);
        // ...
        // 对 milliseconds_to_blink 做一些事
        // ...
    }

    void use()
    {
        blink_led(2s);
        blink_led(1500ms);
    }

##### 强制实施

* 【简单】 报告将 `void*` 用作参数或返回类型的情况
* 【简单】 报告使用了多个 `bool` 参数的情况
* 【难于做好】 查找使用了过多基础类型的参数的函数。

### <a id="ri-pre"></a>I.5: 说明前条件（如果有）

##### 理由

在参数上蕴含着使它们在被调用方中能够恰当使用的约束关系。

##### 示例

考虑：

    double sqrt(double x);

这里 `x` 必须是非负数。类型系统是无法（简洁并自然地）表达这点的，因而我们得用别的方法。例如：

    double sqrt(double x); // x 必须是非负数

一些前条件可以表示为断言。例如：

    double sqrt(double x) { Expects(x >= 0); /* ... */ }

理想情况下，这个 `Expects(x >= 0)` 应当是 `sqrt()` 的接口的一部分，但我们无法轻易做到这点。当前，我们将之放入定义式（函数体）之中。

**参考**: `Expects()` 在 [GSL](#gsl-guidelines-support-library) 中有说明。

##### 注解

优先使用正式的必要条件说明，比如 `Expects(!p);`。
如果这样不可行，就在注释中使用文字来说明，比如 `// 序列 [p:q) 根据 < 排序`。

##### 注解

许多成员函数都以某个类所保持的不变式作为一项前条件。
这个不变式是由构造函数所建立的，且必须在被从类之外所调用的每个成员函数的退出时重新建立。
我们并不需要对每个成员函数都说明这个不变式。

##### 强制实施

【无法强制实施】

**参见**: 有关传递指针的规则。???

### <a id="ri-expects"></a>I.6: 优先使用 `Expects()` 来表达前条件

##### 理由

清晰地表明这个条件是一个前条件，并便于工具的利用。

##### 示例

    int area(int height, int width)
    {
        Expects(height > 0 && width > 0);            // 好
        if (height <= 0 || width <= 0) my_error();   // 隐晦的
        // ...
    }

##### 注解

前条件是可以用许多方式来说明的，包括代码注释，`if` 语句，以及 `assert()`。
这些方式使其难于与普通代码之间进行区分，难于进行更新，难于利用工具来操作，而且可能具有错误的语义（你真的总是想要在调试模式中止程序而在生产运行中不做任何检查吗？）

##### 注解

前条件应当是接口的一部分，而不是实现的一部分，
但我们至今还没有能够做到这点的语言设施。
一旦语言支持变为可用（例如，参见[契约提案](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)），我们就将会采用前条件，后条件和断言的标准版本。

##### 注解

`Expects()` 还可以用于在算法的中部来检查某个条件。

##### 注解

使用 `unsigned` 并不是回避[确保非负数值](#res-nonnegative)问题的好方法。

##### 强制实施

【无法强制实施】 要把各种对前条件进行断言的方式都找出来是不可行的。对那些易于识别的（如 `assert()`）实例给出警告的做法，其意义在缺少语言设施的前提下是有问题的。

### <a id="ri-post"></a>I.7: 说明后条件

##### 理由

以检测到对返回结果的误解，还可能发现实现中存在错误。

##### 示例，不好

考虑：

    int area(int height, int width) { return height * width; }  // 不好

这里，我们（粗心大意地）遗漏了前条件的说明，因此高度和宽度必须是正数这点是不明确的。
我们也遗漏了后条件的说明，因此算法（`height * width`）对于大于最大整数的面积来说是错误的这点是不明显的。
可能会有溢出。
应该考虑使用：

    int area(int height, int width)
    {
        auto res = height * width;
        Ensures(res > 0);
        return res;
    }

##### 示例，不好

考虑一个著名的安全性 BUG：

    void f()    // 有问题的
    {
        char buffer[MAX];
        // ...
        memset(buffer, 0, sizeof(buffer));
    }

由于没有后条件来说明缓冲区应当被清零，优化器可能会将这个看似多余的 `memset()` 调用给清除掉：

    void f()    // 有改进
    {
        char buffer[MAX];
        // ...
        memset(buffer, 0, sizeof(buffer));
        Ensures(buffer[0] == 0);
    }

##### 注解

后条件通常是在说明函数目的的代码注释中非正式地进行说明的；用 `Ensures()` 可以使之更加系统化，更加明显，并且更容易检查。

##### 注解

后条件对于那些无法在所返回的结果中直接体现的东西来说尤其重要，比如要说明所用的数据结构。

##### 示例

考虑一个操作 `Record` 的函数，它使用 `mutex` 来避免数据竞争条件：

    mutex m;

    void manipulate(Record& r)    // 请勿这样做
    {
        m.lock();
        // ... 没有 m.unlock() ...
    }

这里，我们“忘记”说明应当释放 `mutex`，因此我们搞不清楚这里 `mutex` 释放的缺失是一个 BUG 还是一种功能特性。
把后条件说明将使其更加明确：

    void manipulate(Record& r)    // 后条件: m 在退出后是未锁定的
    {
        m.lock();
        // ... 没有 m.unlock() ...
    }

现在这个 BUG 就明显了（但仅对阅读了代码注释的人类来说）。

更好的做法是使用 [RAII](#rr-raii) 来在代码中保证后条件（“锁必须进行释放”）的实施：

    void manipulate(Record& r)    // 最好这样
    {
        lock_guard<mutex> _ {m};
        // ...
    }

##### 注解

理想情况下，后条件应当在接口或声明式中说明，让使用者易于见到它们。
只有那些与使用者有关的后条件才应当在接口中说明。
仅与内部状态相关的后条件应当属于定义式或实现。

##### 强制实施

【无法强制实施】 这是一条理念性的指导方针，一般情况下进行直接的
检查是不可行的。不过许多工具链中都有适用于特定领域的检查器，
比如针对锁定持有情况的检查器。

### <a id="ri-ensures"></a>I.8: 优先使用 `Ensures()` 来表达后条件

##### 理由

清晰地表明这个条件是一个后条件，并便于工具的利用。

##### 示例

    void f()
    {
        char buffer[MAX];
        // ...
        memset(buffer, 0, MAX);
        Ensures(buffer[0] == 0);
    }

##### 注解

后条件是可以用许多方式来说明的，包括代码注释，`if` 语句，以及 `assert()`。
这些方式使其难于与普通代码之间进行区分，难于进行更新，难于利用工具来操作，而且可能具有错误的语义。

**替代方案**: 如“这个资源必须被释放”这样形式的后条件最好以 [RAII](#rr-raii) 的方式来表达。

##### 注释

理想情况下，`Ensures` 应当是接口的一部分，但我们无法轻易做到这点。
当前，我们将之放入定义式（函数体）之中。
一旦语言支持变为可用（例如，参见[契约提案](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)），我们就将会采用前条件，后条件和断言的标准版本。

##### 强制实施

【无法强制实施】 要把各种对后条件进行断言的方式都找出来是不可行的。对那些易于识别的（如 `assert()`）实例给出警告的做法，其意义在缺少语言设施的前提下是有问题的。

### <a id="ri-concepts"></a>I.9: 当接口是模板时，用概念来文档化其参数

##### 理由

更严谨地说明接口，并使其在（不远的）将来可以在编译时进行检查。

##### 示例

使用 C++20 风格的必要条件说明。例如：

    template<typename Iter, typename Val>
      requires input_iterator<Iter> && equality_comparable_with<iter_value_t<Iter>, Val>
    Iter find(Iter first, Iter last, Val v)
    {
        // ...
    }

**参见**: [泛型编程](#ss-gp)和[概念](#ss-concepts)。

##### 强制实施

对未被概念所约束（在其声明式之中或者在一个 `requires` 子句中所给出）的并非可变数量的模板形参作出警告。

### <a id="ri-except"></a>I.10: 使用异常来表明无法实施所要求的任务

##### 理由

不应该让错误可以被忽略，因为这将导致系统或者一次运算进入未定义的（或者预料之外的）状态。
这是错误的一个主要来源。

##### 示例

    int printf(const char* ...);    // 不好: 当输出失败时返回负值

    template<class F, class ...Args>
    // 好: 当无法启动一个新的线程时抛出 system_error
    explicit thread(F&& f, Args&&... args);

##### 注解

错误是什么？

错误的含义是函数无法达成其所宣称的目标（这包括后条件的建立）。
把错误忽略掉的调用方代码将导致错误的结果，或者未定义的系统状态。
例如，无法连接一个远程服务器本身并不是错误：
这个服务器可以因为各种原因而拒绝连接，因此合乎常理的方式是让其返回一个其调用者必然要检查的结果。
不过，如果无法连接本身就是被当作一种错误的话，这个失败时应当抛出一个异常。

##### 例外

许多传统的接口函数（比如 UNIX 的信号处理器）都使用错误代码（就是 `errno`）来报告其实是状态代码而不是错误的东西。你没有更好的选择只能用它，因此对其调用并不违反本条规则。

##### 替代方案

如果你不能使用异常（比如说由于你的代码全都是老式的原始指针用法，或者由于你有硬实时性的约束），请考虑使用返回一对值的代码风格：

    int val;
    int error_code;
    tie(val, error_code) = do_something();
    if (error_code) {
        // ... 处理错误或者退出 ...
    }
    // ... 使用 val ...

这种风格不幸地会导致未初始化的变量。
从 C++17 开始，可以使用 "结构化绑定" 功能特性来从返回值直接对多个变量初始化。

    auto [val, error_code] = do_something();
    if (error_code) {
        // ... 处理错误或者退出 ...
    }
    // ... 使用 val ...

##### 注解

我们并不认为“性能”是一种不使用异常的合理理由。

* 通常，显式的错误检查和处理会消耗掉和异常处理一样多的时间和空间。
* 通常，使用异常的更清晰的代码会带来更好的性能（简化了对程序执行路径的追踪和其优化）。
* 一条对性能关键代码的好规则是，把检查从代码的[关键](#rper-critical)部分中移出去。
* 长期来看，更规整的代码会得到更好的优化。
* 在做出性能相关的声明前一定要小心地[进行测量](#rper-measure)。

**参见**: [I.5](#ri-pre) 和 [I.7](#ri-post) 有关报告前条件和后条件的违反。

##### 强制实施

* 【无法强制实施】 这是一条理念性的指导方针，进行直接的检查是不可行的。
* 查找 `errno`。

### <a id="ri-raw"></a>I.11: 决不以原始指针（`T*`）或引用（`T&`）来传递所有权

##### 理由

如果对调用者和被调用方哪一个拥有对象有疑问，那就会造成泄漏或者发生提早的析构。

##### 示例

考虑：

    X* compute(args)    // 请勿这样做
    {
        X* res = new X{};
        // ...
        return res;
    }

应当由谁来删除返回的这个 `X` 呢？如果 `compute` 返回引用的话这个问题将更难发现。
应该考虑按值来返回结果（如果结果比较大的话就用移动语义）：

    vector<double> compute(args)  // 好的
    {
        vector<double> res(10000);
        // ...
        return res;
    }

**替代方案**: 用“智能指针”来[传递所有权](#rr-smartptrparam)，比如 `unique_ptr`（专有所有权）和 `shared_ptr`（共享所有权）。
这样做比返回对象自身来说并没有那么简炼，而且通常也不那么高效，
因此，仅当需要引用语义时再使用智能指针。

**替代方案**: 有时候因为 ABI 兼容性的要求或者缺少资源，是无法对老代码进行修改的。
这种情况下，请用[指导方针支持库](#gsl-guidelines-support-library)的 `owner` 来标记拥有对象的指针：

    owner<X*> compute(args)    // 现在就明确传递了所有权这一点
    {
        owner<X*> res = new X{};
        // ...
        return res;
    }

这告诉了分析工具 `res` 是一个所有者。
就是说，它的值必须被 `delete`，或者被传递给另一个所有者，正如这里的 `return` 所做。

在资源包装类的实现中也同样使用了 `owner`。

##### 注解

以原始指针（或迭代器）的形式传递的对象，都假定是由调用方
所有的，因此其生存期也由调用方来处理。换种方式来看：
传递所有权的 API 相对于传递指针的 API 来说比较少见，
因此缺省情况就是“不传递所有权”。

**参见**: [实参传递](#rf-conventional)，[使用智能指针参数](#rr-smartptrparam)，以及[返回值](#rf-value-return)。

##### 强制实施

* 【简单】 当对并非 `owner<T>` 的原始指针进行 `delete` 就发出警告。建议使用标准库的资源包装或者使用 `owner<T>`。
* 【简单】 当任何代码路径上遗漏了对 `owner` 指针的 `reset` 或者显式的 `delete` 时就发出警告。
* 【简单】 当把 `new` 或者返回值为 `owner` 的函数的返回值赋值给原始指针或非 `ower` 的引用时就发出警告。

### <a id="ri-nullptr"></a>I.12: 把不能为空的指针声明为 `not_null`

##### 理由

帮助避免对 `nullptr` 解引用的错误。
通过避免多余的 `nullptr` 检查来提高性能。

##### 示例

    int length(const char* p);            // 不清楚 length(nullptr) 是否有效

    length(nullptr);                      // OK?

    int length(not_null<const char*> p);  // 有改善：可以假定 p 不可能为 nullptr

    int length(const char* p);            // 只好假定 p 可以为 nullptr

通过在源代码中说明意图，实现者和工具就可以提供更好的诊断能力，比如通过静态分析来找出某些种类的错误，还可以实施优化，比如移除分支和空值测试。

##### 注解

`not_null` 在[指导方针支持库](#gsl-guidelines-support-library)中定义。

##### 注解

指向 `char` 的指针将指向 C 风格的字符串（以零终结的字符的连续串）这一点仍然是潜规则，并且也是混乱和错误的潜在来源。请使用 `czstring` 来代替 `const char*`。

    // 可以假定 p 不能为 nullptr
    // 可以假定 p 指向以零终结的字符数组
    int length(not_null<zstring> p);

注意： `length()` 显然是经过伪装的 `std::strlen()`。

##### 强制实施

* 【简单】〔基础〕 如果有函数在所有控制流路径上访问指针参数之前检查它是否是 `nullptr`，则给出警告称其应当被声明为 `not_null`。
* 【复杂】 如果有指针返回值的函数在所有返回路径上都保证其不是 `nullptr`，则给出警告称返回类型应当被声明为 `not_null`。

### <a id="ri-array"></a>I.13: 不要只用一个指针来传递数组

##### 理由

 (pointer, size) 式的接口是易于出错的。同样，（指向数组的）普通指针还必须依赖某种约定以使被调用方来确定其大小。

##### 示例

考虑：

    void copy_n(const T* p, T* q, int n); // 从 [p:p+n) 复制到 [q:q+n)

当由 `q` 所指向的数组少于 `n` 个元素会怎么样？此时我们将覆写一些可能无关的内存。
当由 `p` 所指向的数组少于 `n` 个元素会怎么样？此时我们将读取一些可能无关的内存。
此二者都是未定义的行为，而且可能是非常恶劣的 BUG。

##### 替代方案

考虑使用明确的 `span`：

    void copy(span<const T> r, span<T> r2); // 将 r 复制给 r2

##### 示例，不好

考虑：

    void draw(Shape* p, int n);  // 糟糕的接口；糟糕的代码
    Circle arr[10];
    // ...
    draw(arr, 10);

把 `10` 作为参数 `n` 传递可能是错误的：虽然最常见的约定是假定有 `[0:n)`，但这点并未不是明确的。更糟糕的是，`draw()` 的调用通过编译了：这里有一次从数组到指针的隐式转换（数组退化），然后又进行了从 `Circle` 到 `Shape` 的另一次隐式转换。`draw()` 是不可能安全地迭代这个数组的：它无法知道元素的大小。

**替代方案**: 使用一个辅助类来确保元素的数量正确，并避免进行危险的隐式转换。例如：

    void draw2(span<Circle>);
    Circle arr[10];
    // ...
    draw2(span<Circle>(arr));  // 推断出元素的数量
    draw2(arr);    // 推断出元素的类型和数组大小

    void draw3(span<Shape>);
    draw3(arr);    // 错误: 无法将 Circle[10] 转换为 span<Shape>

这个 `draw2()` 传递了与 `draw()` 同样数量的信息，但明确指定了它接受的是 `Circle` 的范围。参见 ???.

##### 例外

使用 `zstring` 和 `czstring` 来表示 C 风格的以零终结字符串。
但这样做时，应当使用 `std::string_view` 或 [GSL](#gsl-guidelines-support-library) 中的 `span<char>` 以避免范围错误。

##### 强制实施

* 【简单】〔边界〕 对任何依赖于从数组类型向指针类型的隐式转换的表达式给出警告。允许 zstring/czstring 指针类型的例外。
* 【简单】〔边界〕 对任何指针类型表达式进行且结果为指针类型的值的运算操作给出警告。允许 zstring/czstring 指针类型的例外。

### <a id="ri-global-init"></a>I.22: 避免全局对象之间进行复杂的初始化

##### 理由

复杂的初始化可能导致未定义的执行顺序。

##### 示例

    // file1.c

    extern const X x;

    const Y y = f(x);   // 读取 x; 写入 y

    // file2.c

    extern const Y y;

    const X x = g(y);   // 读取 y; 写入 x

由于 `x` 和 `y` 是处于不同翻译单元之内的，调用 `f()` 和 `g()` 的顺序就是未定义的；
我们可能会访问到还未初始化的 `const` 对象。
这里展示的是，全局（命名空间作用域）对象的初始化顺序难题并不仅限于全局*变量*而已。

##### 注解

并发代码中的初始化顺序问题是更加难于处理的。
所以通常最好完全避免使用全局（命名空间作用域）的对象。

##### 强制实施

* 标记调用了非 `constexpr` 函数的全局初始化式
* 标记访问了 `extern` 对象的全局初始化式

### <a id="ri-nargs"></a>I.23: 保持较少的函数参数数量

##### 理由

大量参数会带来更大的出现混乱的机会。大量传递参数与其他替代方案相比也通常是代价比较大的。

##### 讨论

两个最常见的使得函数具有过多参数的原因是：

1. *缺乏抽象*
   缺少一种抽象，使得一个组合值被以
   一组独立的元素的方式进行传递，而不是以一个单独的保证了不变式的对象来传递。
   这不仅使其参数列表变长，而且会导致错误，
   因为各个成分值无法再被某种获得保证的不变式进行保护。

2. *违反了“函数单一职责”原则*
   这个函数试图完成多项任务，它可能应当被重构。

##### 示例

标准库的 `merge()` 函数达到了我们可以自如处理的界限：

    template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result, Compare comp);

注意，这属于上面的第一种问题：缺乏抽象。STL 传递的不是范围（抽象），而是一对迭代器（未封装的成分值）。

其中有四个模板参数和六个函数参数。
为简化最常用和最简单的用法，比较器参数可以缺省使用 `<`：

    template<class InputIterator1, class InputIterator2, class OutputIterator>
    OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result);

这实际上不会减低其整体复杂性，但它减少了对于许多使用者的表面复杂性。
为了真正地减少参数的数量，我们得把参数归拢到更高层的抽象之中：

    template<class InputRange1, class InputRange2, class OutputIterator>
    OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);

把参数成“批”进行组合是减少参数数量和增加进行检查的机会的一般性技巧。

或者，我们也可以用标准库概念来定义“三个类型必须可以用于归并”：

    template<class In1, class In2, class Out>
      requires mergeable<In1, In2, Out>
    Out merge(In1 r1, In2 r2, Out result);

##### 示例

安全性剖面配置中建议将以下代码

    void f(int* some_ints, int some_ints_length);  // 不好：C 风格，不安全

替换为

    void f(gsl::span<int> some_ints);              // 好：安全，有边界检查

这样，使用一种抽象可以获得安全性和健壮性的好处，而且自然地减少了参数的数量。

##### 注解

多少参数算很多？请使用少于四个参数。
有些函数确实最好表现为四个独立的参数，但这样的函数并不多。

**替代方案**: 使用更好的抽象：把参数归集为由意义的对象，然后（按值或按引用）传递这些对象。

**替代方案**: 利用默认实参或者重载来让最常见的调用方式可以用比较少的实参来进行。

##### 强制实施

* 当函数声明了两个类型相同的迭代器（也包括指针）而不是一个范围或视图，就给出警告。
* 【无法强制实施】 这是一条理念性的指导方针，进行直接的检查是不可行的。

### <a id="ri-unrelated"></a>I.24: 避免可以由同一组实参以不同顺序调用造成不同含义的相邻形参

##### 理由

相同类型的相邻参数很容易被不小心互换掉。

##### 示例，不好

考虑：

    void copy_n(T* p, T* q, int n);  // 从 [p:p + n) 复制到 [q:q + n)

这是个 K&R C 风格接口的一种恶劣的变种。它导致很容易把“目标”和“来源”参数搞反。

可以在“来源”参数上使用 `const`：

    void copy_n(const T* p, T* q, int n);  // 从 [p:p + n) 复制到 [q:q + n)

##### 例外

当参数的顺序不重要时，不会造成问题：

    int max(int a, int b);

##### 替代方案

不要以指针来传递数组，而要传递用来表示一个范围的对象（比如一个 `span`）：

    void copy_n(span<const T> p, span<T> q);  // 从 p 复制到 q

##### 替代方案

定义一个 `struct` 来作为参数类型，并依照各个参数来命名它的各字段：

    struct SystemParams {
        string config_file;
        string output_path;
        seconds timeout;
    };
    void initialize(SystemParams p);

这样做带来一种使其调用代码对于以后的读者变得明晰的倾向，因为这种参数
在调用点通常都要按名字来进行填充。

##### 注解

只有接口设计者才能胜任处理违反本条指导方针的源头问题。

##### 强制实施策略

【简单】 当两个连续的参数具有相同的类型时就给出警告。

我们仍在寻找不这么简单的强制实施方式。

### <a id="ri-abstract"></a>I.25: 优先以空抽象类作为类层次的接口

##### 理由

空的（没有非静态成员数据）抽象类要比带有状态的基类更倾向于保持稳定。

##### 示例，不好

你知道 `Shape` 总会冒出来的 :-)

    class Shape {  // 不好: 接口类中加载了数据
    public:
        Point center() const { return c; }
        virtual void draw() const;
        virtual void rotate(int);
        // ...
    private:
        Point c;
        vector<Point> outline;
        Color col;
    };

这将强制性要求每个派生类都要计算出一个中心点——即使这并不容易，而且这个中心点从不会被用到。相似地说，不是每个 `Shape` 都有一个 `Color`，而许多 `Shape` 也最好别用一个定义成一系列 `Point` 的轮廓来进行表示。使用抽象类要更好：

    class Shape {    // 有改进: Shape 是一个纯接口
    public:
        virtual Point center() const = 0;   // 纯虚函数
        virtual void draw() const = 0;
        virtual void rotate(int) = 0;
        // ...
        // ... 没有数据成员 ...
        // ...
        virtual ~Shape() = default;
    };

##### 强制实施

【简单】 当把类 `C` 的指针/引用赋值给 `C` 的某个基类的指针/引用，而这个基类包含数据成员时，就给出警告。

### <a id="ri-abi"></a>I.26: 当想要跨编译器的 ABI 时，使用一个 C 风格的语言子集

##### 理由

不同的编译器会实现不同的类的二进制布局，异常处理，函数名字，以及其他的实现细节。

##### 例外

在一些平台上正有公共的 ABI 兴起，这可以使你从更加苛刻的限制中摆脱出来。

##### 注解

如果你只用一种编译器，你也可以在接口上使用完全的 C++。但当升级到新的编译器版本之后，可能需要进行重新编译。

##### 强制实施

【无法强制实施】 要可靠地识别某个接口是否是构成 ABI 的一部分是很困难的。

### <a id="ri-pimpl"></a>I.27: 对于稳定的程序库 ABI，考虑使用 Pimpl 手法

##### 理由

由于私有数据成员参与类的内存布局，而私有成员函数参与重载决议，
对这些实现细节的改动都要求使用了这类的所有用户全部重新编译。而持有指向实现的指针（Pimpl）的
非多态的接口类，则可以将类的用户从其实现的改变隔离开来，其代价是一层间接。

##### 示例

接口（widget.h）

    class widget {
        class impl;
        std::unique_ptr<impl> pimpl;
    public:
        void draw(); // 公开 API 转发给实现
        widget(int); // 定义于实现文件中
        ~widget();   // 定义于实现文件中，其中 impl 将为完整类型
        widget(widget&&) noexcept; // 定义于实现文件中
        widget(const widget&) = delete;
        widget& operator=(widget&&) noexcept; // 定义于实现文件中
        widget& operator=(const widget&) = delete;
    };


实现（widget.cpp）

    class widget::impl {
        int n; // private data
    public:
        void draw(const widget& w) { /* ... */ }
        impl(int n) : n(n) {}
    };
    void widget::draw() { pimpl->draw(*this); }
    widget::widget(int n) : pimpl{std::make_unique<impl>(n)} {}
    widget::widget(widget&&) noexcept = default;
    widget::~widget() = default;
    widget& widget::operator=(widget&&) noexcept = default;

##### 注解

参见 [GOTW #100](https://herbsutter.com/gotw/_100/) 和 [cppreference](http://en.cppreference.com/w/cpp/language/pimpl) 有关这个手法相关的权衡和其他实现细节。

##### 强制实施

【无法强制】 很难可靠地识别出哪个接口属于 ABI 的一部分。

### <a id="ri-encapsulate"></a>I.30: 将有违规则的部分封装

##### 理由

维持代码简单且安全。
有时候因为逻辑的或者性能的原因，需要使用难看的，不安全的或者易错的技术。
此时，将它们局部化，而不是使其“感染”接口，可以避免更多的程序员团队必须当心其
细节和微妙之处。
如果可能的话，实现复杂度不能通过接口渗透到用户代码之中。

##### 示例

考虑一个程序，其基于某种形式的输入（比如 `main` 的实参）来决定
从文件，从命令行，还是从标准输入来获得输入数据。
我们可能会将其写成

    bool owned;
    owner<istream*> inp;
    switch (source) {
    case std_in:        owned = false; inp = &cin;                       break;
    case command_line:  owned = true;  inp = new istringstream{argv[2]}; break;
    case file:          owned = true;  inp = new ifstream{argv[2]};      break;
    }
    istream& in = *inp;

这违反了[避免未初始化变量](#res-always)，
[避免忽略所有权](#ri-raw)，
和[避免魔法常量](#res-magic)等规则。
尤其是，人们必须记得找地方写

    if (owned) delete inp;

我们可以通过使用带有一个特殊的删除器（对 `cin` 不做任何事）的 `unique_ptr` 来处理这个特定的例子，
但这对于新手来说较复杂（他们很容易遇到这种问题），并且这个例子其实是一个更一般的问题的特例：
我们希望将其当做静态的某种属性（此处为所有权），需要在运行时进行
偶尔的处理。
一般的，更常见的，且更安全的例子可以被静态处理，因而我们并不希望为它们添加开销和复杂性。
然而我们还是不得不处理那些不常见的，较不安全的，而且更为昂贵的情况。
[[Str15]](http://www.stroustrup.com/resource-model.pdf) 中对这种例子有所探讨。

由此，我们编写这样的类

    class Istream { [[gsl::suppress(lifetime)]]
    public:
        enum Opt { from_line = 1 };
        Istream() { }
        Istream(zstring p) : owned{true}, inp{new ifstream{p}} {}            // 从文件读取
        Istream(zstring p, Opt) : owned{true}, inp{new istringstream{p}} {}  // 从命令行读取
        ~Istream() { if (owned) delete inp; }
        operator istream& () { return *inp; }
    private:
        bool owned = false;
        istream* inp = &cin;
    };

这样，`istream` 的所有权的动态本质就被封装起来。
大体上，在现实的代码中还是需要针对潜在的错误添加一些检查。

##### 强制实施

* 很难，判断那种违背规则的代码是基本的是很难做到的
* 对允许规则违背的部分跨越接口的规则抑制进行标记








# <a id="s-enum"></a>Enum: 枚举

枚举用于定义整数值的集合，并用于为这种值集定义类型。有两种类型的枚举，
“普通”的 `enum` 和 `class enum`。

枚举规则概览：

* [Enum.1: 优先采用枚举而不是宏](#renum-macro)
* [Enum.2: 采用枚举来表示相关的具名常量的集合](#renum-set)
* [Enum.3: 优先采用 `enum class` 而不是“普通”`enum`](#renum-class)
* [Enum.4: 针对安全和简单的用法来为枚举定义操作](#renum-oper)
* [Enum.5: 请勿为枚举符采用 `ALL_CAPS` 命名方式](#renum-caps)
* [Enum.6: 避免使用无名枚举](#renum-unnamed)
* [Enum.7: 仅在必要时才为枚举指定其底层类型](#renum-underlying)
* [Enum.8: 仅在必要时才指定枚举符的值](#renum-value)

### <a id="renum-macro"></a>Enum.1: 优先采用 `enum` 而不是宏

##### 理由

宏不遵守作用域和类型规则。而且，宏的名字在预处理中就被移除，因而通常不会出现在如调试器这样的工具中。

##### 示例

首先是一些不好的老代码：

    // webcolors.h (第三方头文件)
    #define RED   0xFF0000
    #define GREEN 0x00FF00
    #define BLUE  0x0000FF

    // productinfo.h
    // 以下则基于颜色定义了产品的子类型
    #define RED    0
    #define PURPLE 1
    #define BLUE   2

    int webby = BLUE;   // webby == 2; 可能不是我们所想要的

代之以 `enum`：

    enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
    enum class Product_info { red = 0, purple = 1, blue = 2 };

    int webby = blue;   // 错误: 应当明确
    Web_color webby = Web_color::blue;

我们用 `enum class` 来避免名字冲突。

##### 注释

开可以考虑使用 `constexpr` 和 `const inline` 变量。

##### 强制实施

标记定义整数值的宏。


### <a id="renum-set"></a>Enum.2: 采用枚举来表示相关的具名常量的集合

##### 理由

枚举展示其枚举符之间是有关联的，且可以用作具名类型。



##### 示例

    enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };


##### 注解

对枚举的 `switch` 是很常见的，编译器可以对不平常的 `case` 标签进行警告。例如：

    enum class Product_info { red = 0, purple = 1, blue = 2 };

    void print(Product_info inf)
    {
        switch (inf) {
        case Product_info::red: cout << "red"; break;
        case Product_info::purple: cout << "purple"; break;
        }
    }

这种漏掉一个的 `switch` 语句通常是添加枚举符并缺少测试的结果。

##### 强制实施

* 当 `switch` 语句的 `case` 标签并未覆盖枚举的全部枚举符时，对其进行标记。
* 当 `switch` 语句的 `case` 覆盖了枚举的几个枚举符，但没有 `default` 时，对其进行标记。


### <a id="renum-class"></a>Enum.3: 优先采用 `class enum` 而不是“普通”`enum`

##### 理由

最小化意外情况：传统的 `enum` 太容易转换为 `int` 了。

##### 示例

    void Print_color(int color);

    enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
    enum Product_info { red = 0, purple = 1, blue = 2 };

    Web_color webby = Web_color::blue;

    // 显然至少有一个调用是有问题的。
    Print_color(webby);
    Print_color(Product_info::blue);

代之以 `enum class`：

    void Print_color(int color);

    enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
    enum class Product_info { red = 0, purple = 1, blue = 2 };

    Web_color webby = Web_color::blue;
    Print_color(webby);  // 错误: 无法转换 Web_color 为 int。
    Print_color(Product_info::red);  // 错误: 无法转换 Product_info 为 int。

##### 强制实施

【简单】 对所有非 `class enum` 定义进行警告。

### <a id="renum-oper"></a>Enum.4: 针对安全和简单的用法来为枚举定义操作

##### 理由

便于使用并避免犯错。

##### 示例

    enum Day { mon, tue, wed, thu, fri, sat, sun };

    Day& operator++(Day& d)
    {
        return d = (d == Day::sun) ? Day::mon : static_cast<Day>(static_cast<int>(d)+1);
    }

    Day today = Day::sat;
    Day tomorrow = ++today;

这里使用 `static_cast` 有点不好，但

    Day& operator++(Day& d)
    {
        return d = (d == Day::sun) ? Day::mon : Day(++d);    // 错误
    }

是无限递归，而且不用强制转换而使用一个针对所有情况的 `switch` 太冗长了。


##### 强制实施

对重复出现的强制转换回枚举的表达式进行标记。


### <a id="renum-caps"></a>Enum.5: 请勿为枚举符采用 `ALL_CAPS` 命名方式

##### 理由

避免和宏之间发生冲突

##### 示例，不好

     // webcolors.h （第三方头文件）
    #define RED   0xFF0000
    #define GREEN 0x00FF00
    #define BLUE  0x0000FF

    // productinfo.h
    // 以下则基于颜色定义了产品的子类型

    enum class Product_info { RED, PURPLE, BLUE };   // 语法错误

##### 强制实施

标记 ALL_CAPS 风格的枚举符。

### <a id="renum-unnamed"></a>Enum.6: 避免使用无名枚举

##### 理由

如果无法对枚举命名的话，它的值之间就是没有关联的。

##### 示例，不好

    enum { red = 0xFF0000, scale = 4, is_signed = 1 };

这种代码在出现指定整数常量的其他方便方式之前并不少见。

##### 替代方案

代之以使用 `constexpr` 值。例如：

    constexpr int red = 0xFF0000;
    constexpr short scale = 4;
    constexpr bool is_signed = true;

##### 强制实施

对无名枚举进行标记。


### <a id="renum-underlying"></a>Enum.7: 仅在必要时才为枚举指定其底层类型

##### 理由

缺省情况的读写都是最简单的。
`int` 是缺省的整数类型。
`int` 是和 C 的 `enum` 相兼容的。

##### 示例

    enum class Direction : char { n, s, e, w,
                                  ne, nw, se, sw };  // 底层类型可以节省空间

    enum class Web_color : int32_t { red   = 0xFF0000,
                                     green = 0x00FF00,
                                     blue  = 0x0000FF };  // 底层类型是多余的

##### 注解

对`enum`或`enum class`前向声明时有必要指定底层类型：

    enum Flags : char;

    void f(Flags);

    // ....

    enum Flags : char { /* ... */ };

或者用以确保该类型的值具有指定的位精度：

    enum Bitboard : uint64_t { /* ... */ };

##### 强制实施

????


### <a id="renum-value"></a>Enum.8: 仅在必要时才指定枚举符的值

##### 理由

这是最简单的。
避免了枚举符值发生重复。
缺省情况会提供一组连续的值，并有利于 `switch` 语句的实现。

##### 示例

    enum class Col1 { red, yellow, blue };
    enum class Col2 { red = 1, yellow = 2, blue = 2 }; // 打错字
    enum class Month { jan = 1, feb, mar, apr, may, jun,
                       jul, august, sep, oct, nov, dec }; // 传统是从 1 开始
    enum class Base_flag { dec = 1, oct = dec << 1, hex = dec << 2 }; // 位的集合

为了和传统的值相匹配（比如 `Month`），以及当连续的值不合要求
（比如像 `Base_flag` 一样分配不同的位），是需要指定值的。

##### 强制实施

* 标记重复的枚举值
* 对明确指定的全部连续的枚举符的值进行标记。




# <a id="s-resource"></a>R: 资源管理

本章节中包含于资源相关的各项规则。
资源，就是任何必须进行获取，并（显式或隐式）进行释放的东西，比如内存、文件句柄、Socket 和锁等等。
其必须进行释放的原因在于它们是短缺的，因而即便是采用延迟释放也许也是有害的。
基本的目标是要确保不会泄漏任何资源，而且不会持有不在需要的任何资源。
负责释放某个资源的实体被称作是其所有者。

少数情况下，发生泄漏是可接受的甚至是理想的：
如果所编写的程序只是基于输入来产生输出，而其所需的内存正比于输入的大小，那么最理想的（性能和开发便利性）策略有时候恰是不要删除任何东西。
如果有足够的内存来处理最大输入的话，让其泄漏即可，但如果并非如此，应当保证给出一条恰当的错误消息。
这里，我们将忽略这样的情况。

* 资源管理规则概览：

  * [R.1: 利用资源句柄和 RAII（资源获取即初始化）来自动管理资源](#rr-raii)
  * [R.2: 接口中的原生指针（仅）代表个体对象](#rr-use-ptr)
  * [R.3: 原生指针（`T*`）没有所有权](#rr-ptr)
  * [R.4: 原生引用（`T&`）没有所有权](#rr-ref)
  * [R.5: 优先采用有作用域的对象，避免不必要的堆分配](#rr-scoped)
  * [R.6: 避免非 `const` 的全局变量](#rr-global)

* 分配和回收规则概览：

  * [R.10: 避免 `malloc()` 和 `free()`](#rr-mallocfree)
  * [R.11: 避免显式调用 `new` 和 `delete`](#rr-newdelete)
  * [R.12: 显式资源分配的结果应当立即交给一个管理对象](#rr-immediate-alloc)
  * [R.13: 单个表达式语句中至多进行一次显式资源分配](#rr-single-alloc)
  * [R.14: 避免使用 `[]` 形参，优先使用 `span`](#rr-ap)
  * [R.15: 总是同时重载相匹配的分配、回收函数对](#rr-pair)

* <a id="rr-summary-smartptrs"></a>智能指针规则概览：

  * [R.20: 用 `unique_ptr` 或 `shared_ptr` 表示所有权](#rr-owner)
  * [R.21: 优先采用 `unique_ptr` 而不是 `shared_ptr`，除非需要共享所有权](#rr-unique)
  * [R.22: 使用 `make_shared()` 创建 `shared_ptr`](#rr-make_shared)
  * [R.23: 使用 `make_unique()` 创建 `unique_ptr`](#rr-make_unique)
  * [R.24: 使用 `std::weak_ptr` 来打断 `shared_ptr` 的循环引用](#rr-weak_ptr)
  * [R.30: 以智能指针为参数，仅用于明确表达生存期语义](#rr-smartptrparam)
  * [R.31: 非 `std` 的智能指针，应当遵循 `std` 的行为模式](#rr-smart)
  * [R.32: `unique_ptr<widget>` 参数用以表达函数假定获得 `widget` 的所有权](#rr-uniqueptrparam)
  * [R.33: `unique_ptr<widget>&` 参数用以表达函数对该 `widget` 重新置位](#rr-reseat)
  * [R.34: `shared_ptr<widget>` 参数用以表达函数是所有者的一份子](#rr-sharedptrparam-owner)
  * [R.35: `shared_ptr<widget>&` 参数用以表达函数可能会对共享的指针重新置位](#rr-sharedptrparam)
  * [R.36: `const shared_ptr<widget>&` 参数用以表达它可能将保留一个对对象的引用 ???](#rr-sharedptrparam-const)
  * [R.37: 不要把来自某个智能指针别名的指针或引用传递出去](#rr-smartptrget)

### <a id="rr-raii"></a>R.1: 利用资源句柄和 RAII（资源获取即初始化）来自动管理资源

##### 理由

避免资源泄漏和人工资源管理的复杂性。
C++ 语言确保的构造函数/析构函数对称性，反映了资源的获取/释放函数对（比如 `fopen`/`fclose`，`lock`/`unlock`，以及 `new`/`delete` 等）的对称性本质。
每当需要处理某个需要成对儿的获取/释放函数调用的资源时，应当将资源封装到保证这种配对调用的对象之中——在构造函数中获取资源，并在其析构函数中释放它。

##### 示例，不好

考虑：

    void send(X* x, string_view destination)
    {
        auto port = open_port(destination);
        my_mutex.lock();
        // ...
        send(port, x);
        // ...
        my_mutex.unlock();
        close_port(port);
        delete x;
    }

这段代码中，你必须记得在所有路径中调用 `unlock`、`close_port` 和 `delete`，并且每个都恰好调用一次。
而且，一旦上面标有 `...` 的任何代码抛出了异常，`x` 就会泄漏，而 `my_mutex` 则保持锁定。

##### 示例

考虑：

    void send(unique_ptr<X> x, string_view destination)  // x 拥有这个 X
    {
        Port port{destination};            // port 拥有这个 PortHandle
        lock_guard<mutex> guard{my_mutex}; // guard 拥有这个锁
        // ...
        send(port, x);
        // ...
    } // 自动解锁 my_mutex 并删除 x 中的指针

现在所有的资源清理都是自动进行的，不管是否发生了异常，所有路径中都会执行一次。额外的好处是，该函数现在明确声称它将接过指针的所有权。

`Port` 又是什么呢？是一个封装资源的便利句柄：

    class Port {
        PortHandle port;
    public:
        Port(string_view destination) : port{open_port(destination)} { }
        ~Port() { close_port(port); }
        operator PortHandle() { return port; }

        // port 句柄通常是不能克隆的，因此根据需要关闭了复制和赋值
        Port(const Port&) = delete;
        Port& operator=(const Port&) = delete;
    };

##### 注解

一旦发现一个“表现不良”的资源并未以带有析构函数的类来表示，就用一个类来包装它，或者使用 [`finally`](#re-finally)。

**参见**: [RAII](#re-raii)

### <a id="rr-use-ptr"></a>R.2: 接口中的原生指针（仅）代表个体对象

##### 理由

最好用某个容器类型（比如 `vector`，拥有数据），或者用 `span`（不拥有数据）来表示数组。
这些容器和视图都带有足够的信息来进行范围检查。

##### 示例，不好

    void f(int* p, int n)   // n 为 p[] 中的元素数量
    {
        // ...
        p[2] = 7;   // 不好: 对原生指针采用下标
        // ...
    }

编译期不会读注释，而如果不读其他代码的话你也无法指导 `p` 是否真的指向了 `n` 个元素。
应当代之以 `span`。

##### 示例

    void g(int* p, int fmt)   // 用格式 fmt 打印 *p
    {
        // ... 只使用 *p 和 p[0] ...
    }

##### 例外

C 风格的字符串是以单个指向以零结尾的字符序列的指针来传递的。
为了表明对这种约定的依赖，应当使用 `zstring` 而不是 `char*`。

##### 注解

当前许多的单元素指针的用法其实都应当用引用。
不过，如果 `nullptr` 是可能的值的话，也许引用就不是合理的替代方案了。

##### 强制实施

* 对并非来自容器、视图或迭代器的指针进行的指针算术（包括 `++`）进行标记。
  这条规则对比较老的代码库实施时，可能会产生巨量的误报。
* 对把数组名被传递为单纯的指针进行标记。

### <a id="rr-ptr"></a>R.3: 原生指针（`T*`）没有所有权

##### 理由

对此（C++ 标准中和大多数代码中都）没有异议，大多数原生指针都是无所有权的。
我们希望将有所有权的指针标示出来，以使得可以可靠和高效地删除由有所有权指针所指向的对象。

##### 示例

    void f()
    {
        int* p1 = new int{7};           // 不好: 原生指针拥有了所有权
        auto p2 = make_unique<int>(7);  // OK: int 被一个唯一指针所拥有
        // ...
    }

`unique_ptr` 保证对它的对象进行删除（即便是发生异常时也如此），以此保护不发生泄漏。而 `T*` 做不到这点。

##### 示例

    template<typename T>
    class X {
    public:
        T* p;   // 不好: 不清楚 p 是不是带有所有权
        T* q;   // 不好: 不清楚 q 是不是带有所有权
        // ...
    };

可以通过明确所有权来修正这个问题：

    template<typename T>
    class X2 {
    public:
        owner<T*> p;  // OK: p 具有所有权
        T* q;         // OK: q 没有所有权
        // ...
    };

##### 例外

最主要的例外就是遗留代码，尤其是那些必须维持可以用 C 编译或者通过 ABI 来建立 C 和 C 风格的 C++ 之间的接口的代码。
亿万行的代码都违反本条规则而让 `T*` 具有所有权的现实是无法被忽略的。
我们由衷希望看到程序变换工具把这些 20 岁以上的“遗留”代码转换成光鲜的现代代码，
我们鼓励这种工具的开发、部署和使用，
我们希望这里的各项指导方针能够有助于这种工具的开发，
而且我们也在这一领域的研发工作中持续作出贡献。
但是，这是需要时间的：“遗留代码”的产生比我们能翻新的老代码还要快，因此这将会花费许多年的时间。

这些代码是无法被全部重写的（即便假定有良好的代码转换软件），尤其不会很快发生。
这个问题是不能简单通过把所有有所有权的指针都转换成 `unique_ptr` 和 `shared_ptr` 来（大规模）解决的，
这部分是因为我们确实需要在基础的资源句柄的实现中一起使用有所有权的“原生指针”和简单的指针。
例如，常见的 `vector` 实现中都有一个有所有权的指针和两个没有所有权的指针。
许多 ABI（以及基本上全部的面向 C 的接口代码）都使用 `T*`，其中不少都是有所有权的。
一些接口是无法简单地用 `owner` 来标记的，因为它们需要维持可以作为 C 来编译，
（这可能是少见的恰当的使用宏的场合，它仅在 C++ 模式中扩展为 `owner`）。

##### 注解

`owner<T*>` 并没有超出 `T*` 的默认语义。使用它可以不改动任何使用方代码，也不会影响 ABI。
它只不过是一项针对程序员和分析工具的提示。
比如说，当 `owner<T*>` 是某个类的成员时，这个类最好提供一个析构函数来 `delete` 它。

##### 示例，不好

返回（原生）指针的做法向调用方暴露了在生存期管理上的不确定性；就是说，谁应该删除其所指向的对象呢？

    Gadget* make_gadget(int n)
    {
        auto p = new Gadget{n};
        // ...
        return p;
    }

    void caller(int n)
    {
        auto p = make_gadget(n);   // 要记得 delete p
        // ...
        delete p;
    }

除了遭受[资源泄漏](#???)的问题外，这也带来了一组假性的分配和回收操作，而这其实是不必要的。如果 Gadget 可以廉价地从函数转移出来（就是说，它很小，或者具有高效的移动操作）的话，直接“按值”返回即可（参见[输出返回值](#rf-out)）：

    Gadget make_gadget(int n)
    {
        Gadget g{n};
        // ...
        return g;
    }

##### 注解

这条规则适用于工厂函数。

##### 注解

如果指针语义是必须的（比如说，因为返回类型需要指代类层次中的基类（或接口）），则可以返回“智能指针”。

##### 强制实施

* 【简单】 对在并非 `owner<T>` 的原生指针上进行的 `delete` 给出警告。
* 【中等】 对一个 `owner<T>` 指针，当并非每个代码路径中都要么进行 `reset` 要么明确 `delete`，则给出警告。
* 【简单】 当 `new` 的返回值被赋值给原生指针时，给出警告。
* 【简单】 当函数所返回的对象是在函数中所分配的，并且它具有移动构造函数时，给出警告。
  建议代之以按值返回。

### <a id="rr-ref"></a>R.4: 原生引用（`T&`）没有所有权

##### 理由

对此（C++ 标准中和大多数代码中都）没有异议，大多数原生引用都是无所有权的。
我们希望将所有者都标示出来，以使得可以可靠和高效地删除由有所有权指针所指向的对象。

##### 示例

    void f()
    {
        int& r = *new int{7};  // 不好: 原生的具有所有权的引用
        // ...
        delete &r;             // 不好: 违反了有关删除原生指针的规则
    }

**参见**: [原生指针的规则](#rr-ptr)

##### 强制实施

参见[原生指针的规则](#rr-ptr)

### <a id="rr-scoped"></a>R.5: 优先采用有作用域的对象，避免不必要的堆分配

##### 理由

有作用域的对象是局部对象、全局对象，或者成员。
它们也意味着在其所在作用域或者所在对象之外无须花费单独的分配和回收成本。
有作用域对象的成员自身也是有作用域的，有作用域对象的构造函数和析构函数负责管理其成员的生存期。

##### 示例

下面的例子效率不佳（因为无必要的分配和回收），在 `...` 中抛出异常和返回也是脆弱的（导致发生泄漏），而且也比较啰嗦：

    void f(int n)
    {
        auto p = new Gadget{n};
        // ...
        delete p;
    }

可以用局部变量来代替它：

    void f(int n)
    {
        Gadget g{n};
        // ...
    }

##### 强制实施

* 【中级】 如果分配了某个对象，又在函数内的所有路径中都进行了回收，则给出警告。建议它应当被代之以一个局部的栈对象。
* 【简单】 当局部的 `Unique_pointer` 或 `Shared_pointer` 在其生存期结束前未被移动、复制、赋值或 `reset`，则给出警告。
例外：不对指向无界数组的局部 `Unique_pointer` 产生这种警告。（见下文）

##### 例外

创建指向堆分配缓冲区的局部 `const unique_ptr<T[]>` 是没问题的，这是一种有效的表现有作用域的动态数组的方法。

##### 示例

一个局部 `const unique_ptr<T[]>` 变量的有效用例：

    int get_median_value(const std::list<int>& integers)
    {
      const auto size = integers.size();

      // OK: declaring a local unique_ptr<T[]>.
      const auto local_buffer = std::make_unique_for_overwrite<int[]>(size);

      std::copy_n(begin(integers), size, local_buffer.get());
      std::nth_element(local_buffer.get(), local_buffer.get() + size/2, local_buffer.get() + size);

      return local_buffer[size/2];
    }

### <a id="rr-global"></a>R.6: 避免非 `const` 的全局变量

参见 [I.2](#ri-global)

## <a id="ss-alloc"></a>R.alloc: 分配与回收

### <a id="rr-mallocfree"></a>R.10: 避免 `malloc()` 和 `free()`

##### 理由

`malloc()` 和 `free()` 并不支持构造和销毁，而且无法同 `new` 和 `delete` 之间进行混用。

##### 示例

    class Record {
        int id;
        string name;
        // ...
    };

    void use()
    {
        // p1 可能是 nullptr
        // *p1 并未初始化；尤其是，
        // 其中的 string 也还不是一个 string，而是一片和 string 大小相同的字节而已
        Record* p1 = static_cast<Record*>(malloc(sizeof(Record)));

        auto p2 = new Record;

        // 如果没有抛出异常的话，*p2 就经过了默认初始化
        auto p3 = new(nothrow) Record;
        // p3 可能为 nullptr；否则 *p3 就经过了默认初始化

        // ...

        delete p1;    // 错误: 不能 delete 由 malloc() 分配的对象
        free(p2);    // 错误: 不能 free() 由 new 分配的对象
    }

在某些实现中，`delete` 和 `free()` 可能可以工作，或者也可能引发运行时的错误。

##### 例外

有些应用程序或者代码段是不能接受异常的。
它们的最佳例子就是那些性命攸关的硬实时代码。
但要注意的是，许多对异常的禁止其实是基于某种（不良的）迷信，
或者来源于对没有进行系统性的资源管理的老式代码库的关注（很不幸，但这经常是必须的）。
在这些情况下，应当考虑使用 `nothrow` 版本的 `new`。

##### 强制实施

对 `malloc` 和 `free` 的使用进行标记。

### <a id="rr-newdelete"></a>R.11: 避免显式调用 `new` 和 `delete`

##### 理由

由 `new` 所返回的指针应当属于一个资源句柄（它将调用 `delete`）。
若由 `new` 所返回的指针被赋值给普通的裸指针，那么这个对象就可能会泄漏。

##### 注解

大型程序中，裸露的 `delete`（即出现于应用程序代码中，而不是专门进行资源管理的代码中）
很可能是一个 BUG：如果已经有了 N 个 `delete` 的话，怎么确定我们需要的不是 N+1 或者 N-1 个呢？
这种 BUG 可能会潜伏起来：它也许只会在维护过程中才暴露出来。
如果出现了裸露的 `new`，那就可能在别的什么地方需要一个裸露的 `delete`，因而可能也是一个 BUG。

##### 强制实施

【简单】 对任何 `new` 和 `delete` 的显式使用都给出警告。建议代之以 `make_unique`。

### <a id="rr-immediate-alloc"></a>R.12: 显式资源分配的结果应当立即交给一个管理对象

##### 理由

如果不这样做的话，当发生异常或者返回时就可能造成泄露。

##### 示例，不好

    void func(const string& name)
    {
        FILE* f = fopen(name, "r");            // 打开文件
        vector<char> buf(1024);
        auto _ = finally([f] { fclose(f); });  // 记得要关闭文件
        // ...
    }

`buf` 的分配可能会失败，并导致文件句柄的泄漏。

##### 示例

    void func(const string& name)
    {
        ifstream f{name};   // 打开文件
        vector<char> buf(1024);
        // ...
    }

对文件句柄（在 `ifstream` 中）的使用是简单、高效而且安全的。

##### 强制实施

* 将用于初始化指针的显式分配标记出来。（问题：我们能识别出多少直接资源分配呢？）

### <a id="rr-single-alloc"></a>R.13: 单个表达式语句中至多进行一次显式资源分配

##### 理由

如果在一条语句中进行两次显式资源分配的话就可能发生资源泄漏，这是因为许多的子表达式（包括函数参数）的求值顺序都是未指明的。

##### 示例

    void fun(shared_ptr<Widget> sp1, shared_ptr<Widget> sp2);

可以这样调用 `fun`：

    // 不好：可能会泄漏
    fun(shared_ptr<Widget>(new Widget(a, b)), shared_ptr<Widget>(new Widget(c, d)));

这是异常不安全的，因为编译器可能会把两个用以创建函数的两个参数的表达式重新排序。
特别是，编译器是可以交错执行这两个表达式的：
它可能会首先为两个对象都（通过调用 `operator new`）进行内存分配，然后再试图调用二者的 `Widget` 构造函数。
一旦其中一个构造函数调用抛出了异常，那么另一个对象的内存可能永远不会被释放了！

这个微妙的问题其实有一种简单的解决方案：永远不要在一条表达式语句中进行多于一次的显式资源分配。
例如：

    shared_ptr<Widget> sp1(new Widget(a, b)); // 好多了，但不太干净
    fun(sp1, new Widget(c, d));

最佳的方案是使用返回所有者对象的工厂函数，而完全避免显式的分配：

    fun(make_shared<Widget>(a, b), make_shared<Widget>(c, d)); // 最佳

如果还没有，请自己编写一个工厂包装。

##### 强制实施

* 将包含多次显式资源分配的表达式标记出来。（问题：我们能识别出多少直接资源分配呢？）

### <a id="rr-ap"></a>R.14: 避免使用 `[]` 形参，优先使用 `span`

##### 理由

数组会退化为指针，因而丢失其大小信息，并留下了发生范围错误的机会。
使用 `span` 来保留大小信息。

##### 示例

    void f(int[]);          // 不建议的做法

    void f(int*);           // 对多个对象不建议的做法
                            // （指针应当指向单个对象，不要进行下标运算）

    void f(gsl::span<int>); // 好，建议的做法

##### 强制实施

标记出 `[]` 参数。代之以使用 `span`。

### <a id="rr-pair"></a>R.15: 总是同时重载相匹配的分配、回收函数对

##### 理由

不然的话就出现不匹配的操作，并导致混乱。

##### 示例

    class X {
        // ...
        void* operator new(size_t s);
        void operator delete(void*);
        // ...
    };

##### 注解

如果想要无法进行回收的内存的话，可以将回收操作 `=delete`。
请勿留下它而不进行声明。

##### 强制实施

标记出不完全的操作对。

## <a id="ss-smart"></a>R.smart: 智能指针

### <a id="rr-owner"></a>R.20: 用 `unique_ptr` 或 `shared_ptr` 表示所有权

##### 理由

它们可以避免资源泄漏。

##### 示例

考虑：

    void f()
    {
        X* p1 { new X };              // 不好，p1 会泄漏
        auto p4 = make_unique<X>();   // 好，唯一所有权
        auto p5 = make_shared<X>();   // 好，共享所有权
    }

这里（只有）初始化 `p1` 的对象将会泄漏。

##### 强制实施

【简单】 如果 `new` 的返回值被赋值给了原生指针，就给出警告。
【简单】 如果返回带所有权原始指针的函数的结果被赋值给了原生指针，就给出警告。

### <a id="rr-unique"></a>R.21: 优先采用 `unique_ptr` 而不是 `shared_ptr`，除非需要共享所有权

##### 理由

`unique_ptr` 概念上要更简单且更可预测（知道它何时会销毁），而且更快（不需要暗中维护引用计数）。

##### 示例，不好

这里并不需要维护一个引用计数。

    void f()
    {
        shared_ptr<Base> base = make_shared<Derived>();
        // 局部范围中使用 base，并未进行复制——引用计数不会超过 1
    } // 销毁 base

##### 示例

这样更加高效：

    void f()
    {
        unique_ptr<Base> base = make_unique<Derived>();
        // 局部范围中使用 base
    } // 销毁 base

##### 强制实施

【简单】 如果函数所使用的 `Shared_pointer` 的对象是函数之内所分配的，而且既不会将这个 `Shared_pointer` 返回，也不会将其传递给其他接受 `Shared_pointer&` 的函数的话，就给出警告。建议代之以 `unique_ptr`。

### <a id="rr-make_shared"></a>R.22: 使用 `make_shared()` 创建 `shared_ptr`

##### 理由

`make_shared` 为构造提供了更精炼的语句。
它也提供了一个机会，通过把 `shared_ptr` 的使用计数和对象相邻放置，来消除为引用计数进行独立的内存分配操作。

##### 示例

考虑：

    shared_ptr<X> p1 { new X{2} }; // 不好
    auto p = make_shared<X>(2);    // 好

`make_shared()` 版本仅提到一次 `X`，因而它通常比显式的 `new` 方式要更简短（而且更快）。

##### 强制实施

【简单】 如果 `shared_ptr` 从 `new` 的结果而不是 `make_shared` 进行构造，就给出警告。

### <a id="rr-make_unique"></a>R.23: 使用 `make_unique()` 创建 `unique_ptr`

##### 理由

`make_unique` 为构造提供了更精炼的语句。
它也保证了复杂表达式中的异常安全性。

##### 示例

    unique_ptr<Foo> p {new Foo{7}};    // OK: 不过有重复

    auto q = make_unique<Foo>(7);      // 有改善: 并未重复 Foo

##### 强制实施

【简单】 如果 `unique_ptr` 从 `new` 的结果而不是 `make_unique` 进行构造，就给出警告。

### <a id="rr-weak_ptr"></a>R.24: 使用 `std::weak_ptr` 来打断 `shared_ptr` 的循环引用

##### 理由

`shared_ptr` 是基于引用计数的，而带有循环的结构中的引用计数不可能变为零，因此我们需要一种机制
来打破带有循环的结构。

##### 示例

    #include <memory>

    class bar;

    class foo {
    public:
      explicit foo(const std::shared_ptr<bar>& forward_reference)
        : forward_reference_(forward_reference)
      { }
    private:
      std::shared_ptr<bar> forward_reference_;
    };

    class bar {
    public:
      explicit bar(const std::weak_ptr<foo>& back_reference)
        : back_reference_(back_reference)
      { }
      void do_something()
      {
        if (auto shared_back_reference = back_reference_.lock()) {
          // 使用 *shared_back_reference
        }
      }
    private:
      std::weak_ptr<foo> back_reference_;
    };

##### 注解

??? (HS: 许多人都说要“打破循环引用”，不过我觉得“临时性共享所有权”可能更关键。)
???(BS: 打破循环引用是必须达成的目标；临时性共享所有权则是达成的方式。
你也可以仅仅使用另一个 `shared_ptr` 来得到“临时性共享所有权”。)

##### 强制实施

??? 可能无法做到。如果能够静态地检测出循环引用的话，我们就不需要 `weak_ptr` 了。

### <a id="rr-smartptrparam"></a>R.30: 以智能指针为参数，仅用于明确表达生存期语义

参见 [F.7](#rf-smart)。

### <a id="rr-smart"></a>R.31: 非 `std` 的智能指针，应当遵循 `std` 的行为模式

##### 理由

下面段落中的规则同样适用于第三方和自定义的其他种类的智能指针，而且对于诊断引发导致了性能和正确性问题的一般性的智能指针错误来说也是非常有帮助的。
你将会期望你所使用的所有智能指针都遵循这些规则。

任何重载了一元 `*` 和 `->` 的类型（无论主模板还是特化）都被当成是智能指针：

* 如果它可以复制，则将其当做一种具有引用计数的 `Shared_ptr`。
* 如果它不能复制，则将其当做一种唯一的 `Unique_ptr`。

##### 示例，不好

    // 使用 Boost 的 intrusive_ptr
    #include <boost/intrusive_ptr.hpp>
    void f(boost::intrusive_ptr<widget> p)  // 根据 'sharedptrparam' 规则是错误的
    {
        p->foo();
    }

    // 使用 Microsoft 的 CComPtr
    #include <atlbase.h>
    void f(CComPtr<widget> p)               // 根据 'sharedptrparam' 规则是错误的
    {
        p->foo();
    }

上面两段根据 [`sharedptrparam` 指导方针](#rr-smartptrparam)来说都是错误的：
`p` 是一个 `Shared_pointer`，但其共享性质完全没有被用到，而对其进行按值传递则是一种暗含的劣化；
这两个函数应当仅当它们需要参与 `widget` 的生存期管理时才接受智能指针。否则当可以为 `nullptr` 时它们就应当接受 `widget*`，否则，理想情况下，函数应当接受 `widget&`。
这些智能指针都符合 `Shared_pointer` 的概念，因此这些强制实施指导方针的规则可以直接应用，并使得这种一般性的劣化情况暴露出来。

### <a id="rr-uniqueptrparam"></a>R.32: `unique_ptr<widget>` 参数用以表达函数假定获得 `widget` 的所有权

##### 理由

以这种方式使用 `unique_ptr` 同时说明并强制施加了函数调用时的所有权转移。

##### 示例

    void sink(unique_ptr<widget>); // 获得这个 widget 的所有权

    void uses(widget*);            // 仅仅使用了这个 widget

##### 示例，不好

    void thinko(const unique_ptr<widget>&); // 通常不是你想要的

##### 强制实施

* 【简单】 如果函数以左值引用接受 `Unique_pointer<T>` 参数，但并未在至少一个代码路径中向其赋值或者对其调用 `reset()`，则给出警告。建议代之以接受 `T*` 或 `T&`。
* 【简单】〔基础〕 如果函数以 `const` 引用接受 `Unique_pointer<T>` 参数，则给出警告。建议代之以接受 `const T*` 或 `const T&`。

### <a id="rr-reseat"></a>R.33: `unique_ptr<widget>&` 参数用以表达函数对该 `widget` 重新置位

##### 示例

以这种方式使用 `unique_ptr` 同时说明并强制施加了函数调用时的重新置位语义。

##### 注解

所谓“重新置位（Reseat）”的含义是“让指针或智能指针指代某个不同的对象”。

##### 示例

    void reseat(unique_ptr<widget>&); // “将要”或“可能”重新置位指针

##### 示例，不好

    void thinko(const unique_ptr<widget>&); // 通常不是你想要的

##### 强制实施

* 【简单】 如果函数以左值引用接受 `Unique_pointer<T>` 参数，但并未在至少一个代码路径中向其赋值或者对其调用 `reset()`，则给出警告。建议代之以接受 `T*` 或 `T&`。
* 【简单】〔基础〕 如果函数以 `const` 引用接受 `Unique_pointer<T>` 参数，则给出警告。建议代之以接受 `const T*` 或 `const T&`。

### <a id="rr-sharedptrparam-owner"></a>R.34: 用 `shared_ptr<widget>` 参数表达共享所有权

##### 理由

这样做明确了函数的所有权共享语义。

##### 示例，好

    class WidgetUser
    {
    public:
        // WidgetUser 将会共享这个 widget 的所有权
        explicit WidgetUser(std::shared_ptr<widget> w) noexcept:
            m_widget{std::move(w)} {}
        // ...
    private:
        std::shared_ptr<widget> m_widget;
    };

##### 强制实施

* 【简单】 如果函数以左值引用接受 `Shared_pointer<T>` 参数，但并未在至少一个代码路径中向其赋值或者对其调用 `reset()`，则给出警告。建议代之以接受 `T*` 或 `T&`。
* 【简单】〔基础〕 如果函数按值或者以 `const` 引用接受 `Shared_pointer<T>` 参数，但并未在至少一个代码路径中将其复制或移动给另一个 `Shared_pointer`，则给出警告。建议代之以接受 `T*` 或 `T&`。
* 【简单】〔基础〕 如果函数以右值引用接受 `Shared_pointer<T>` 参数，则给出警告。建议代之以按值传递。

### <a id="rr-sharedptrparam"></a>R.35: `shared_ptr<widget>&` 参数用以表达函数可能会对共享的指针重新置位

##### 理由

这样做明确了函数的重新置位语义。

##### 注解

所谓“重新置位（Reseat）”的含义是“让引用或智能指针指代某个不同的对象”。

##### 示例，好

    void ChangeWidget(std::shared_ptr<widget>& w)
    {
        // 这将会改变调用方的 widget
        w = std::make_shared<widget>(widget{});
    }

##### 强制实施

* 【简单】 如果函数以左值引用接受 `Shared_pointer<T>` 参数，但并未在至少一个代码路径中向其赋值或者对其调用 `reset()`，则给出警告。建议代之以接受 `T*` 或 `T&`。
* 【简单】〔基础〕 如果函数按值或者以 `const` 引用接受 `Shared_pointer<T>` 参数，但并未在至少一个代码路径中将其复制或移动给另一个 `Shared_pointer`，则给出警告。建议代之以接受 `T*` 或 `T&`。
* 【简单】〔基础〕 如果函数以右值引用接受 `Shared_pointer<T>` 参数，则给出警告。建议代之以按值传递。

### <a id="rr-sharedptrparam-const"></a>R.36: `const shared_ptr<widget>&` 参数用以表达它可能将保留一个对对象的引用 ???

##### 理由

这样做明确了函数的 ??? 语义。

##### 示例，好

    void share(shared_ptr<widget>);            // 共享——“将会”保持一个引用计数

    void reseat(shared_ptr<widget>&);          // “可能”重新置位指针

    void may_share(const shared_ptr<widget>&); // “可能”保持一个引用计数

##### 强制实施

* 【简单】 如果函数以左值引用接受 `Shared_pointer<T>` 参数，但并未在至少一个代码路径中向其赋值或者对其调用 `reset()`，则给出警告。建议代之以接受 `T*` 或 `T&`。
* 【简单】〔基础〕 如果函数按值或者以 `const` 引用接受 `Shared_pointer<T>` 参数，但并未在至少一个代码路径中将其复制或移动给另一个 `Shared_pointer`，则给出警告。建议代之以接受 `T*` 或 `T&`。
* 【简单】〔基础〕 如果函数以右值引用接受 `Shared_pointer<T>` 参数，则给出警告。建议代之以按值传递。

### <a id="rr-smartptrget"></a>R.37: 不要把来自某个智能指针别名的指针或引用传递出去

##### 理由

违反这条规则，是导致引用计数的丢失和出现悬挂指针的首要原因。
函数应当优先向其调用链中传递原生指针和引用。
在调用树的顶层，原生指针或引用是从用以保持对象存活的智能指针中获得的。
我们需要确保这个智能指针不会在调用树的下面被疏忽地进行重置或者重新赋值。

##### 注解

为了做到这点，有时候需要获得智能指针的一个局部副本，它可以确保在函数及其调用树的执行期间维持对象存活。

##### 示例

考虑下面的代码：

    // 全局（静态或堆）对象，或者有别名的局部对象 ...
    shared_ptr<widget> g_p = ...;

    void f(widget& w)
    {
        g();
        use(w);  // A
    }

    void g()
    {
        g_p = ...; // 噢，如果这就是这个 widget 的最后一个 shared_ptr 的话，这会销毁这个 widget
    }

下面的代码是不应该通过代码评审的：

    void my_code()
    {
        // 不好: 传递的是从非局部的智能指针中获得的指针或引用
        //       而这可能会在 f 或其调用的函数中的某处被不经意地重置掉
        f(*g_p);

        // 不好: 原因相同，只不过将其作为“this”指针传递
        g_p->func();
    }

修正很简单——获取该指针的一个局部副本，为调用树“保持一个引用计数”：

    void my_code()
    {
        // 很廉价: 一次增量就搞定了整个函数以及下面的所有调用树
        auto pin = g_p;

        // 好: 传递的是从局部的无别名智能指针中获得的指针或引用
        f(*pin);

        // 好: 原因相同
        pin->func();
    }

##### 强制实施

* 【简单】 如果从非局部或局部但潜在具有别名的智能指针变量（`Unique_pointer` 或 `Shared_pointer`）中所获取的指针或引用，被用于进行函数调用，则给出警告。如果智能指针是一个 `Shared_pointer`，则建议代之以获取该智能指针的一个局部副本并从中获取指针或引用。


# <a id="s-performance"></a>Per: 性能

??? 这一节应该放在主指南中吗 ???

本章节所包含的规则对于需要高性能和低延迟的人们很有价值。
就是说，这些规则是有关如何在可预测的短时段中尽可能使用更短时间和更少资源来完成任务的。
本章节中的规则要比（绝大）多数应用程序所需要的规则更多限制并更有侵入性。
请勿在一般的代码中盲目地尝试遵循这些规则：要达成低延迟的目标是需要进行一些额外工作的。

性能规则概览：

* [Per.1: 请勿进行无理由的优化](#rper-reason)
* [Per.2: 请勿进行不成熟的优化](#rper-knuth)
* [Per.3: 请勿对非性能关键的代码进行优化](#rper-critical)
* [Per.4: 不能假定复杂代码一定比简单代码更快](#rper-simple)
* [Per.5: 不能假定低级代码一定比高级代码更快](#rper-low)
* [Per.6: 请勿不进行测量就作出性能评断](#rper-measure)
* [Per.7: 设计应当允许优化](#rper-efficiency)
* [Per.10: 依赖静态类型系统](#rper-type)
* [Per.11: 把计算从运行时转移到编译期](#rper-comp)
* [Per.12: 消除多余的别名](#rper-alias)
* [Per.13: 消除多余的间接](#rper-indirect)
* [Per.14: 最小化分配和回收的次数](#rper-alloc)
* [Per.15: 请勿在关键逻辑分支中进行分配](#rper-alloc0)
* [Per.16: 使用紧凑的数据结构](#rper-compact)
* [Per.17: 在时间关键的结构中应当先声明最常用的成员](#rper-struct)
* [Per.18: 空间即时间](#rper-space)
* [Per.19: 进行可预测的内存访问](#rper-access)
* [Per.30: 避免在关键路径中进行上下文切换](#rper-context)

### <a id="rper-reason"></a>Per.1: 请勿进行无理由的优化

##### 理由

如果没有必要优化的话，这样做的结果就是更多的错误和更高的维护成本。

##### 注解

一些人作出优化只是出于习惯或者因为感觉这很有趣。

???

### <a id="rper-knuth"></a>Per.2: 请勿进行不成熟的优化

##### 理由

经过精心优化的代码通常比未优化的代码更大而且更难修改。

???

### <a id="rper-critical"></a>Per.3: 请勿对非性能关键的代码进行优化

##### 理由

对程序中并非性能关键的部分进行的优化，对于系统性能是没有效果的。

##### 注解

如果你的程序要耗费大量时间来等待 Web 或人的操作的话，对内存中的计算进行优化可能是没什么用处的。

换个角度来说：如果你的程序花费处理时间的 4% 来
计算 A 而花费 40% 的时间来计算 B，那对 A 的 50% 的改进
其影响只能和 B 的 5% 的改进相比。（如果你甚至不知道
A 或 B 到底花费了多少时间，参见 <a href="#Rper-reason">Per.1</a> 和 <a
href="#Rper-Knuth">Per.2</a>。）

### <a id="rper-simple"></a>Per.4: 不能假定复杂代码一定比简单代码更快

##### 理由

简单的代码可能会非常快。优化器在简单代码上有时候会发生奇迹。

##### 示例，好

    // 清晰表达意图，快速执行

    vector<uint8_t> v(100000);

    for (auto& c : v)
        c = ~c;

##### 示例，不好

    // 试图更快，但通常会更慢

    vector<uint8_t> v(100000);

    for (size_t i = 0; i < v.size(); i += sizeof(uint64_t)) {
        uint64_t& quad_word = *reinterpret_cast<uint64_t*>(&v[i]);
        quad_word = ~quad_word;
    }

##### 注解

???

???

### <a id="rper-low"></a>Per.5: 不能假定低级代码一定比高级代码更快

##### 理由

低级代码有时候会妨碍优化。优化器在高级代码上有时候会发生奇迹。

##### 注解

???

???

### <a id="rper-measure"></a>Per.6: 请勿不进行测量就作出性能评断

##### 理由

性能领域充斥各种错误认识和伪习俗。
现代的硬件和优化器并不遵循这些幼稚的假设；即便是专家也会经常感觉意外。

##### 注解

要进行高质量的性能测量是很难的，而且需要采用专门的工具。

##### 注解

有些使用了 Unix 的 `time` 或者标准库的 `<chrono>` 的简单的微基准测量，有助于打破大多数明显的错误认识。
如果确实无法精确地测量完整系统的话，至少也要尝试对一些关键操作和算法进行测量。
性能剖析可以帮你发现系统的哪些部分是性能关键的。
你很可能会感觉意外。

???

### <a id="rper-efficiency"></a>Per.7: 设计应当允许优化

##### 理由

因为我们经常需要对最初的设计进行优化。
因为忽略后续改进的可能性的设计是很难修改的。

##### 示例

来自 C（以及 C++）的标准：

    void qsort (void* base, size_t num, size_t size, int (*compar)(const void*, const void*));

什么情况会需要对内存进行排序呢？
时即上，我们需要对元素序列进行排序，通常它们存储于容器之中。
对 `qsort` 的调用抛弃了许多有用的信息（比如元素的类型），强制用户对其已知的信息
进行重复（比如元素的大小），并强制用户编写额外的代码（比如用于比较 `double` 的函数）。
这蕴含了程序员工作量的增加，易错，并剥夺了编译器为优化所需的信息。

    double data[100];
    // ... 填充 a ...

    // 对从地址 data 开始的 100 块 sizeof(double) 大小
    // 的内存，用由 compare_doubles 所定义的顺序进行排序
    qsort(data, 100, sizeof(double), compare_doubles);

从接口设计的观点来看，`qsort` 抛弃了有用的信息。

这样做可以更好（C++98）：

    template<typename Iter>
        void sort(Iter b, Iter e);  // sort [b:e)

    sort(data, data + 100);

这里，我们利用了编译器关于数组大小，元素类型，以及如何对 `double` 进行比较的知识。

而以 C++20 的话，我们还可以做得更好：

    // sortable 指定了 c 必须是一个
    // 可以用 < 进行比较的元素的随机访问序列
    void sort(sortable auto& c);

    sort(c);

其中的关键在于传递充分的信息以便能够选择一个好的实现。
这里给出的几个 `sort` 接口仍然有一个缺憾：
它们隐含地依赖于元素类型定义了小于（`<`）运算符。
为使接口完整，我们需要另一个接受比较准则的版本：

    // 用 r 比较 c 的元素
    template<random_access_range R, class C> requires sortable<R, C>
    void sort(R&& r, C c);

`sort` 的标准库规范提供了这两个版本和其他版本。

##### 注解

不成熟的优化被称为[一切罪恶之源](#rper-knuth)，但这并不是轻视性能的理由。
考虑如何使设计可以为改进而进行修正绝不是不成熟的，而性能改进则是一种常见的改进要求。
我们的目标是建立一组习惯，使缺省情况就能得到高效，可维护，且可优化的代码。
特别是，当你编写并非一次性实现细节的函数时，应当考虑

* 信息传递：
优先采用能够为后续的实现改进带来充分信息的简洁[接口](#s-interfaces)。
要注意信息会通过我们所提供的接口来流入和流出一个实现。
* 紧凑的数据：默认情况[使用紧凑的数据](#rper-compact)，比如 `std::vector`，并[系统化地进行访问](#rper-access)。
如果你觉得需要一种有链接的结构的话，应尝试构造接口使这个结构不会被用户所看到。
* 函数的参数传递和返回：
对可改变和不可变的数据加以区分。
不要把资源管理的负担强加给用户。
不要把假性的间接强加给用户。
对通过接口传递信息采用[符合惯例的方式](#rf-conventional)；
不合惯例的，以及“优化过的”数据传递方式可能会严重影响后续的重新实现。
* 抽象：
不要过度泛化；视图提供每一种可能用法（和误用），并把每个设计决策都（通过编译时或运行时间接）
推迟到后面处理的设计，通常是复杂的，膨胀的，难于理解的混乱体。
应当从具体的例子进行泛化，泛化时要保持性能。
不要仅仅基于关于未来需求的推测而进行泛化。
理想情况是零开销泛化。
* 程序库：
使用带有良好接口的程序库。
当没有可用的程序库时，就构建自己的，并模仿一个好程序库的接口风格。
[标准库](#sl-the-standard-library)是寻找模仿的一个好的第一来源。
* 隔离：
通过将你所选择的接口提供给你的代码来将其和杂乱和老旧风格的代码之间进行隔离。
这有时候称为为有用或必须但杂乱的代码“提供包装”。
不要让不良设计“渗入”你的代码中。

##### 示例

考虑：

    template<class ForwardIterator, class T>
    bool binary_search(ForwardIterator first, ForwardIterator last, const T& val);

`binary_search(begin(c), end(c), 7)` 能够得出 `7` 是否在 `c` 之中。
不过，它无法得出 `7` 在何处，或者是否有多于一个 `7`。

有时候仅把最小数量的信息传递回来（如这里的 `true` 或 `false`）是足够的，但一个好的接口会
向调用方传递其所需的信息。因此，标准库还提供了

    template<class ForwardIterator, class T>
    ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T& val);

`lower_bound` 返回第一个匹配元素（如果有）的迭代器，否则返回第一个大于 `val` 的元素的迭代器，找不到这样的元素时，返回 `last`。

不过 `lower_bound` 还是无法为所有用法返回足够的信息，因此标准库还提供了

    template<class ForwardIterator, class T>
    pair<ForwardIterator, ForwardIterator>
    equal_range(ForwardIterator first, ForwardIterator last, const T& val);

`equal_range` 返回迭代器的 `pair`，指定匹配的第一个和最后一个之后的元素。

    auto r = equal_range(begin(c), end(c), 7);
    for (auto p = r.first; p != r.second; ++p)
        cout << *p << '\n';

显然，这三个接口都是以相同的基本代码实现的。
它们不过是将基本的二叉搜索算法表现给用户的三种方式，
包含从最简单（“让简单的事情简单！”）
到返回完整但不总是必要的信息（“不要隐藏有用的信息”）。
自然，构造这样一组接口是需要经验和领域知识的。

##### 注解

接口的构建不要仅匹配你能想到的第一种实现和第一种用例。
一旦第一个初始实现完成后，应当进行复审；一旦它被部署出去，就很难对错误进行补救了。

##### 注解

对效率的需求并不意味着对[底层代码](#rper-low)的需求。
高层代码并不必然缓慢或膨胀。

##### 注解

事物都是有成本的。
不要对成本过于偏执（当代计算机真的非常快），
但需要对你所使用的东西的成本的数量级有大致的概念。
例如，应当对
一次内存访问，
一次函数调用，
一次字符串比较，
一次系统调用，
一次磁盘访问，
以及一个通过网络的消息的成本有大致的概念。

##### 注解

如果你只能想到一种实现的话，可能你并没有某种能够设计一个稳定接口的东西。
有可能它只不过是实现细节——不是每段代码都需要一个稳定接口——停下来想一想。
一个有用的问题是
“如果这个操作需要用多个线程实现的话，需要什么样的接口呢？向量化？”

##### 注解

这条规则并不抵触[不要进行不成熟的优化](#rper-knuth)规则。
它对其进行了补充，鼓励程序员在有必要的时候，使后续的——适当并且成熟的——优化能够进行。

##### 强制实施

很麻烦。
也许查找 `void*` 函数参数能够找到妨碍后续优化的接口的例子。

### <a id="rper-type"></a>Per.10: 依赖静态类型系统

##### 理由

类型违规，弱类型（比如 `void*`），以及低级代码（比如把序列当作独立字节进行操作）等会让优化器的工作变得困难很多。简单的代码通常比手工打造的复杂代码能够更好地优化。

???

### <a id="rper-comp"></a>Per.11: 把计算从运行时转移到编译期

##### 理由

减少代码大小和运行时间。
通过使用常量来避免数据竞争。
编译时捕获错误（并因而消除错误处理代码）。

##### 示例

    double square(double d) { return d*d; }
    static double s2 = square(2);    // 旧式代码：动态初始化

    constexpr double ntimes(double d, int n)   // 假定 0 <= n
    {
            double m = 1;
            while (n--) m *= d;
            return m;
    }
    constexpr double s3 {ntimes(2, 3)};  // 现代代码：编译期初始化

像 `s2` 的初始化这样的代码并不少见，尤其是比 `square()` 更复杂一些的初始化更是如此。
不过，与 `s3` 的初始化相比，它有两个问题：

* 我们得忍受运行时的一次函数调用的开销
* `s2` 在初始化开始前可能就被某个别的线程访问了。

注意：常量是不可能发生数据竞争的。

##### 示例

考虑一种流行的提供包装类的技术，在包装类自身之中存储小型对象，而把大型对象保存到堆上。

    constexpr int on_stack_max = 20;

    template<typename T>
    struct Scoped {     // 在 Scoped 中存储一个 T
            // ...
        T obj;
    };

    template<typename T>
    struct On_heap {    // 在自由存储中存储一个 T
            // ...
            T* objp;
    };

    template<typename T>
    using Handle = typename std::conditional<(sizeof(T) <= on_stack_max),
                        Scoped<T>,      // 第一种候选
                        On_heap<T>      // 第二种候选
                   >::type;

    void f()
    {
        Handle<double> v1;                   // double 在栈中
        Handle<std::array<double, 200>> v2;  // array 保存到自由存储里
        // ...
    }

假定 `Scoped` 和 `On_heap` 均提供了兼容的用户接口。
这里我们在编译时计算出了最优的类型。
对于选择所要调用的最优函数，也有类似的技术。

##### 注解

理想情况是，*不*试图在编译期执行所有的代码。
显然，大多数的运算都依赖于输入，因而它们没办法挪到编译期进行，
而除了这种逻辑限制外，实际情况是，复杂的编译期运算会严重增加编译时间，
并使调试变得复杂。
甚至编译期运算也可能使得代码变慢。
这种情况确实罕见，但当把一种通用运算分解为一组优化的子运算时，可能会导致指令高速缓存的效率变差。

##### 强制实施

* 找出可以（但尚不）是 constexpr 的简单函数。
* 找出调用时其全部实参均为常量表达式的函数。
* 找出可以为 constexpr 的宏。

### <a id="rper-alias"></a>Per.12: 消除多余的别名

???

### <a id="rper-indirect"></a>Per.13: 消除多余的间接

???

### <a id="rper-alloc"></a>Per.14: 最小化分配和回收的次数

???

### <a id="rper-alloc0"></a>Per.15: 请勿在关键逻辑分支中进行分配

???

### <a id="rper-compact"></a>Per.16: 使用紧凑的数据结构

##### 理由

性能通常都是由内存访问次数所决定的。

???

### <a id="rper-struct"></a>Per.17: 在时间关键的结构中应当先声明最常用的成员

???

### <a id="rper-space"></a>Per.18: 空间即时间

##### 理由

性能通常都是由内存访问次数所决定的。

???

### <a id="rper-access"></a>Per.19: 进行可预测的内存访问

##### 理由

性能对于 Cache 的性能非常敏感，而 Cache 算法则更喜欢对相邻数据进行的（通常是线性的）简单访问行为。

##### 示例

    int matrix[rows][cols];

    // 不好
    for (int c = 0; c < cols; ++c)
        for (int r = 0; r < rows; ++r)
            sum += matrix[r][c];

    // 好
    for (int r = 0; r < rows; ++r)
        for (int c = 0; c < cols; ++c)
            sum += matrix[r][c];

### <a id="rper-context"></a>Per.30: 避免在关键路径中进行上下文切换

???




# <a id="s-errors"></a>E: 错误处理

错误处理涉及：

* 检测某个错误
* 将有关错误的信息传递给某个处理代码
* 维持程序的某个有效状态
* 避免资源泄漏

不可能做到从所有的错误中恢复。如果从某个错误进行恢复是不可能的话，以明确定义的方式迅速“脱离”则是很重要的。错误处理的策略必须简单，否则就会成为更糟糕错误的来源。未经测试和很少被执行的错误处理代码自身也是许多 BUG 的来源。

以下规则是设计用以帮助避免几种错误的：

* 类型违规（比如对 `union` 和强制转换的误用）
* 资源泄漏（包括内存泄漏）
* 边界错误
* 生存期错误（比如在对象被 `delete` 后访问它）
* 复杂性错误（可能由于过于复杂的想法表达而导致的逻辑错误）
* 接口错误（比如通过接口传递了预期外的值）

错误处理规则概览：

* [E.1: 在设计中尽早开发错误处理策略](#re-design)
* [E.2: 通过抛出异常来明示函数无法完成其所赋予的任务](#re-throw)
* [E.3: 仅使用异常来进行错误处理](#re-errors)
* [E.4: 围绕不变式来设计错误处理策略](#re-design-invariants)
* [E.5: 让构造函数建立不变式，若其无法做到则抛出异常](#re-invariant)
* [E.6: 使用 RAII 来避免泄漏](#re-raii)
* [E.7: 明示前条件](#re-precondition)
* [E.8: 明示后条件](#re-postcondition)

* [E.12: 当函数不可能或不能接受以 `throw` 来退出时，使用 `noexcept`](#re-noexcept)
* [E.13: 不要在作为某个对象的直接所有者时抛出异常](#re-never-throw)
* [E.14: 应当使用为目的所设计的自定义类型（而不是内建类型）作为异常](#re-exception-types)
* [E.15: 按值抛出并按引用捕获类型层次中的异常](#re-exception-ref)
* [E.16: 析构函数，回收函数，`swap`，以及异常类型的复制/移动构造决不能失败](#re-never-fail)
* [E.17: 不要试图在每个函数中捕获每个异常](#re-not-always)
* [E.18: 最小化对 `try`/`catch` 的显式使用](#re-catch)
* [E.19: 当没有合适的资源包装时，使用 `final_action` 对象来表达清理动作](#re-finally)

* [E.25: 当不能抛出异常时，模拟 RAII 来进行资源管理](#re-no-throw-raii)
* [E.26: 当不能抛出异常时，考虑采取快速失败](#re-no-throw-crash)
* [E.27: 当不能抛出异常时，系统化地使用错误代码](#re-no-throw-codes)
* [E.28: 避免基于全局状态（比如 `errno`）的错误处理](#re-no-throw)

* [E.30: 请勿使用异常说明](#re-specifications)
* [E.31: 恰当地对 `catch` 子句排序](#re_catch)

### <a id="re-design"></a>E.1: 在设计中尽早开发错误处理策略

##### 理由

在一个系统中改造翻新一种一致且完整的处理错误和资源泄漏的策略是很难的。

### <a id="re-throw"></a>E.2: 通过抛出异常来明示函数无法完成其所赋予的任务

##### 理由

让错误处理有系统性，强健，而且避免重复。

##### 示例

    struct Foo {
        vector<Thing> v;
        File_handle f;
        string s;
    };

    void use()
    {
        Foo bar {{ "{{" }}Thing{1}, Thing{2}, Thing{monkey}}, {"my_file", "r"}, "Here we go!"};
        // ...
    }

这里，`vector` 和 `string` 的构造函数可能无法为其元素分配足够的内存，`vector` 的构造函数可能无法复制其初始化式列表中的 `Thing`，而 `File_handle` 可能无法打开所需的文件。
这些情况中，它们都会抛出异常来让 `use()` 的调用者来处理。
如果 `use()` 可以处理这种构造 `bar` 的故障的话，它可以用 `try`/`catch` 来控制。
这些情况下，`Foo` 的构造函数都会在把控制传递给试图创建 `Foo` 的任何代码之前恰当地销毁以及构造的内存。
注意它并不存在可以包含错误代码的返回值。

`File_handle` 的构造函数可以这样定义：

    File_handle::File_handle(const string& name, const string& mode)
        : f{fopen(name.c_str(), mode.c_str())}
    {
        if (!f)
            throw runtime_error{"File_handle: could not open " + name + " as " + mode"}
    }

##### 注解

人们通常说异常应当用于表明意外的事件和故障。
不过这里面存在一点循环，“什么是意外的？”
例如：

* 无法满足的前条件
* 无法构造对象的构造函数（无法建立类的[不变式](#rc-struct)）
* 越界错误（比如 `v[v.size()] = 7`）
* 无法获得资源（比如网络未连接）

相较而言，终止某个普通的循环则不是意外的。
除非这个循环本应当是无限循环，否则其终止就是正常且符合预期的。

##### 注解

不要用 `throw` 仅仅作为从函数中返回值的另一种方式。

##### 例外

某些系统，比如在执行开始之前就需要保证以（通常很短的）常量最大时间来执行动作的硬实时系统，这样的系统只有当存在工具可以支持精确地预测从一次 `throw` 中恢复的最大时间时才能使用异常。

**参见**: [RAII](#re-raii)

**参见**: [讨论](#sd-noexcept)

##### 注解

在你决定你无法负担或者不喜欢基于异常的错误处理之前，请看一看[替代方案](#re-no-throw-raii)；
它们各自都有自己的复杂性和问题。
同样地，只要可能的话，就应该进行测量之后再发表有关效率的言论。

### <a id="re-errors"></a>E.3: 仅使用异常来进行错误处理

##### 理由

以保持错误处理和“常规代码”互相分离。
C++ 实现都倾向于基于假定异常的稀有而进行优化。

##### 示例，请勿如此

    // 请勿如此: 异常并未用于错误处理
    int find_index(vector<string>& vec, const string& x)
    {
        try {
            for (gsl::index i = 0; i < vec.size(); ++i)
                if (vec[i] == x) throw i;  // 找到了 x
        }
        catch (int i) {
            return i;
        }
        return -1;   // 未找到
    }

这种代码要比显然的替代方式更加复杂，而且极可能运行慢得多。
在 `vector` 中寻找一个值是没什么意外情况的。

##### 强制实施

可能应该是启发式措施。
查找从 `catch` 子句“漏掉”的异常值。

### <a id="re-design-invariants"></a>E.4: 围绕不变式来设计错误处理策略

##### 理由

要使用一个对象，它必须处于某个（正式或非正式通过不变式所定义的）有效的状态，而要从错误中恢复，每个还未销毁的对象也必须处于有效的状态。

##### 注解

[不变式](#rc-struct)是对象的成员的逻辑条件，构造函数必须进行建立，且为公开的成员函数所假定。

##### 强制实施

???

### <a id="re-invariant"></a>E.5: 让构造函数建立不变式，若其无法做到则抛出异常

##### 理由

遗留仍未建立不变式的对象将会带来麻烦。
不是任何成员函数都可以对其进行调用。

##### 示例

    class Vector {  // 非常简单的 double 向量
        // 当 elem != nullptr 时 elem 指向 sz 个 double
    public:
        Vector() : elem{nullptr}, sz{0}{}
        Vector(int s) : elem{new double[s]}, sz{s} { /* 元素的初始化 */ }
        ~Vector() { delete [] elem; }
        double& operator[](int s) { return elem[s]; }
        // ...
    private:
        owner<double*> elem;
        int sz;
    };

类不变式——这里以代码注释说明——是由构造函数建立的。
当 `new` 无法分配所需的内存时将抛出异常。
各运算符，尤其是下标运算符，都是依赖于这个不变式的。

**参见**: [当构造函数无法构造有效对象时，应当抛出异常](#rc-throw)

##### 强制实施

对带有 `private` 状态但没有（公开，受保护或私有的）构造函数的类进行标记。

### <a id="re-raii"></a>E.6: 使用 RAII 来避免泄漏

##### 理由

资源泄漏通常是不可接受的。
手工的资源释放很易出错。
RAII（Resource Acquisition Is Initialization，资源获取即初始化）是最简单，最系统化的避免泄漏方案。

##### 示例

    void f1(int i)   // 不好: 可能会泄漏
    {
        int* p = new int[12];
        // ...
        if (i < 17) throw Bad{"in f()", i};
        // ...
    }

我们可以在抛出异常前小心地释放资源：

    void f2(int i)   // 笨拙且易错: 显式的释放
    {
        int* p = new int[12];
        // ...
        if (i < 17) {
            delete[] p;
            throw Bad{"in f()", i};
        }
        // ...
    }

这样很啰嗦。在更大型的可能带有多个 `throw` 的代码中，显式的释放将变得重复且易错。

    void f3(int i)   // OK: 通过资源包装来进行资源管理（请见下文）
    {
        auto p = make_unique<int[]>(12);
        // ...
        if (i < 17) throw Bad{"in f()", i};
        // ...
    }

注意即使 `throw` 是在所调用的函数中暗中发生，这也能正常工作：

    void f4(int i)   // OK: 通过资源包装来进行资源管理（请见下文）
    {
        auto p = make_unique<int[]>(12);
        // ...
        helper(i);   // 可能抛出异常
        // ...
    }

除非你确实需要指针语义，否则还是应当使用局部的资源对象：

    void f5(int i)   // OK: 通过局部对象来进行资源管理
    {
        vector<int> v(12);
        // ...
        helper(i);   // 可能抛出异常
        // ...
    }

这即简单又安全，而且通常更加高效。

##### 注解

当没有合适的资源包装，且定义一个适当的 RAII 对象/包装由于某种原因不可行时，
万不得已，可以使用 [`final_action` 对象](#re-finally)来表达清理动作。

##### 注解

但是当我们所编写的程序不能使用异常时应当怎么办呢？
首先应当质疑这项假设；到处都有许多反异常的错误认识。
据我们所知，只有少量正当理由：

* 我们所在的系统太小，支持异常将会吃掉我们的 2K 内存的大部分。
* 我们所在的是硬实时系统，而且我们没有工具能保证异常会在所需时间内处理掉。
* 我们所在的系统中有成吨的遗留代码以难于理解的方式大量地使用指针
  （尤其是没有可识别的所有权策略），因此异常可能会造成泄露。
* 我们的 C++ 异常机制的实现不合理地糟糕
  （很慢，很耗内存，对于动态链接库无法正确工作，等等）。
  请向你的实现的供应商提出意见；如果没有用户提出意见，就不会出现改进。
* 如果我们质疑经理的古老智慧的话会被炒鱿鱼。

以上原因中只有第一条才是基础问题，因此一旦可能的话，还是要用异常来实现 RAII，或者设计你的 RAII 对象永不失败。
当无法使用异常时，可以模拟 RAII。
就是说，系统化地在对象构造之后检查其有效性，并且仍然在析构函数中释放所有的资源。
一种策略是为每个资源包装添加一个 `valid()` 操作：

    void f()
    {
        vector<string> vs(100);   // 非 std::vector: 添加了 valid()
        if (!vs.valid()) {
            // 处理错误或退出
        }

        ifstream fs("foo");   // 非 std::ifstream: 添加了 valid()
        if (!fs.valid()) {
            // 处理错误或退出
        }

        // ...
    } // 析构函数如常进行清理

显然这样做增加了代码大小，不允许隐式的“异常”（`valid()` 检查）传播，而且 `valid()` 检查可能被忘掉。
优先采用异常。

**参见**: [`noexcept` 的用法](#re-noexcept)

##### 强制实施

???

### <a id="re-precondition"></a>E.7: 明示前条件

##### 理由

避免接口错误。

**参见**: [前条件规则](#ri-pre)

### <a id="re-postcondition"></a>E.8: 明示后条件

##### 理由

避免接口错误。

**参见**: [后条件规则](#ri-post)

### <a id="re-noexcept"></a>E.12: 当函数不可能或不能接受以 `throw` 来退出时，使用 `noexcept`

##### 理由

使错误处理系统化，强健，且高效。

##### 示例

    double compute(double d) noexcept
    {
        return log(sqrt(d <= 0 ? 1 : d));
    }

这里，我们已知 `compute` 不会抛出异常，因为它仅由不会抛出异常的操作所组成。
通过将 `compute` 声明为 `noexcept`，让编译器和人类阅读者获得信息，使其更容易理解和操作 `compute`。

##### 注解

许多标准库函数都是 `noexcept` 的，这包括所有从 C 标准库中“继承”来的标准库函数。

##### 示例

    vector<double> munge(const vector<double>& v) noexcept
    {
        vector<double> v2(v.size());
        // ... 做一些事 ...
    }

这里的 `noexcept` 表明我不希望或无法处理无法构造局部的 `vector` 对象的情形。
也就是说，我认为内存耗尽是一种严重的设计错误（类比于硬件故障），因此我希望当其发生时让程序崩溃。

##### 注解

请勿使用传统的[异常说明](#re-specifications)。

##### 参见

[讨论](#sd-noexcept)。

### <a id="re-never-throw"></a>E.13: 不要在作为某个对象的直接所有者时抛出异常

##### 理由

这可能导致一次泄漏。

##### 示例

    void leak(int x)   // 请勿如此: 可能泄漏
    {
        auto p = new int{7};
        if (x < 0) throw Get_me_out_of_here{};  // 可能泄漏 *p
        // ...
        delete p;   // 可能不会执行到这里
    }

避免这种问题的一种方法是坚持使用资源包装：

    void no_leak(int x)
    {
        auto p = make_unique<int>(7);
        if (x < 0) throw Get_me_out_of_here{};  // 将按需删除 *p
        // ...
        // 无须 delete p
    }

另一种（通常更好）的方案是使用一个局部变量来消除指针的显式使用：

    void no_leak_simplified(int x)
    {
        vector<int> v(7);
        // ...
    }

##### 注解

如果有需要清理的某个局部“东西”，但其并未表示为带有析构函数的对象，则这样的清理
也必须在 `throw` 之前完成。
有时候，[`finally()`](#re-finally) 可以把这种不系统的清理变得更加可管理一些。

### <a id="re-exception-types"></a>E.14: 应当使用为目的所设计的自定义类型（而不是内建类型）作为异常

##### 理由

自定义类型可以把有关某个错误的信息更好地传递给处理器。
这些信息可以编码到类型自身中，而类型则不大可能会和其他人的异常造成冲突。

##### 示例

    throw 7; // 不好

    throw "something bad";  // 不好

    throw std::exception(); // 不好 - 未提供信息

从 `std::exception` 派生，能够获得选择捕获特定异常或者通过 `std::exception` 进行通盘处理的灵活性：

    class MyException: public std::runtime_error
    {
    public:
        MyException(const string& msg) : std::runtime_error(msg) {}
        // ...
    };

    // ...

    throw MyException("something bad");  // 好

异常可以不必派生于 `std::exception`：

    class MyCustomError final {};  // 并未派生于 std::exception

    // ...

    throw MyCustomError{};  // 好 - 处理器必须捕获这个类型（或 ...）

当检测位置没有可以添加的有用信息时，可以使用派生于 `exception`
的库类型作为通用类型：

    throw std::runtime_error{"someting bad"}; // 好

    // ...

    throw std::invalid_argument("i is not even"); // 好

也可以使用 `enum` 类：

    enum class alert {RED, YELLOW, GREEN};

    throw alert::RED; // 好

##### 强制实施

识别针对内建类型和 `std::exception` 的 `throw`。

### <a id="re-exception-ref"></a>E.15: 按值抛出并按引用捕获类型层次中的异常

##### 理由

按值（而非指针）抛出并按引用捕获，能避免进行复制，尤其是基类子对象的切片。

##### 示例，不好

    void f()
    {
        try {
            // ...
            throw new widget{}; // 请勿如此：抛出值而不要抛出原始指针
            // ...
        }
        catch (base_class e) {  // 请勿如此: 可能造成切片
            // ...
        }
    }

可以代之以引用：

    catch (base_class& e) { /* ... */ }

或者（通常更好的）`const` 引用：

    catch (const base_class& e) { /* ... */ }

大多数处理器并不会改动异常，一般情况下我们都会[建议使用 `const`](#res-const)。

##### 注解

对于如一个 `enum` 值这样的小型值类型来说，按值捕获是合适的。

##### 注解

重新抛出已捕获的异常应当使用 `throw;` 而非 `throw e;`。使用 `throw e;` 将会抛出 `e` 的一个新副本（并于异常被 `catch (const std::exception& e)` 捕获时切片成静态类型 `std::exception`），而并非重新抛出原来的 `std::runtime_error` 类型的异常。（但请关注[请勿试图在每个函数中捕获所有的异常](#re-not-always)，以及[尽可能减少 `try`/`catch` 的显式使用](#re-catch)。)

##### 强制实施

* 对按值捕获具有虚函数的类型进行标记。
* 对抛出原始指针进行标记。

### <a id="re-never-fail"></a>E.16: 析构函数，回收函数，`swap`，以及异常类型的复制/移动构造决不能失败

##### 理由

如果析构函数，`swap`，内存回收，或者尝试复制/移动异常对象时会失败，就是说如果它会通过异常而退出，或者根本不会实施其所需的动作，我们就将不知道应当如何编写可靠的程序。

##### 示例，请勿如此

    class Connection {
        // ...
    public:
        ~Connection()   // 请勿如此: 非常糟糕的析构函数
        {
            if (cannot_disconnect()) throw I_give_up{information};
            // ...
        }
    };

##### 注解

许多人都曾试图编写违反这条规则的可靠代码，比如当网络连接“拒绝关闭”的情形。
尽我们所知，没人曾找到一个做到这点的通用方案。
虽然偶尔对于非常特殊的例子，你可以通过设置某个状态以便进行将来的清理的方式绕过它。
比如说，我们可能将一个不打算关闭的 socket 放入一个“故障 socket”列表之中，
让其被某个定期的系统状态清理所检查处理。
我们见过的每个这种例子都是易错的，专门的，而且通常有 BUG。

##### 注解

标准库假定析构函数，回收函数（比如 `operator delete`），和 `swap` 都不会抛出异常。当它们这样做时，基本的标准库不变式将会被打破。

##### 注解

* 回收函数，包括 `operator delete`，必须为 `noexcept`。
* `swap` 函数必须为 `noexcept`。
* 大多数的析构函数都是缺省隐含为 `noexcept` 的。
* 而且，[应该使移动操作为 `noexcept`](#rc-move-noexcept)。
* 当编写用作异常类型的类型时，确保其复制构造函数不为 `noexcept`。一般来说我们没法机制化地强制这一点，因为我们并不了解一个类型是否有意作为一种异常类型。
* 尝试避免抛出复制构造函数不为 `noexcept` 的类型。一般来说我们没法机制化地强制这一点，因为即便 `throw std::string(...)` 也可能抛异常，虽然实际上并不会。

##### 强制实施

* 识别会 `throw` 的析构函数，回收操作，和 `swap`。
* 识别不为 `noexcept` 的这类操作。

**参见**: [讨论](#sd-never-fail)

### <a id="re-not-always"></a>E.17: 不要试图在每个函数中捕获每个异常

##### 理由

如果函数无法对异常进行有意义的恢复动作，其捕获这个异常就导致复杂性和浪费。
要让异常传播直到遇到一个可以处理它的函数。
要用 [RAII](#re-raii) 来处理栈回溯路径上的清理操作。

##### 示例，请勿如此

    void f()   // 不好
    {
        try {
            // ...
        }
        catch (...) {
            // 不做任何事
            throw;   // 传播异常
        }
    }

##### 强制实施

* 标记嵌套的 `try` 块。
* 对带有过高的 `try` 块/函数比率的源代码文件进行标记。 (??? 问题：定义“过高”)

### <a id="re-catch"></a>E.18: 最小化对 `try`/`catch` 的显式使用

##### 理由

`try`/`catch` 很啰嗦，而且非平凡的使用是易错的。
`try`/`catch` 可以作为对非系统化和/或低级的资源管理或错误处理的一个信号。

##### 示例，不好

    void f(zstring s)
    {
        Gadget* p;
        try {
            p = new Gadget(s);
            // ...
            delete p;
        }
        catch (Gadget_construction_failure) {
            delete p;
            throw;
        }
    }

这段代码很混乱。
可能在 `try` 块中的裸指针上发生泄漏。
不是所有的异常都被处理了。
`delete` 一个构造失败的对象几乎肯定是一个错误。
更好的是：

    void f2(zstring s)
    {
        Gadget g {s};
    }

##### 替代方案

* 合适的资源包装以及 [RAII](#re-raii)
* [`finally`](#re-finally)

##### 强制实施

??? 很难，需要启发式方法

### <a id="re-finally"></a>E.19: 当没有合适的资源包装时，使用 `final_action` 对象来表达清理动作

##### 理由

[GSL](#gsl-guidelines-support-library) 提供的 `finally` 要比 `try`/`catch` 更不啰嗦且难于搞错。

##### 示例

    void f(int n)
    {
        void* p = malloc(n);
        auto _ = gsl::finally([p] { free(p); });
        // ...
    }

##### 注解

`finally` 没有 `try`/`catch` 那样混乱，但它仍然比较专门化。
优先采用[适当的资源管理对象](#re-raii)。
万不得已考虑使用 `finally`。

##### 注解

相对于老式的 [`goto exit;` 技巧](#re-no-throw-codes)来说，使用 `finally` 是处理并非系统化的资源管理中的清理工作的
更加系统化并且相当简洁的方案。

##### 强制实施

启发式措施：检测 `goto exit;`。

### <a id="re-no-throw-raii"></a>E.25: 当不能抛出异常时，模拟 RAII 来进行资源管理

##### 理由

即便没有异常，[RAII](#re-raii) 通常仍然是最佳且最系统化的处理资源的方式。

##### 注解

使用异常进行错误处理，是 C++ 中唯一完整且系统化的处理非局部错误的方式。
特别是，非侵入地对对象构造的失败进行报告需要使用异常。
以无法被忽略的方式报告错误需要使用异常。
如果无法使用异常，应当尽你所能模拟它们的使用。

大量对异常的惧怕是被误导的。
当用在并非充斥指针和复杂控制结构的代码中的违例情形时，
异常处理几乎总是（在时间和空间上）可以负担，且几乎总会导致更好的代码。
当然这假定存在一个优良的异常处理机制实现，而这并非在所有系统上都存在。
存在另一些情况并不适用于上述问题，但由于其他原因而无法使用异常。
一个例子是一些硬实时系统：必须在固定的时间之内完成操作并得到错误或正确的响应。
在没有适当的时间评估工具的条件下，很难对异常作出保证。
这样的系统（比如飞控系统）通常也会禁止使用动态（堆）内存。

因此，对于错误处理的主要指导方针还是“使用异常和 [RAII](#re-raii)。”
本节所处理的情况是，要么你没有高效的异常实现，
或者要面对大量的老式代码
（比如说，大量的指针，不明确定义的所有权，以及大量的不系统化的基于错误代码检查的错误处理）
而且向其引入简单且系统化的错误处理的做法不可行。

在宣称不能使用异常或者抱怨它们成本过高之前，应当考虑一下使用[错误代码](#re-no-throw-codes)的例子。
请考虑使用错误代码的成本和复杂性。
如果你担心性能的话，请进行测量。

##### 示例

假定你想要编写

    void func(zstring arg)
    {
        Gadget g {arg};
        // ...
    }

当这个 `g` 并未正确构造时，`func` 将以一个异常退出。
当无法抛出异常时，我们可以通过向 `Gadget` 添加 `valid()` 成员函数来模拟 RAII 风格的资源包装：

    error_indicator func(zstring arg)
    {
        Gadget g {arg};
        if (!g.valid()) return gadget_construction_error;
        // ...
        return 0;   // 零代表“正常”
    }

显然问题现在变成了调用者必须记得测试其返回值。考虑添加 `[[nodiscard]]` 以鼓励这样的做法。

**参见**: [讨论](#sd-???)

##### 强制实施

（仅）对于这种想法的特定版本是可能的：比如检查资源包装的构造后进行系统化的 `valid()` 测试。

### <a id="re-no-throw-crash"></a>E.26: 当不能抛出异常时，考虑采取快速失败

##### 理由

如果你无法做好错误恢复的话，至少你可以在发生更多后续的损害之前拜托出来。

**参见**：[模拟 RAII](#re-no-throw-raii)

##### 注解

当你无法系统化地进行错误处理时，考虑以“程序崩溃”作为对任何无法局部处理的错误的回应。
就是说，如果你无法在检测到错误的函数的上下文中处理它，则调用 `abort()`，`quick_exit()`，
或者相似的某个将触发某种系统重启的函数。

在具有大量进程和/或大量计算机的系统中，你总要预计到并处理这些关键程序崩溃，
比如说源于硬件故障而引发。
这种情况下，“程序崩溃”只不过把错误处理留给了系统的下一个层次。

##### 示例

    void f(int n)
    {
        // ...
        p = static_cast<X*>(malloc(n * sizeof(X)));
        if (!p) abort();     // 当内存耗尽时 abort
        // ...
    }

大多数程序都无法得体地处理内存耗尽。这大略上等价于

    void f(int n)
    {
        // ...
        p = new X[n];    // 当内存耗尽时抛出异常（默认情况会调用 terminate）
        // ...
    }

通常，在退出之前将“崩溃”的原因记录日志是个好主意。

##### 强制实施

很难对付

### <a id="re-no-throw-codes"></a>E.27: 当不能抛出异常时，系统化地使用错误代码

##### 理由

系统化地使用任何错误处理策略都能最小化忘记处理错误的机会。

**参见**：[模拟 RAII](#re-no-throw-raii)

##### 注解

需要处理几个问题：

* 如何从函数向外传递错误指示？
* 如何在错误退出函数之前释放所有资源？
* 使用什么来作为错误指示？

通常，返回错误指示意味着返回两个值：其结果以及一个错误指示。
错误指示可以是对象的一部分，例如对象可以带有 `valid()` 指示，
也可以返回一对值。

##### 示例

    Gadget make_gadget(int n)
    {
        // ...
    }

    void user()
    {
        Gadget g = make_gadget(17);
        if (!g.valid()) {
                // 错误处理
        }
        // ...
    }

这种方案符合[模拟 RAII 资源管理](#re-no-throw-raii)。
`valid()` 函数可以返回一个 `error_indicator`（比如说 `error_indicator` 枚举的某个成员）。

##### 示例

要是我们无法或者不想改动 `Gadget` 类型呢？
这种情况下，我们只能返回一对值。
例如：

    std::pair<Gadget, error_indicator> make_gadget(int n)
    {
        // ...
    }

    void user()
    {
        auto r = make_gadget(17);
        if (!r.second) {
                // 错误处理
        }
        Gadget& g = r.first;
        // ...
    }

可见，`std::pair` 是一种可能的返回类型。
某些人则更喜欢专门的类型。
例如：

    Gval make_gadget(int n)
    {
        // ...
    }

    void user()
    {
        auto r = make_gadget(17);
        if (!r.err) {
                // 错误处理
        }
        Gadget& g = r.val;
        // ...
    }

倾向于专门返回类型的一种原因是为其成员提供命名，而不是使用多少有些隐秘的 `first` 和 `second`,
而且可以避免与 `std::pair` 的其他使用相混淆。

##### 示例

通常，在错误退出之前必须进行清理。
这样做是很混乱的：

    std::pair<int, error_indicator> user()
    {
        Gadget g1 = make_gadget(17);
        if (!g1.valid()) {
            return {0, g1_error};
        }

        Gadget g2 = make_gadget(17);
        if (!g2.valid()) {
            cleanup(g1);
            return {0, g2_error};
        }

        // ...

        if (all_foobar(g1, g2)) {
            cleanup(g2);
            cleanup(g1);
            return {0, foobar_error};
        }

        // ...

        cleanup(g2);
        cleanup(g1);
        return {res, 0};
    }

模拟 RAII 可能不那么简单，尤其是在带有多个资源和多种可能错误的函数之中。
一种较为常见的技巧是把清理都集中到函数末尾以避免重复（注意这里本不必为 `g2` 增加一层作用域，但是编译 `goto` 版本却需要它）：

    std::pair<int, error_indicator> user()
    {
        error_indicator err = 0;
        int res = 0;

        Gadget g1 = make_gadget(17);
        if (!g1.valid()) {
            err = g1_error;
            goto g1_exit;
        }

        {
            Gadget g2 = make_gadget(31);
            if (!g2.valid()) {
                err = g2_error;
                goto g2_exit;
            }

            if (all_foobar(g1, g2)) {
                err = foobar_error;
                goto exit;
            }

            // ...

        g2_exit:
            if (g2.valid()) cleanup(g2);
        }

    g1_exit:
        if (g1.valid()) cleanup(g1);
        return {res,err};
    }

函数越大，这种技巧就越有吸引力。
`finally` 可以[略微缓解这个问题](#re-finally)。
而且，程序变得越大，系统化地采用一中基于错误指示的错误处理策略就越加困难。

我们[优先采用基于异常的错误处理](#re-throw)，并建议[保持函数短小](#rf-single)。

**参见**: [讨论](#sd-???)

**参见**: [返回多个值](#rf-out-multi)

##### 强制实施

很难对付。

### <a id="re-no-throw"></a>E.28: 避免基于全局状态（比如 `errno`）的错误处理

##### 理由

全局状态难于管理，且易于忘记检查。
你上次检查 `printf()` 的返回值是什么时候了？

**参见**：[模拟 RAII](#re-no-throw-raii)

##### 示例，不好

    int last_err;

    void f(int n)
    {
        // ...
        p = static_cast<X*>(malloc(n * sizeof(X)));
        if (!p) last_err = -1;     // 当内存耗尽时发生的错误
        // ...
    }

##### 注解

C 风格的错误处理就是基于全局变量 `errno` 的，因此基本上不可能完全避免这种风格。

##### 强制实施

很难对付。


### <a id="re-specifications"></a>E.30: 请勿使用异常说明

##### 理由

异常说明使得错误处理变得脆弱，隐含一些运行时开销，并且已经从 C++ 标准中被删除了。

##### 示例

    int use(int arg)
        throw(X, Y)
    {
        // ...
        auto x = f(arg);
        // ...
    }

当 `f()` 抛出了不同于 `X` 和 `Y` 的异常时将会执行未预期异常处理器，其默认将终止程序。
这没什么问题，但假定我们检查过着并不会发生而 `f` 则被改写为抛出某个新异常 `Z`，
这样将导致程序崩溃，除非我们改写 `use()`（并重新测试所有东西）。
障碍在于 `f()` 可能在某个我们无法控制的程序库中，而对于新的异常 `use()`
没办法对其做任何事，或者对其完全不感兴趣。
我们可以改写 `use()` 使其传递 `Z` 出去，但这样的话 `use()` 的调用方可能也需要被改写。
如此事态将很快变得无法掌控。
或者，我们可以在 `use()` 中添加一个 `try`-`catch` 以将 `Z` 映射为某种可以接受的异常。
这种方法也会很快变得无法掌控。
注意，对异常集合的改动通常都发生在系统的最底层
（比如说，当改换了网络库或者某种中间件时），因此改变将沿着冗长的调用链“冒泡上浮”。
在大型代码库中，这将意味着直到最后一个使用方也被改写之前，没人可以更新某个库到新版本。
如果 `use()` 是某个库的一部分，则也许不可能对其进行更新，因为其改动可能影响到未知的客户代码。

而让异常继续传递直到其到达某个潜在可以处理它的函数的策略，已经在多年的实践中得到了证明。

##### 注解

静态强制检查异常说明并不会带来任何好处。
相关例子请参见 [Stroustrup94](#stroustrup94)。

##### 注解

当不会抛出异常时，请使用 [`noexcept`](#re-noexcept)。

##### 强制实施

标记每个异常说明。

### <a id="re_catch"></a>E.31: 恰当地对 `catch` 子句排序

##### 理由

`catch` 子句是以其出现顺序依次求值的，而其中一个可能会隐藏掉另一个。

##### 示例，不好

    void f()
    {
        // ...
        try {
                // ...
        }
        catch (Base& b) { /* ... */ }
        catch (Derived& d) { /* ... */ }
        catch (...) { /* ... */ }
        catch (std::exception& e) { /* ... */ }
    }

若 `Derived` 派生自 `Base` 则 `Derived` 的处理器永远不会被执行。
“捕获任何东西”的处理器保证 `std::exception` 的处理器永远不会被执行。

##### 强制实施

标记出所有的“隐藏处理器”。




# <a id="s-const"></a>Con: 常量与不可变性

常量是不会出现竞争条件的。
当大量的对象不会改变它们的值时，对程序进行推理将变得更容易。
承诺“不改动”作为参数所传递对象的接口，极大地提升了可读性。

常量规则概览：

* [Con.1: 缺省情况下，对象应当是不可变的](#rconst-immutable)
* [Con.2: 缺省情况下，成员函数应当为 `const`](#rconst-fct)
* [Con.3: 缺省情况下，应当传递指向 `const` 对象的指针或引用](#rconst-ref)
* [Con.4: 构造之后不再改变其值的对象应当以 `const` 来定义](#rconst-const)
* [Con.5: 以 `constexpr` 来定义可以在编译期计算的值](#rconst-constexpr)

### <a id="rconst-immutable"></a>Con.1: 缺省情况下，对象应当是不可变的

##### 理由

不可变对象更易于进行推理，应仅当需要改动对象的值时，才使之为非 `const` 对象。
避免出现意外造成的或者很难发觉的值的改变。

##### 示例

    for (const int i : c) cout << i << '\n';    // 仅进行读取: const

    for (int i : c) cout << i << '\n';          // 不好: 仅进行读取

##### 例外

按值传递的函数参数很少被改动，但也很少被声明为 `const`。
为了避免造成混淆和大量的误报，不要对函数参数实施这条规则。。

    void f(const char* const p); // 迂腐
    void g(const int i) { ... }  // 迂腐

注意，函数参数是局部变量，其改动也是局部的。

##### 强制实施

* 标记未发生改动的非 `const` 变量（排除参数以避免误报）

### <a id="rconst-fct"></a>Con.2: 缺省情况下，成员函数应当为 `const`

##### 理由

除非成员函数会改变对象的可观察状态，否则它应当标记为 `const`。
这样做更精确地描述了设计意图，具有更佳的可读性，编译器可以识别更多的错误，而且有时能够带来更多的优化机会。

##### 示例，不好

    class Point {
        int x, y;
    public:
        int getx() { return x; }    // 不好，应当为 const，它并不改变对象的状态
        // ...
    };

    void f(const Point& pt)
    {
        int x = pt.getx();          // 错误，无法通过编译，因为 getx 并未标记为 const
    }

##### 注解

传递非 `const` 的指针或引用并非天生就是不好的，
但应当只有在所调用的函数预计会修改这个对象时才这样做。
代码的读者必须假定接受“普通的” `T*` 或 `T&` 的函数都将会修改其所指代的对象。
如果它现在不会，那它可能以后会，且无需强制要求重新编译。

##### 注解

有些代码和程序库提供的函数是声明为 `T*`，
但这些函数并不会修改这个 `T`。
这对于进行代码现代化转换的人们来说是个问题。
你可以：

* 如果倾向于长期解决方案的话，将程序库更新为 `const` 正确的；
* “强制掉 `const`”（[最好避免这样做](#res-casts-const)）；
* 提供包装函数。

例如：

    void f(int* p);   // 老代码：f() 并不会修改 `*p`
    void f(const int* p) { f(const_cast<int*>(p)); } // 包装函数

注意，这种包装函数的方案是一种补丁，只能在无法修改 `f()` 的声明时才使用它，
比如当它属于某个你无法修改的程序库时。

##### 注解

`const` 成员函数可以改动 `mutable` 对象的值，或者通过某个指针成员改动对象的值。
一种常见用法是来维护一个缓存以避免重复进行复杂的运算。
例如，这里的 `Date` 缓存（记住）了其字符串表示，以简化其重复使用：

    class Date {
    public:
        // ...
        const string& string_ref() const
        {
            if (string_val == "") compute_string_rep();
            return string_val;
        }
        // ...
    private:
        void compute_string_rep() const;    // 计算字符串表示并将其存入 string_val
        mutable string string_val;
        // ...
    };

另一种说法是 `const` 特性不会传递。
通过 `const` 成员函数改动 `mutable` 成员的值和通过非 `const` 指针来访问的对象的值
是有可能的。
由类负责确保这样的改动仅当根据其语义（不变式）对于其用户有意义时
才会发生。

**参见**：[PImpl](#ri-pimpl)

##### 强制实施

* 如果未标记为 `const` 的成员函数并未对任何成员变量实施非 `const` 操作的话，对其进行标记。

### <a id="rconst-ref"></a>Con.3: 缺省情况下，应当传递指向 `const` 对象的指针或引用

##### 理由

避免所调用的函数意外地改变了这个值。
如果被调用的函数不会改动状态的话，对程序的推理将变得容易得多。

##### 示例

    void f(char* p);        // f 会不会修改 *p?（假定它会修改）
    void g(const char* p);  // g 不会修改 *p

##### 注解

传递指向非 `const` 对象的指针或引用并不是天生就有问题的，
不过只有当所调用的函数本就有意改动对象时才能这样做。

##### 注解

[请勿强制掉 `const`](#res-casts-const)。

##### 强制实施

* 如果函数并未修改以指向非 `const` 的指针或引用传递的对象，则对其进行标记。
* 如果函数（利用强制转换）修改了以指向 `const` 的指针或引用传递的对象，则对其进行标记。

### <a id="rconst-const"></a>Con.4: 构造之后不再改变其值的对象应当以 `const` 来定义

##### 理由

避免意外地改变对象的值。

##### 示例

    void f()
    {
        int x = 7;
        const int y = 9;

        for (;;) {
            // ...
        }
        // ...
    }

既然 `x` 并非 `const`，我们就必须假定它可能在循环中的某处会被修改。

##### 强制实施

* 标记并未被修改的非 `const` 变量。

### <a id="rconst-constexpr"></a>Con.5: 以 `constexpr` 来定义可以在编译期计算的值

##### 理由

更好的性能，更好的编译期检查，受保证的编译期求值，竞争条件可能性为零。

##### 示例

    double x = f(2);            // 可能在运行时求值
    const double y = f(2);      // 可能在运行时求值
    constexpr double z = f(2);  // 除非 f(2) 可在编译期求值，否则会报错

##### 注解

参见 F.4。

##### 强制实施

* 对带有常量表达式初始化式的 `const` 定义进行标记。



# <a id="s-cpl"></a>CPL: C 风格的编程

C 和 C++ 是联系很紧密的两门语言。
它们都是源于 1978 年的“经典 C”语言的，且从此之后就在 ISO 标准委员会中进行演化。
为了让它们保持兼容，我们做过许多努力，但它们各自都并非是对方的子集。

C 规则概览：

* [CPL.1: 优先使用 C++ 而不是 C](#rcpl-c)
* [CPL.2: 当一定要用 C 时，应使用 C 和 C++ 的公共子集，并将 C 代码以 C++ 来编译](#rcpl-subset)
* [CPL.3: 当一定要用 C 来作为接口时，应在使用这些接口的调用方代码中使用 C++](#rcpl-interface)

### <a id="rcpl-c"></a>CPL.1: 优先使用 C++ 而不是 C

##### 理由

C++ 提供更好的类型检查和更多的语法支持。
它能为高层的编程提供更好的支持，而且通常会产生更快速的代码。

##### 示例

    char ch = 7;
    void* pv = &ch;
    int* pi = pv;   // 非 C++
    *pi = 999;      // 覆盖了 &ch 附近的 sizeof(int) 个字节

针对在 C 中从 `void*` 或向它进行的隐式强制转换的相关规则比较麻烦而且并未强制实施。
特别是，这个例子违反了禁止把类型转换为具有更严格对齐的类型的规则。

##### 强制实施

使用 C++ 编译器。

### <a id="rcpl-subset"></a>CPL.2: 当一定要用 C 时，应使用 C 和 C++ 的公共子集，并将 C 代码以 C++ 来编译

##### 理由

它们的子集语言，C 和 C++ 编译器都可以编译，而当作为 C++ 编译时，比“纯 C” 进行更好的类型检查。

##### 示例

    int* p1 = malloc(10 * sizeof(int));                      // 非 C++
    int* p2 = static_cast<int*>(malloc(10 * sizeof(int)));   // 非 C, C 风格的 C++
    int* p3 = new int[10];                                   // 非 C
    int* p4 = (int*) malloc(10 * sizeof(int));               // C 和 C++ 均可

##### 强制实施

* 当使用某种将代码作为 C 来编译的构建模式时进行标记。

  * C++ 将会确保代码是合法的 C++ 代码，除非使用了 C 扩展的编译器选项。

### <a id="rcpl-interface"></a>CPL.3: 当一定要用 C 来作为接口时，应在使用这些接口的代码中使用 C++

##### 理由

C++ 比 C 的表达能力更强，而且为许多种类的编程都提供了更好的支持。

##### 示例

例如，为使用第三方 C 程序库或者 C 系统接口，可以使用 C 和 C++ 的公共子集来定义其底层接口，以获得更好的类型检查。
尽可能将底层接口封装到一个遵循了 C++ 指导方针的接口之中（以获得更好的抽象、内存安全性和资源安全性），并在 C++ 代码中使用这个 C++ 接口。

##### 示例

在 C++ 中可以调用 C：

    // C 中:
    double sqrt(double);

    // C++ 中:
    extern "C" double sqrt(double);

    sqrt(2);

##### 示例

在 C 中可以调用 C++：

    // C 中:
    X call_f(struct Y*, int);

    // C++ 中:
    extern "C" X call_f(Y* p, int i)
    {
        return p->f(i);   // 可能是虚函数调用
    }

##### 强制实施

不需要做什么。


# <a id="s-source"></a>SF: 源文件

区分声明（用作接口）和定义（用作实现）。
用头文件来表达接口并强调逻辑结构。

源文件规则概览：

* [SF.1: 如果你的项目还未采用别的约定的话，应当为代码文件使用后缀 `.cpp`，而对接口文件使用后缀 `.h`](#rs-file-suffix)
* [SF.2: 头文件不能含有对象定义或非内联的函数定义](#rs-inline)
* [SF.3: 对在多个源文件中使用的任何声明，都应使用头文件](#rs-declaration-header)
* [SF.4: 在文件中的其他所有声明之前包含头文件](#rs-include-order)
* [SF.5: `.cpp` 文件必须包含定义了它的接口的一个或多个头文件](#rs-consistency)
* [SF.6: `using namespace` 指令，（仅）可以为迁移而使用，可以为基础程序库使用（比如 `std`），或者在局部作用域中使用](#rs-using)
* [SF.7: 请勿在头文件中的全局作用域使用 `using namespace` 指令](#rs-using-directive)
* [SF.8: 为所有的头文件使用 `#include` 防卫宏](#rs-guards)
* [SF.9: 避免源文件的循环依赖](#rs-cycles)
* [SF.10: 避免依赖于隐含地 `#include` 进来的名字](#rs-implicit)
* [SF.11: 头文件应当是自包含的](#rs-contained)
* [SF.12: 对相对于包含文件的文件优先采用引号形式的 `#include`，其他情况下采用角括号形式](#rs-incform)

* [SF.20: 用 `namespace` 表示逻辑结构](#rs-namespace)
* [SF.21: 请勿在头文件中使用无名（匿名）命名空间](#rs-unnamed)
* [SF.22: 为所有的内部/不导出的实体使用无名（匿名）命名空间](#rs-unnamed2)

### <a id="rs-file-suffix"></a>SF.1: 如果你的项目还未采用别的约定的话，应当为代码文件使用后缀 `.cpp`，而对接口文件使用后缀 `.h`

参见 [NL.27](#rl-file-suffix)

### <a id="rs-inline"></a>SF.2: 头文件不能含有对象定义或非内联的函数定义

##### 理由

对受制于唯一定义规则的实体的包含将导致连接错误。

##### 示例

    // file.h:
    namespace Foo {
        int x = 7;
        int xx() { return x+x; }
    }

    // file1.cpp:
    #include <file.h>
    // ... 更多代码 ...

     // file2.cpp:
    #include <file.h>
    // ... 更多代码 ...

当连接 `file1.cpp` 和 `file2.cpp` 时将出现两个连接器错误。

**其他形式**: 头文件必须仅包含：

* `#include` 其他的头文件（可能包括包含防卫宏）
* 模板
* 类定义
* 函数声明
* `extern` 声明
* `inline` 函数定义
* `constexpr` 定义
* `const` 定义
* `using` 别名定义
* ???

##### 强制实施

根据以上白名单来检查。

### <a id="rs-declaration-header"></a>SF.3: 对在多个源文件中使用的任何声明，都应使用头文件

##### 理由

可维护性。可读性。

##### 示例，不好

    // bar.cpp:
    void bar() { cout << "bar\n"; }

    // foo.cpp:
    extern void bar();
    void foo() { bar(); }

`bar` 的维护者在需要改变 `bar` 的类型时，无法找到其全部声明。
`bar` 的使用者不知道他所使用的接口是否完整和正确。顶多会从连接器获得一些（延迟的）错误消息。

##### 强制实施

* 对并未放入 `.h` 而在其他源文件中的实体声明进行标记。

### <a id="rs-include-order"></a>SF.4: 在文件中的其他所有声明之前包含头文件

##### 理由

最小化上下文的依赖并增加可读性。

##### 示例

    #include <vector>
    #include <algorithm>
    #include <string>

    // ... 我自己的代码 ...

##### 示例，不好

    #include <vector>

    // ... 我自己的代码 ...

    #include <algorithm>
    #include <string>

##### 注解

这对于 `.h` 和 `.cpp` 文件都同样适用。

##### 注解

有一种论点是通过在打算保护的代码的*后面*再 `#include` 头文件，以此将代码同头文件中的声明式和宏等之间进行隔离
（如上面例子中标为“不好”之处）。
不过，

* 这只能对单个文件（在单个层次上）工作：如果采用这个技巧的头文件被别的头文件所包含，这个威胁就会再次出现。
* 命名空间（一个“实现命名空间”）可以针对许多的上下文依赖进行保护。
* 完全的保护和灵活性需要模块。

**参见**：

* [工作草案，C++ 的模块扩展](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf)
* [模块，组件化及其迁移](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf)

##### 强制实施

容易。

### <a id="rs-consistency"></a>SF.5: `.cpp` 文件必须包含定义了它的接口的一个或多个头文件

##### 理由

这使得编译器可以提早进行一致性检查。

##### 示例，不好

    // foo.h:
    void foo(int);
    int bar(long);
    int foobar(int);

    // foo.cpp:
    void foo(int) { /* ... */ }
    int bar(double) { /* ... */ }
    double foobar(int);

这个错误直到调用了 `bar` 或 `foobar` 的程序的连接时才会被发现。

##### 示例

    // foo.h:
    void foo(int);
    int bar(long);
    int foobar(int);

    // foo.cpp:
    #include "foo.h"

    void foo(int) { /* ... */ }
    int bar(double) { /* ... */ }
    double foobar(int);   // 错误: 错误的返回类型

`foobar` 的返回类型错误在编译 `foo.cpp` 时立即就被发现了。
对 `bar` 的参数类型错误在连接时之前无法被发现，因为可能会有重载发生，但系统性地使用 `.h` 文件能够增加时其被程序员更早发现的可能性。

##### 强制实施

???

### <a id="rs-using"></a>SF.6: `using namespace` 指令，（仅）可以为迁移而使用，可以为基础程序库使用（比如 `std`），或者在局部作用域中使用

##### 理由

`using namespace` 可能造成名字冲突，因而应当节制使用。
然而，将用户代码中的每个命名空间中的名字都进行限定并不总是能够做到（比如在转换过程中）
而且有时候命名空间非常基础，并且在代码库中广为使用，坚持进行限定将使其既啰嗦又分散注意力。

##### 示例

    #include <string>
    #include <vector>
    #include <iostream>
    #include <memory>
    #include <algorithm>

    using namespace std;

    // ...

显然地，大量使用了标准库，而且貌似没使用别的程序库，因此要求每一处带有使用 `std::`
会使人分散注意力。

##### 示例

使用 `using namespace std;` 导致程序员可能面临与标准库中的名字造成名字冲突

    #include <cmath>
    using namespace std;

    int g(int x)
    {
        int sqrt = 7;
        // ...
        return sqrt(x); // 错误
    }

不过，不大可能导致并非错误的名字解析，
假定使用 `using namespace std` 的人们都了解 `std` 以及这种风险。

##### 注解

`.cpp` 文件也是一种形式的局部作用域。
包含一条 `using namespace X` 的 N 行的 `.cpp` 文件中发生名字冲突的机会，
和包含一条 `using namespace X` 的 N 行的函数，
以及每个都包含一条 `using namespace X` 的总行数为 N 行的 M 个函数，没有多少差别。

##### 注解

[请勿在头文件全局作用域中使用 `using namespace`](#rs-using-directive)。

### <a id="rs-using-directive"></a>SF.7: 请勿在头文件中的全局作用域使用 `using namespace`

##### 理由

这样做使 `#include` 一方无法有效地进行区分并使用其他方式。这还可能使所 `#include` 的头文件之间出现顺序依赖，它们以不同次序包含时可能具有不同的意义。

##### 示例

    // bad.h
    #include <iostream>
    using namespace std; // bad

    // user.cpp
    #include "bad.h"

    bool copy(/*... some parameters ...*/);    // some function that happens to be named copy

    int main()
    {
        copy(/*...*/);    // now overloads local ::copy and std::copy, could be ambiguous
    }

##### 注解

一个例外是 `using namespace std::literals;`。若要在头文件中使用
字符串字面量，则必须如此，而且根据[规则](http://eel.is/c++draft/over.literal)——用户必须以
`operator""_x` 来命名他们自己的 UDL——它们并不会与标准库相冲突。

##### 强制实施

标记头文件的全局作用域中的 `using namespace`。

### <a id="rs-guards"></a>SF.8: 为所有的头文件使用 `#include` 防卫宏

##### 理由

避免文件被多次 `#include`。

为避免包含防卫宏的冲突，不要仅使用文件名来命名防卫宏。
确保还要包含一个关键词和好的区分词，比如头文件所属的程序库
或组件的名字。

##### 示例

    // file foobar.h:
    #ifndef LIBRARY_FOOBAR_H
    #define LIBRARY_FOOBAR_H
    // ... 声明 ...
    #endif // LIBRARY_FOOBAR_H

##### 强制实施

标记没有 `#include` 防卫的 `.h` 文件。

##### 注解

一些实现提供了如 `#pragma once` 这样的厂商扩展作为包含防卫宏的替代。
这并非标准且不可移植。它向程序中注入了宿主机器的文件系统的语义，
而且把你锁定到某个特定厂商。
我们的建议是编写 ISO C++：参见[规则 P.2](#rp-cplusplus)。

### <a id="rs-cycles"></a>SF.9: 避免源文件的循环依赖

##### 理由

循环会使理解变得困难，并拖慢编译速度。
它们还会使（当其可用时）向利用语言支持的模块进行转换工作变得复杂。


##### 注解

要消除循环依赖；请勿仅仅用 `#include` 防卫宏来试图打破它们。

##### 示例，不好

    // file1.h:
    #include "file2.h"

    // file2.h:
    #include "file3.h"

    // file3.h:
    #include "file1.h"

##### 强制实施

对任何循环依赖进行标记。


### <a id="rs-implicit"></a>SF.10: 避免依赖于隐含地 `#include` 进来的名字

##### 理由

避免意外。
避免当 `#include` 的头文件改变时改变一条 `#include`。
避免意外地变为依赖于所包含的头文件中的实现细节和逻辑上独立的实体。

##### 示例，不好

    #include <iostream>
    using namespace std;

    void use()
    {
        string s;
        cin >> s;               // 好
        getline(cin, s);        // 错误：getline() 未定义
        if (s == "surprise") {  // 错误：== 未定义
            // ...
        }
    }

`<iostream>` 暴露了 `std::string` 的定义（“为什么？”是一个有趣的问题），
但其并不必然是通过传递包含整个 `<string>` 头文件而做到这一点的，
这带来了常见的新手问题“为什么 `getline(cin,s);` 不成？”，
甚至偶尔出现的“`string` 无法用 `==` 来比较”。

其解决方案是明确地 `#include <string>`：

##### 示例，好

    #include <iostream>
    #include <string>
    using namespace std;

    void use()
    {
        string s;
        cin >> s;               // 好
        getline(cin, s);        // 好
        if (s == "surprise") {  // 好
            // ...
        }
    }

##### 注解

一些头文件正是用于从一些头文件中合并一组声明。
例如：

    // basic_std_lib.h:

    #include <string>
    #include <map>
    #include <iostream>
    #include <random>
    #include <vector>

用户只用一条 `#include` 就可以获得整组的声明了：

    #include "basic_std_lib.h"

本条反对隐式包含的规则并不防止这种特意的聚集包含。

##### 强制实施

强制实施将需要一些有关头文件中哪些是“导出”给用户所用而哪些是用于实现的知识。
在我们能用到模块之前没有真正的好方案。

### <a id="rs-contained"></a>SF.11: 头文件应当是自包含的

##### 理由

易用性，头文件应当易于使用，且单独包含即可正常工作。
头文件应当对其所提供的功能进行封装。
避免让头文件的使用方来管理它的依赖项。

##### 示例

    #include "helpers.h"
    // helpers.h 依赖于 std::string 并已包含了 <string>

##### 注解

不遵守这条规则将导致头文件的使用方难于诊断所出现的错误。

##### 注解

头文件应当包含其所有依赖项。请小心使用相对路径，各 C++ 实现对于它们的含义是有分歧的。

##### 强制实施

以一项测试来验证头文件自身可通过编译，或者一个仅包含了该头文件的 cpp 文件可通过编译。

### <a id="rs-incform"></a>SF.12: 对相对于包含文件的文件优先采用引号形式的 `#include`，其他情况下采用角括号形式

##### 理由

[标准](http://eel.is/c++draft/cpp.include) 向编译器提供了对于实现
使用角括号（`<>`）或引号（`""`）语法的 `#include` 的两种形式的灵活性。
各厂商利用了这点并采用了不同的搜索算法和指定包含路径的方法。

无论如何，指导方针是使用引号形式来（从同一个组件或项目中）包含那些存在于某个相对于含有这条 `#include` 语句的文件的相对路径中的文件，其他情况尽可能使用角括号形式。这样做鼓励明确表现出文件与包含它的文件之间的局部性，或当需要某种不同的搜索算法的情形。这样一眼就可以很容易明白头文件是从某个局部相对文件包含的，还是某个标准库头文件或别的搜索路径（比如另一个程序库或一组常用包含路径）中的某个头文件。

##### 示例

    // foo.cpp:
    #include <string>                // 来自标准程序库，要求使用 <> 形式
    #include <some_library/common.h> // 从另一个程序库中包含的，并非出于局部相对位置的文件；使用 <> 形式
    #include "foo.h"                 // 处于同一项目中局部相对于 foo.cpp 的文件，使用 "" 形式
    #include "foo_utils/utils.h"     // 处于同一项目中局部相对于 foo.cpp 的文件，使用 "" 形式
    #include <component_b/bar.h>     // 通过搜索路径定位到的处于同一项目中的文件，使用 <> 形式

##### 注解

不遵守这条可能会导致很难诊断的错误：由于包含时指定的错误的范围而选择了错误的文件。例如，通常 `#include ""` 的搜索算法首先搜索存在于某个局部相对路径中的文件，因此使用这种形式来指代某个并非位于局部相对路径的文件，就一位置一旦在局部相对路径中出现了一个这样的文件（比如进行包含的文件被移动到了别的位置），它就会在原来所包含的文件之前被找到，并使包含文件集合以一种预料之外的方式被改变。

程序库作者们应当把它们的头文件放到一个文件夹中，然后让其客户使用相对路径来包含这些文件：`#include <some_library/common.h>`。

##### 强制实施

检测按 `""` 引用的头文件是否可以按 `<>` 引用。

### <a id="rs-namespace"></a>SF.20: 用 `namespace` 表示逻辑结构

##### 理由

 ???

##### 示例

    ???

##### 强制实施

???

### <a id="rs-unnamed"></a>SF.21: 请勿在头文件中使用无名（匿名）命名空间

##### 理由

在头文件中使用无名命名空间差不多都是一个 BUG。

##### 示例

    // 文件 foo.h:
    namespace
    {
        const double x = 1.234;  // 不好

        double foo(double y)     // 不好
        {
            return y + x;
        }
    }

    namespace Foo
    {
        const double x = 1.234; // 好

        inline double foo(double y)        // 好
        {
            return y + x;
        }
    }

##### 强制实施

* 对头文件中所使用的任何匿名命名空间进行标记。

### <a id="rs-unnamed2"></a>SF.22: 为所有的内部/不导出的实体使用无名（匿名）命名空间

##### 理由

外部实体无法依赖于嵌套的无名命名空间中的实体。
考虑将实现源文件中的所有定义都放入无名命名空间中，除非它定义的是一个“外部/导出”实体。

##### 示例；不好

    static int f();
    int g();
    static bool h();
    int k();

##### 示例；好

    namespace {
        int f();
        bool h();
    }
    int g();
    int k();

##### 示例

API 类及其成员不能放在无名命名空间中；而在实现源文件中所定义的任何的“辅助”类或函数则应当放在无名命名空间作用域之中。

    ???

##### 强制实施

* ???

# <a id="s-stdlib"></a>SL: 标准库

如果只使用纯语言本身的话，任何开发任务都会变得很麻烦（无论以何种语言）。
如果使用了某个合适的程序库的话，则任何开发任务都会变得相当简单。

这些年来标准库一直在持续增长。
现在它在标准中的描述已经比语言功能特性的描述更大了。
因此，可能指导方针的库部分的规模最终将会增长等于甚至超过其他的所有部分。

<< ??? 我们需要另一个层次的规则编号 ??? >>

C++ 标准库组件概览：

* [SL.con: 容器](#ss-con)
* [SL.str: 字符串](#ss-string)
* [SL.io: I/O 流（iostream）](#ss-io)
* [SL.regex: 正则表达式](#ss-regex)
* [SL.chrono: 时间](#ss-chrono)
* [SL.C: C 标准库](#ss-clib)

标准库规则概览：

* [SL.1: 尽可能使用程序库](#rsl-lib)
* [SL.2: 优先使用标准库而不是其他程序库](#rsl-sl)
* [SL.3: 请勿向命名空间 `std` 中添加非标准实体](#sl-std)
* [SL.4: 以类型安全的方式使用标准库](#sl-safe)
* ???

### <a id="rsl-lib"></a>SL.1:  尽可能使用程序库

##### 理由

节约时间。避免重复发明轮子。
避免重复他人的工作。
如果其他人的工作有了改进，则可以从中获得好处。
当你进行了改进之后可以帮助其他人。

### <a id="rsl-sl"></a>SL.2: 优先使用标准库而不是其他程序库

##### 理由

了解标准库的人更多。
相对于你自己的代码或者大多数其他程序库来说，标准库更加倾向于稳定，进行了良好维护，而且广泛可用。


### <a id="sl-std"></a>SL.3: 请勿向命名空间 `std` 中添加非标准实体

##### 理由

向 `std` 中添加东西可能会改变本来是遵循标准的代码的含义。
添加到 `std` 的东西可能会与未来版本的标准产生冲突。

##### 示例

    namespace std { // 不好：违反标准

    class My_vector {
        //     . . .
    };

    }

    namespace Foo { // 好：允许使用用户命名空间

    class My_vector {
        //     . . .
    };

    }

##### 强制实施

有可能，但很麻烦而且在一些平台上很可能导致一些问题。

### <a id="sl-safe"></a>SL.4: 以类型安全的方式使用标准库

##### 理由

因为，很显然，违反这条规则将导致未定义的行为，内存损坏，以及其他所有种类的糟糕的错误。

##### 注解

本条规则是半哲学性的元规则，需要许多具体规则予以支持。
我们需要将之作为对于更加专门的规则的总括。

更加专门的规则概览：

* [SL.4: 以类型安全的方式使用标准库](#sl-safe)


## <a id="ss-con"></a>SL.con: 容器

???

容器规则概览：

* [SL.con.1: 优先采用 STL 的 `array` 或 `vector` 而不是 C 数组](#rsl-arrays)
* [SL.con.2: 除非有理由使用别的容器，否则默认情况应优先采用 STL 的 `vector`](#rsl-vector)
* [SL.con.3: 避免边界错误](#rsl-bounds)
* [SL.con.4: 请勿对非可平凡复制的实参使用 `memset` 或 `memcpy`](#rsl-copy)

### <a id="rsl-arrays"></a>SL.con.1: 优先采用 STL 的 `array` 或 `vector` 而不是 C 数组

##### 理由

C 数组不那么安全，而且相对于 `array` 和 `vector` 也没有什么优势。
对于定长数组，应使用 `std::array`，它传递给函数时并不会退变为指针并丢失其大小信息。
而且，和内建数组一样，栈上分配的 `std::array` 会在栈上保存它的各个元素。
对于变长数组，应使用 `std::vector`，它还可以改变大小并处理内存分配。

##### 示例

    int v[SIZE];                        // 不好

    std::array<int, SIZE> w;            // ok

##### 示例

    int* v = new int[initial_size];     // 不好，有所有权的原生指针
    delete[] v;                         // 不好，手工 delete

    std::vector<int> w(initial_size);   // ok

##### 注解

在不拥有而引用容器中的元素时使用 `gsl::span`。

##### 注解

在栈上分配的固定大小的数组和把元素都放在自由存储上的 `vector` 之间比较性能是没什么意义的。
你同样也可以在栈上的 `std::array` 和通过指针访问 `malloc()` 的结果之间进行这样的比较。
对于大多数代码来说，即便是栈上分配和自由存储分配之间的差异也没那么重要，但 `vector` 带来的便利和安全性却是重要的。
如果有人编写的代码中这种差异确实重要，那么他显然可以在 `array` 和 `vector` 之间做出选择。

##### 强制实施

* 如果 C 数组的声明所在的函数或类也声明了 STL 的某个容器（这是为了避免在老式的非 STL 代码中的大量警告噪音），则对其进行标记。修正：最少要把 C 数组改成 `std::array`。

### <a id="rsl-vector"></a>SL.con.2: 除非有理由使用别的容器，否则默认情况应优先采用 STL 的 `vector`

##### 理由

`vector` 和 `array` 是仅有的能够提供以下各项优势的标准容器：

* 最快的通用访问（随机访问，还包括对于向量化友好性）；
* 最快的默认访问模式（从头到尾或从尾到头方式是对预读器友好的）；
* 最少的空间耗费（连续布局中没有每个元素的开销，而且是 cache 友好的）。

通常你都需要对容器进行元素的添加和删除，因此默认应当采用 `vector`；如果并不需要改动容器的大小的话，则应采用 `array`。

即便其他容器貌似更加合适，比如 `map` 的 O(log N) 查找性能，或者 `list` 的中部高效插入，对于几个 KB 以内大小的容器来说，`vector` 仍然经常性能更好。

##### 注解

`string` 不应当用作独立字符的容器。`string` 是文本字符串；如果需要字符的容器的话，应当采用 `vector</*char_type*/>` 或者 `array</*char_type*/>`。

##### 例外

如果你有正当的理由来使用别的容器的话，就请使用它。例如：

* 若 `vector` 满足你的需求，但你并不需要容器大小可变，则应当代之以 `array`。

* 若你需要支持字典式查找的容器并保证 O(K) 或 O(log N) 的查找效率，而且容器将会比较大（超过几个 KB），你需要经常进行插入使得维护有序的 `vector` 的开销不大可行，则请代之以使用 `unordered_map` 或者 `map`。

##### 注解

使用 `()` 初始化来将 `vector` 初始化为具有特定数量的元素。
使用 `{}` 初始化来以一个元素列表来对 `vector` 进行初始化。

    vector<int> v1(20);  // v1 具有 20 个值为 0 的元素（vector<int>{}）
    vector<int> v2 {20}; // v2 具有 1 个值为 20 的元素

[优先采用 `{}` 初始化式语法](#res-list)。

##### 强制实施

* 如果 `vector` 构造之后大小不会改变（比如因为它是 `const` 或者因为没有对它调用过非 `const` 函数），则对其进行标记。修正：代之以使用 `array`。

### <a id="rsl-bounds"></a>SL.con.3: 避免边界错误

##### 理由

越过已分配的元素的范围进行读写，通常都会导致糟糕的错误，不正确的结果，程序崩溃，以及安全漏洞。

##### 注解

应用于一组元素的范围的标准库函数，都有（或应当有）接受 `span` 的边界安全重载。
如 `vector` 这样的标准类型，在边界剖面配置下（以某种不兼容的方式，如添加契约）可以被修改为实施边界检查，或者使用 `at()`。

理想情况下，边界内保证应当可以被静态强制实行。
例如：

* 基于范围的 `for` 的循环不会越过其所针对的容器的范围
* `v.begin(),v.end()` 可以很容易确定边界安全性

这种循环和任何的等价的无检查或不安全的循环一样高效。

通常，可以用一个简单的预先检查来消除检查每个索引的需要。
例如

* 对于 `v.begin(),v.begin()+i`，`i` 可以很容易针对 `v.size()` 检查

这种循环比每次都待检查元素访问要快得多。

##### 示例，不好

    void f()
    {
        array<int, 10> a, b;
        memset(a.data(), 0, 10);         // 不好，且包含长度错误（length = 10 * sizeof(int)）
        memcmp(a.data(), b.data(), 10);  // 不好，且包含长度错误（length = 10 * sizeof(int)）
    }

而且，`std::array<>::fill()` 或 `std::fill()`，甚或是空的初始化式，都是比 `memset()` 更好的候选。

##### 示例，好

    void f()
    {
        array<int, 10> a, b, c{};       // c 被初始化为零
        a.fill(0);
        fill(b.begin(), b.end(), 0);    // std::fill()
        fill(b, 0);                     // std::ranges::fill()

        if ( a == b ) {
          // ...
        }
    }

##### Example

如果代码使用的是未修改的标准库，仍然有一些变通方案来以边界安全的方式使用 `std::array` 和 `std::vector`。代码中可以调用各个类的 `.at()` 成员函数，这将抛出 `std::out_of_range` 异常。或者，代码中可以调用 `at()` 自由函数，这将在边界违例时导致快速失败（或者某个自定义动作）。

    void f(std::vector<int>& v, std::array<int, 12> a, int i)
    {
        v[0] = a[0];        // 不好
        v.at(0) = a[0];     // OK（替代方案 1）
        at(v, 0) = a[0];    // OK（替代方案 2）

        v.at(0) = a[i];     // 不好
        v.at(0) = a.at(i);  // OK（替代方案 1）
        v.at(0) = at(a, i); // OK（替代方案 2）
    }

##### 强制实施

* 对于没有边界检查的标准库函数的任何调用都给出诊断消息。
??? 在这里添加一组禁用函数的连接列表

本条规则属于[边界剖面配置](#ss-bounds)。


### <a id="rsl-copy"></a>SL.con.4: 请勿对非可平凡复制的实参使用 `memset` 或 `memcpy`

##### 理由

这样做会破坏对象语义（例如，其会覆写掉 `vptr`）。

##### 注解

`(w)memset`，`(w)memcpy`，`(w)memmove`，以及 `(w)memcmp` 与此相似。

##### 示例

    struct base {
        virtual void update() = 0;
    };

    struct derived : public base {
        void update() override {}
    };


    void f (derived& a, derived& b) // 虚表再见！
    {
        memset(&a, 0, sizeof(derived));
        memcpy(&a, &b, sizeof(derived));
        memcmp(&a, &b, sizeof(derived));
    }

应当代之以定义适当的默认初始化，复制，以及比较函数

    void g(derived& a, derived& b)
    {
        a = {};    // 默认初始化
        b = a;     // 复制
        if (a == b) do_something(a,b);
    }

##### 强制实施

* 对在不可平凡复制的类型使用这些函数进行标记

**TODO 注释**:

* 对于标准库的影响需要和 WG21 之间进行紧密的协调，即便不需要标准化也应当至少保证兼容性。
* 我们正在考虑为标准库（尤其是 C 标准库）中如 `memcmp` 这样的函数指定边界安全的重载，并在 GSL 中提供它们。
* 对于标准中没有进行完全的边界检查的现存函数和如 `vector` 这样的类型来说，我们的目标是在启用了边界剖面配置的代码中调用时，这些功能应当进行边界检查，而从遗留代码中调用时则没有检查，可能需要利用契约来实现（正由几个 WG21 成员进行提案工作）。



## <a id="ss-string"></a>SL.str: 字符串

文本处理是一个大的主题。
`std::string` 无法全部覆盖这些。
这一部分主要尝试澄清 `std::string` 和 `char*`、`zstring`、`string_view` 和 `gsl::span<char>` 之间的关系。
有关非 ASCII 字符集和编码的重要问题（比如 `wchar_t`，Unicode，以及 UTF-8 等）将在别处讨论。

**参见**：[正则表达式](#ss-regex)

在这里，我们用“字符序列”或“字符串”来代表（终将）作为文本来读取的字符序列。
We don't consider ???

字符串概览：

* [SL.str.1: 使用 `std::string` 以拥有字符序列](#rstr-string)
* [SL.str.2: 使用 `std::string_view` 或 `gsl::span<char>` 以指代字符序列](#rstr-view)
* [SL.str.3: 使用 `zstring` 或 `czstring` 以指代 C 风格、以零结尾的字符序列](#rstr-zstring)
* [SL.str.4: 使用 `char*` 以指代单个字符](#rstr-char*)
* [SL.str.5: 使用 `std::byte` 以指代并不必须表示字符的字节值](#rstr-byte)

* [SL.str.10: 当需要实施相关于文化地域的操作时，使用 `std::string`](#rstr-locale)
* [SL.str.11: 当需要改动字符串时，使用 `gsl::span<char>` 而不是 `std::string_view`](#rstr-span)
* [SL.str.12: 为作为标准库的 `string` 类型的字符串字面量使用后缀 `s`](#rstr-s)

**参见**：

* [F.24 span](#rf-range)
* [F.25 zstring](#rf-zstring)


### <a id="rstr-string"></a>SL.str.1: 使用 `std::string` 以拥有字符序列

##### 理由

`string` 能够正确处理资源分配，所有权，复制，渐进扩容，并提供许多有用的操作。

##### 示例

    vector<string> read_until(const string& terminator)
    {
        vector<string> res;
        for (string s; cin >> s && s != terminator; ) // 读取一个单词
            res.push_back(s);
        return res;
    }

注意已经为 `string` 提供了 `>>` 和 `!=`（作为有用操作的例子），并且没有显示的内存分配，
回收，或者范围检查（`string` 会处理这些）。

C++17 中，我们可以使用 `string_view` 而不是 `const string&` 作为参数，以允许调用方更大的灵活性：

    vector<string> read_until(string_view terminator)   // C++17
    {
        vector<string> res;
        for (string s; cin >> s && s != terminator; ) // 读取一个单词
            res.push_back(s);
        return res;
    }

##### 示例，不好

不要使用 C 风格的字符串来进行需要不单纯的内存管理的操作：

    char* cat(const char* s1, const char* s2)   // 当心！
        // return s1 + '.' + s2
    {
        int l1 = strlen(s1);
        int l2 = strlen(s2);
        char* p = (char*)malloc(l1 + l2 + 2);
        strcpy(p, s1, l1);
        p[l1] = '.';
        strcpy(p + l1 + 1, s2, l2);
        p[l1 + l2 + 1] = 0;
        return p;
    }

我们搞对了吗？
调用者能记得要对返回的指针调用 `free()` 吗？
这段代码能通过安全性评审吗？

##### 注解

没有测量就不要假设 `string` 比底层技术慢，要记得并非所有代码都是性能攸关的。
[请勿进行不成熟的优化](#rper-knuth)

##### 强制实施

???

### <a id="rstr-view"></a>SL.str.2: 使用 `std::string_view` 或 `gsl::span<char>` 以指代字符序列

##### 理由

`std::string_view` 或 `gsl::span<char>` 提供了简易且（潜在）安全的对字符序列的访问，并与序列的
分配和存储方式无关。

##### 示例

    vector<string> read_until(string_view terminator);

    void user(zstring p, const string& s, string_view ss)
    {
        auto v1 = read_until(p);
        auto v2 = read_until(s);
        auto v3 = read_until(ss);
        // ...
    }

##### 注解

`std::string_view`（C++17）是只读的。

##### 强制实施

???

### <a id="rstr-zstring"></a>SL.str.3: 使用 `zstring` 或 `czstring` 以指代 C 风格、以零结尾的字符序列

##### 理由

可读性。
明确意图。
普通的 `char*` 可以是指向单个字符的指针，指向字符数组的指针，指向 C 风格（零结尾）字符串的指针，甚或是指向小整数的指针。
对这些情况加以区分能够避免误解和 BUG。

##### 示例

    void f1(const char* s); // s 可能是个字符串

我们所知的只不过是它可能是 nullptr 或者指向至少一个字符

    void f1(zstring s);     // s 是 C 风格字符串或者 nullptr
    void f1(czstring s);    // s 是 C 风格字符串常量或者 nullptr
    void f1(std::byte* s);  // s 是某个字节的指针（C++17）

##### 注解

除非确实有理由，否则不要把 C 风格的字符串转换为 `string`。

##### 注解

与其他的“普通指针”一样，`zstring` 不能表达所有权。

##### 注解

已经存在了上亿行的 C++ 代码，它们大多使用 `char*` 和 `const char*` 却并不注明其意图。
各种不同的方式都在使用它们，包括以之表示所有权，以及（代替 `void*`）作为通用的内存指针。
很难区分这些用法，因此这条指导方针很难被遵守。
而这是 C 和 C++ 程序中的最主要的 BUG 来源之一，因此一旦可行就遵守这条指导方针是值得的。

##### 强制实施

* 标记在 `char*` 上使用的 `[]`
* 标记在 `char*` 上使用的 `delete`
* 标记在 `char*` 上使用的 `free()`

### <a id="rstr-char*"></a>SL.str.4: 使用 `char*` 以指代单个字符

##### 示例

现存代码中对 `char*` 的各种不同用法，是一种主要的错误来源。

##### 示例，不好

    char arr[] = {'a', 'b', 'c'};

    void print(const char* p)
    {
        cout << p << '\n';
    }

    void use()
    {
        print(arr);   // 运行时错误；可能非常糟糕
    }

数组 `arr` 并非 C 风格字符串，因为它不是零结尾的。

##### 替代方案

参见 [`zstring`](#rstr-zstring)，[`string`](#rstr-string)，以及 [`string_view`](#rstr-view)。

##### 强制实施

* 标记在 `char*` 上使用的 `[]`

### <a id="rstr-byte"></a>SL.str.5: 使用 `std::byte` 以指代并不必须表示字符的字节值

##### 理由

用 `char*` 来表示指向不一定是字符的东西的指针会造成混乱，
并会妨碍有价值的优化。

##### 示例

    ???

##### 注解

C++17

##### 强制实施

???


### <a id="rstr-locale"></a>SL.str.10: 当需要实施相关于文化地域的操作时，使用 `std::string`

##### 理由

`std::string` 支持标准库的 [`locale` 功能](#rstr-locale)

##### 示例

    ???

##### 注解

???

##### 强制实施

???

### <a id="rstr-span"></a>SL.str.11: 当需要改动字符串时，使用 `gsl::span<char>` 而不是 `std::string_view`

##### 理由

`std::string_view` 是只读的。

##### 示例

???

##### 注解

???

##### 强制实施

编译器会标记出试图写入 `string_view` 的地方。

### <a id="rstr-s"></a>SL.str.12: 为作为标准库的 `string` 类型的字符串字面量使用后缀 `s`

##### 理由

直接表达想法能够最小化犯错机会。

##### 示例

    auto pp1 = make_pair("Tokyo", 9.00);         // {C 风格字符串,double} 有意如此？
    pair<string, double> pp2 = {"Tokyo", 9.00};  // 稍微啰嗦
    auto pp3 = make_pair("Tokyo"s, 9.00);        // {std::string,double}    // C++14
    pair pp4 = {"Tokyo"s, 9.00};                 // {std::string,double}    // C++17



##### 强制实施

???


## <a id="ss-io"></a>SL.io: I/O 流（iostream）

`iostream` 是一种类型安全的，可扩展的，带格式的和无格式的流式 I/O 的 I/O 程序库。
它支持多种（且用户可扩展的）缓冲策略以及多种文化地域。
它可以用于进行便利的 I/O，内存读写（字符串流），
以及用户定义的扩展，诸如跨网络的流（asio：尚未标准化）。

I/O 流规则概览：

* [SL.io.1: 仅在必要时才使用字符层面的输入](#rio-low)
* [SL.io.2: 当进行读取时，总要考虑非法输入](#rio-validate)
* [SL.io.3: 优先使用 iostream 进行 I/O](#rio-streams)
* [SL.io.10: 除非你使用了 `printf` 族函数，否则要调用 `ios_base::sync_with_stdio(false)`](#rio-sync)
* [SL.io.50: 避免使用 `endl`](#rio-endl)
* [???](#???)

### <a id="rio-low"></a>SL.io.1: 仅在必要时才使用字符层面的输入

##### 理由

除非你确实仅处理单个的字符，否则使用字符级的输入将导致用户代码实施潜在易错的
且潜在低效的从字符进行标记组合的工作。

##### 示例

    char c;
    char buf[128];
    int i = 0;
    while (cin.get(c) && !isspace(c) && i < 128)
        buf[i++] = c;
    if (i == 128) {
        // ... 处理过长的字符串 ....
    }

更好的做法（简单得多而且可能更快）：

    string s;
    s.reserve(128);
    cin>>s;

而且额能并不需要 `reserve(128)`。

##### 强制实施

???


### <a id="rio-validate"></a>SL.io.2: 当进行读取时，总要考虑非法输入

##### 理由

错误通常最好尽快处理。
如果输入无效，所有的函数都必须编写为对付不良的数据（而这并不现实）。

##### 示例

    ???

##### 强制实施

???

### <a id="rio-streams"></a>SL.io.3: 优先使用 iostream 进行 I/O

##### 理由

`iosteam` 安全，灵活，并且可扩展。

##### 示例

    // 写出一个复数：
    complex<double> z{ 3,4 };
    cout << z << '\n';

`complex` 是一个用户定义的类型，而其 I/O 的定义无需改动 `iostream` 库。

##### 示例

    // 读取一系列复数：
    for (complex<double> z; cin>>z)
        v.push_back(z);

##### 例外

??? 性能 ???

##### 讨论：`iostream` vs. `printf()` 家族

人们通常说（并且通常是正确的）`printf` 家族比 `iostream` 有两个优势：
格式化的灵活性和性能。
这需要与 `iostream` 在处理用户定义类型方面的扩展性，针对安全性的违反方面的韧性，
隐含的内存管理，以及 `locale` 处理等优势之间进行权衡。

如果需要 I/O 性能的话，你几乎总能做到比 `printf()` 更好。

`gets()`，使用 `%s` 的 `scanf()`，和使用 `%s` 的 `printf()` 在安全性方面冒风险（容易遭受缓冲区溢出问题而且通常很易错）。
C11 定义了一些“可选扩展”，它们对其实参进行一些额外检查。
如果您的 C 程序库中包含 `gets_s()`、`scanf_s()` 和 `printf_s()`，它们也许是更安全的替代方案，但仍然并非是类型安全的。

##### 强制实施

可选地标记 `<cstdio>` 和 `<stdio.h>`。

### <a id="rio-sync"></a>SL.io.10: 除非你使用了 `printf` 族函数，否则要调用 `ios_base::sync_with_stdio(false)`

##### 理由

`iostreams` 和 `printf` 风格的 I/O 之间的同步是由代价的。
`cin` 和 `cout` 默认是与 `printf` 相同步的。

##### 示例

    int main()
    {
        ios_base::sync_with_stdio(false);
        // ... 使用 iostreams ...
    }

##### 强制实施

???

### <a id="rio-endl"></a>SL.io.50: 避免使用 `endl`

##### 理由

`endl` 操纵符大致相当于 `'\n'` 和 `"\n"`；
其最常用的情况只不过会以添加多余的 `flush()` 的方式拖慢程序。
与 `printf` 式输出相比，这种拖慢程度是比较显著的。

##### 示例

    cout << "Hello, World!" << endl;    // 两次输出操作和一次 flush
    cout << "hello, World!\n";          // 一次输出操作且没有 flush

##### 注解

对于 `cin`/`cout`（或同等设备）的交互来说，没什么原因必须进行冲洗；它们是自动进行的。
对于向文件写入来说，也很少需要 `flush`。

##### 注解

对于字符串流（指 `ostringstream`），插入一个 `endl` 完全等价于
插入一个 `'\n'` 字符，但正是这种情况下，`endl` 可能会明显比较慢。

`endl` *并不*关注产生平台专有的行结尾序列（比如 Windows 上的 `"\r\n"`）。
因此，字符串流的 `s << endl` 只会插入*单个* `'\n'` 字符。

##### 注解

除了（偶尔会比较重要的）性能问题外，
从 `"\\n"` 和 `endl` 之间进行选择基本上完全是审美问题。

## <a id="ss-regex"></a>SL.regex: 正则表达式

`<regex>` 是标准 C++ 的正则表达式库。
它支持许多正则表达式的模式约定。

## <a id="ss-chrono"></a>SL.chrono: 时间

`<chrono>`（在命名空间 `std::chrono` 中定义）提供了 `time_point` 和 `duration`，并同时提供了
用于以各种不同单位输出时间的函数。
它还提供了用于注册 `time_point` 的时钟。

## <a id="ss-clib"></a>SL.C: C 标准库

???

C 标准库规则概览：

* [SL.C.1: 请勿使用 setjmp/longjmp](#rclib-jmp)
* [???](#???)
* [???](#???)

### <a id="rclib-jmp"></a>SL.C.1: 请勿使用 setjmp/longjmp

##### 理由

`longjmp` 会忽略析构函数，由此使得依赖于 RAII 的所有资源管理策略全部失效。

##### 强制实施

标记出现的所有 `longjmp` 和 `setjmp`




# <a id="s-a"></a>A: 架构设计的观念

本部分包括有关高层次的架构性观念和程序库的观念。

架构性规则概览：

* [A.1: 分离稳定的代码和不稳定的代码](#ra-stable)
* [A.2: 将潜在可复用的部分作为程序库](#ra-lib)
* [A.4: 程序库之间不能有循环依赖](#ra-dag)
* [???](#???)
* [???](#???)
* [???](#???)
* [???](#???)
* [???](#???)
* [???](#???)

### <a id="ra-stable"></a>A.1: 分离稳定的代码和不稳定的代码

对较不稳定的代码进行隔离，有助于其单元测试，接口改进，重构，以及最终弃用。

### <a id="ra-lib"></a>A.2: 将潜在可复用的部分作为程序库

##### 理由

##### 注解

程序库是一些共同进行维护，文档化，并发布的声明式和定义式的集合体。
程序库可以是一组头文件（“仅有头文件的程序库”），或者一组头文件加上一组目标文件构成。
你可以静态或动态地将程序库连接到程序中，或者你还可以 `#included` 仅头文件的库。


### <a id="ra-dag"></a>A.4: 程序库之间不能有循环依赖

##### 理由

* 循环依赖导致构建过程变得复杂。
* 循环依赖难于理解，可能会引入不确定性（未定义行为）。

##### 注解

一个程序库可以在它的组件的定义之间包含循环引用。
例如：

    ???

不过，程序库不能对依赖于它的其他程序库产生依赖。


# <a id="s-not"></a>NR: 伪规则和错误的看法

本部分包含一些在不少地方流行的规则和指导方针，但是我们慎重地建议不要采纳它们。
我们完全了解这些规则曾经在某些时间和场合是有意义的，而且我们自己也曾经采用过它们。
不过，在我们所推荐并以各项指导方针所支持的编程风格的情况中，这些“伪规则”是有害的。

即便是今天，仍有一些情况下这些规则是有意义的。
比如说，缺少合适的工具支持会导致异常在硬实时系统中的不适用，
但请不要盲目地信任“通俗智慧”（比如有关“效率”的未经数据支持的观点）；
这种“智慧”也许是基于几十年前的信息，或者是来自于与 C++ 有非常不同性质的语言的经验
（比如 C 或者 Java）。

对于这些伪规则的替代方案的正面观点都在各个规则的“替代方案”部分中给出。

伪规则概览：

* [NR.1: 请勿坚持认为声明都应当放在函数的最上面](#rnr-top)
* [NR.2: 请勿坚持使函数中只保留一个 `return` 语句](#rnr-single-return)
* [NR.3: 请勿避免使用异常](#rnr-no-exceptions)
* [NR.4: 请勿坚持把每个类定义放在其自己的源文件中](#rnr-lots-of-files)
* [NR.5: 请勿采用两阶段初始化](#rnr-two-phase-init)
* [NR.6: 请勿把所有清理操作放在函数末尾并使用 `goto exit`](#rnr-goto-exit)
* [NR.7: 请勿使所有数据成员 `protected`](#rnr-protected-data)
* ???

### <a id="rnr-top"></a>NR.1: 请勿坚持认为声明都应当放在函数的最上面

##### 理由

“所有声明都在开头”的规则，是来自不允许在语句之后对变量和常量进行初始化的老编程语言的遗产。
这样做会导致更长的程序，以及更多由于未初始化的或者错误初始化的变量所导致的错误。

##### 示例，不好

    int use(int x)
    {
        int i;
        char c;
        double d;

        // ... 做一些事 ...

        if (x < i) {
            // ...
            i = f(x, d);
        }
        if (i < x) {
            // ...
            i = g(x, c);
        }
        return i;
    }

未初始化变量和其使用点的距离越长，出现 BUG 的机会就越大。
幸运的是，编译器可以发现许多“设值前使用”的错误。
不幸的是，编译器无法捕捉到所有这样的错误，而且一些 BUG 并不都像这个小例子中的这样容易发现。


##### 替代方案

* [坚持为对象进行初始化](#res-always)。
* [ES.21: 不要在确实需要使用变量（或常量）之前就引入它](#res-introduce)。

### <a id="rnr-single-return"></a>NR.2: 请勿坚持使函数中只保留一个 `return` 语句

##### 理由

单返回规则会导致不必要地复杂的代码，并引入多余的状态变量。
特别是，单返回规则导致更难在函数开头集中进行错误检查。

##### 示例

    template<class T>
    //  requires Number<T>
    string sign(T x)
    {
        if (x < 0)
            return "negative";
        if (x > 0)
            return "positive";
        return "zero";
    }

为仅使用一个返回语句，我们得做类似这样的事：

    template<class T>
    //  requires Number<T>
    string sign(T x)        // 不好
    {
        string res;
        if (x < 0)
            res = "negative";
        else if (x > 0)
            res = "positive";
        else
            res = "zero";
        return res;
    }

这不仅更长，而且很可能效率更差。
越长越复杂的函数，对其进行变通就越是痛苦。
当然许多简单的函数因为它们本来就简单的逻辑都天然就只有一个 `return`。

##### 示例

    int index(const char* p)
    {
        if (!p) return -1;  // 错误指标：替代方案是 "throw nullptr_error{}"
        // ... 进行查找以找出 p 的索引
        return i;
    }

如果我们采纳这条规则的话，得做类似这样的事：

    int index2(const char* p)
    {
        int i;
        if (!p)
            i = -1;  // 错误指标
        else {
            // ... 进行查找以找出 p 的索引
        }
        return i;
    }

注意我们（故意地）违反了禁止未初始化变量的规则，因为这种风格通常都会导致这样。
而且，这种风格也会倾向于采用 [goto exit](#rnr-goto-exit) 伪规则。

##### 替代方案

* 保持函数短小简单。
* 随意使用多个 `return` 语句（以及抛出异常）。

### <a id="rnr-no-exceptions"></a>NR.3: 请勿避免使用异常

##### 理由

一般有四种主要的不用异常的理由：

* 异常是低效的
* 异常会导致泄漏和错误
* 异常的性能无法预测
* 异常处理的运行时支持耗费过多空间

我们没有能够满足所有人的解决这个问题的办法。
无论如何，针对异常的讨论已经持续了四十多年了。
一些语言没有异常就无法使用，而另一些并不支持异常。
这在使用和不使用异常的方面都造成了强大的传统，并导致激烈的争论。

不过，我们可以简要说明，为什么我们认为对于通用编程以及这里的指导方针的情况来说，
异常是最佳的候选方案。
简单的论据，无论支持还是反对，都是缺乏说服力的。
确实存在一些特殊的应用，其中异常就是不合适的。
（例如，硬实时系统，且缺乏可靠的对于异常处理的耗费进行估计的支持）。

我们依次来考虑针对异常的主要反对观点：

* 异常是低效的：
和什么相比？
当进行比较时，请确保处理了同样的错误集合，并且它们都进行了等价的处理。
尤其是，不要对一个见到异常就立刻终止的程序和一个在记录错误日志之前
小心地进行资源清理的程序之间进行比较。
确实，某些系统的异常处理实现很糟糕；有时候，这样的实现迫使我们使用
其他错误处理方案，但这并不是异常的基本问题。
当使用某个有效的论据时——无论什么样的上下文——请小心你能拿出确实提供了所讨论的问题的
内部情况的健全的数据。
* 异常会导致泄漏和错误。
不会。
如果你的程序时一大堆乱糟糟的指针而没有总体的资源管理策略，
那么无论你干什么都会有问题。
如果你的系统是由上百万行这样的代码构成的，
那你可能是无法使用异常的，
不过这是一个有关过度和放纵的使用指针的问题，而不是异常的问题。
我们的观点是，你需要用 RAII 来让基于异常的错误处理变得简单且安全——比其他方案都要更简单和安全。
* 异常的性能无法预测。
如果你是在硬实时系统上，而你必须确保一个任务要在给定的时间内完成，
你需要一些工具来支撑这样的保证。
就我们所知，还没有出现这样的工具（至少对大多数程序员没有）。
* 异常处理的运行时支持耗费过多空间
小型（通常为嵌入式）系统中可能如此。
不过在放弃异常之前，请考虑采用统一的利用错误码的错误处理将耗费的空间有多少，
以及错误未被捕获将造成的损失由多少。

许多（可能是大多数）的和异常有关的问题都源自于需要和杂乱的老代码进行交互的历史性原因。

而支持使用异常的基本论点是：

* 它们把错误返回和普通返回进行了清晰的区分
* 它们无法被忘记或忽略
* 它们可以系统化地使用

请记住

* 异常是用于报告错误的（C++ 中；其他语言可能有异常的不同用法）。
* 异常不是用于可以局部处理的错误的。
* 不要试图在每个函数中捕获每一种异常（这样做是冗长的，臃肿的，而且会导致代码缓慢）。
* 异常不是用于那些当发生无法恢复的错误之后需要立即终止模块或系统的错误的。

##### 示例

    ???

##### 替代方案

* [RAII](#re-raii)
* 契约/断言：使用 GSL 的 `Expects` 和 `Ensures`（直到对契约的语言支持可以使用）

### <a id="rnr-lots-of-files"></a>NR.4: 请勿坚持把每个类定义放在其自己的源文件中

##### 理由

将每个类都放进其自己的文件所导致的文件数量难于管理，并会拖慢编译过程。
单个的类很少是一种良好的维护和发布的逻辑单位。

##### 示例

    ???

##### 替代方案

* 使用命名空间来包含逻辑上聚合的类和函数。

### <a id="rnr-two-phase-init"></a>NR.5: 请勿采用两阶段初始化

##### 理由

将初始化拆分为两步会导致不变式的弱化，
更复杂的代码（必须处理半构造对象），
以及错误（当未能一致地正确处理半构造对象时）。

##### 示例，不好

    // 老式传统风格：有许多问题

    class Picture
    {
        int mx;
        int my;
        int * data;
    public:
        // 主要问题：构造函数未进行完全构造
        Picture(int x, int y)
        {
            mx = x;         // 也不好：在构造函数体中而非
                            // 成员初始化式中进行赋值
            my = y;
            data = nullptr; // 也不好：在构造函数中而非
                            // 成员初始化式中进行常量初始化
        }

        ~Picture()
        {
            Cleanup();
        }

        // ...

        // 不好：两阶段初始化
        bool Init()
        {
            // 不变式检查
            if (mx <= 0 || my <= 0) {
                return false;
            }
            if (data) {
                return false;
            }
            data = (int*) malloc(mx*my*sizeof(int));   // 也不好：拥有原始指针，还用了 malloc
            return data != nullptr;
        }

        // 也不好：没有理由让清理操作作为单独的函数
        void Cleanup()
        {
            if (data) free(data);
            data = nullptr;
        }
    };

    Picture picture(100, 0); // 此时 picture 尚未就绪可用
    // 这里将失败
    if (!picture.Init()) {
        puts("Error, invalid picture");
    }
    // 现在有一个无效的 picture 对象实例。

##### 示例，好

    class Picture
    {
        int mx;
        int my;
        vector<int> data;

        static int check_size(int size)
        {
            // 不变式检查
            Expects(size > 0);
            return size;
        }

    public:
        // 更好的方式是以一个 2D 的 Size 类作为单个形参
        Picture(int x, int y)
            : mx(check_size(x))
            , my(check_size(y))
            // 现在已知 x 和 y 为有效的大小
            , data(mx * my) // 出错时将抛出 std::bad_alloc
        {
            // 图片就绪可用
        }

        // 编译器生成的析构函数会完成工作。（另见 C.21）

        // ...
    };

    Picture picture1(100, 100);
    // picture1 已就绪可用……

    // y 并非有效大小值，
    // 缺省的契约违规行为将会调用 std::terminate
    Picture picture2(100, 0);
    // 不会抵达这里……

##### 替代方案

* 始终在构造函数中建立类不变式。
* 不要在需要对象之前就定义它。

### <a id="rnr-goto-exit"></a>NR.6: 请勿把所有清理操作放在函数末尾并使用 `goto exit`

##### 理由

`goto` 是易错的。
这种技巧是进行 RAII 式的资源和错误处理的前异常时代的技巧。

##### 示例，不好

    void do_something(int n)
    {
        if (n < 100) goto exit;
        // ...
        int* p = (int*) malloc(n);
        // ...
        if (some_error) goto_exit;
        // ...
    exit:
        free(p);
    }

请找出其中的 BUG。

##### 替代方案

* 使用异常和 [RAII](#re-raii)
* 对于非 RAII 资源，使用 [`finally`](#re-finally)。

### <a id="rnr-protected-data"></a>NR.7: 请勿使所有数据成员 `protected`

##### 理由

`protected` 数据是一种错误来源。
`protected` 数据可以被各种地方的无界限数量的代码所操纵。
`protected` 数据是在类层次中等价于全局对象的东西。

##### 示例

    ???

##### 替代方案

* [使成员数据 `public` 或者（更好地）`private`](#rh-protected)。


# <a id="s-references"></a>RF: 参考材料

已经为 C++，尤其是对 C++ 的使用编写过了许多的编码标准、规则和指导方针。
它们中许多都

* 关注的是低级问题，比如标识符的拼写
* 是由 C++ 的新手编写的
* 将“禁止程序员作出不常见行为”作为其首要目标
* 将维持许多编译器的可移植性作为目标（有些已经是 10 年前的了）
* 是为了维持好几十年的代码库而编写的
* 是仅关注单一的应用领域的
* 只会产生反效果
* 被忽略了（程序员为了完成工作不得不忽略它们）

不良的编码标准要比没有编码标准还要差。
不过一组恰当的指导方针比没有标准要好得多：“形式即解放。”

我们为什么不能有一种允许所有我们想要的同时又禁止所有我们不期望的东西的语言（“完美的语言”）呢？
本质上说，这是由于可负担的语言（及其工具链）同时也要为那些需求与你不同的人提供服务，并且要为你今后比今天更多的需求提供服务。
而且，你的需求会随时间而改变，而为此你则需要采用一种通用语言。
今日貌似理想的语言在未来可能会变得过于受限了。

编码指导方针可以使语言能够适应于特定的需求。
因此，并不存在适用于每个人的单一编码风格。
我们预计不同的组织会提供更具限制性和更严格的编码风格附加规定。

参考材料部分：

* [RF.rules: 编码规则](#ss-rules)
* [RF.books: 带有编码指导方针的书籍](#ss-books)
* [RF.C++: C++ 编程 (C++11/C++14/C++17)](#ss-cplusplus)
* [RF.web: 网站](#ss-web)
* [RS.video: 有关“当代 C++”的视频](#ss-vid)
* [RF.man: 手册](#ss-man)
* [RF.core: 核心指导方针相关材料](#ss-core)

## <a id="ss-rules"></a>RF.rules: 编码规则

* [AUTOSAR Guidelines for the use of the C++14 language in critical and safety-related systems v17.10](https://www.autosar.org/fileadmin/user_upload/standards/adaptive/17-10/AUTOSAR_RS_CPP14Guidelines.pdf)
* [Boost Library Requirements and Guidelines](http://www.boost.org/development/requirements.html).
  ???.
* [Bloomberg: BDE C++ Coding](https://github.com/bloomberg/bde/wiki/CodingStandards.pdf).
  着重强调了代码的组织和布局。
* Facebook: ???
* [GCC Coding Conventions](https://gcc.gnu.org/codingconventions.html).
  C++03 以及（相当）一部分向后兼容。
* [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html).
  面向 C++17 和（同样）较老的代码库。Google 的专家们现在正展开活跃的合作，以改进这里的各项指导方针，有希望能够合并这些成果，以使它们能够成为他们也同样推荐采纳的一组现代的通用指导方针。
* [JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS](http://www.stroustrup.com/JSF-AV-rules.pdf).
  文档编号 2RDU00001 Rev C. December 2005.
  针对飞行控制软件。
  针对硬实时。
  这意味着它需要非常多的限制（“程序如果发生故障就会有人挂掉”）。
  例如，飞机起飞后禁止进行任何自由存储的分配和回收（禁止内存溢出并禁止发生碎片化）。
  禁止使用异常（因为没有可用工具可以保证异常能够在固定的短时间段内被处理）。
  所使用的程序库必须是已被证明可以用于关键任务应用的。
  它和这个指导方针集合的相似性并不让人惊讶，因为 Bjarne Stroustrup 正是 JSF++ 的作者之一。
  建议采纳，但请注意其非常特定的关注领域。
* [MISRA C++ 2008: Guidelines for the use of the C++ language in critical systems] (https://www.misra.org.uk/Buyonline/tabid/58/Default.aspx)。
* [Using C++ in Mozilla Code](https://firefox-source-docs.mozilla.org/code-quality/coding-style/using_cxx_in_firefox_code.html).
  如其名称所示，它关注于跨许多（老）编译器的兼容性。
  因此，它是很具有限制性的。
* [Geosoft.no: C++ Programming Style Guidelines](http://geosoft.no/development/cppstyle.html).
  ???.
* [Possibility.com: C++ Coding Standard](http://www.possibility.com/Cpp/CppCodingStandard.html).
  ???.
* [SEI CERT: Secure C++ Coding Standard](https://wiki.sei.cmu.edu/confluence/x/Wnw-BQ).
  针对安全关键代码所编写的一组非常好的规则（还带有示例和原理说明）。
  它们的许多规则都广泛适用。
* [High Integrity C++ Coding Standard](http://www.codingstandard.com/).
* [llvm](http://llvm.org/docs/CodingStandards.html).
  有些简略，基于 C++14，而且是（有理由地）针对其应用领域的。
* ???

## <a id="ss-books"></a>RF.books: 带有编码指导方针的书籍

* [Meyers96](#meyers96) Scott Meyers: *More Effective C++*. Addison-Wesley 1996.
* [Meyers97](#meyers97) Scott Meyers: *Effective C++, Second Edition*. Addison-Wesley 1997.
* [Meyers01](#meyers01) Scott Meyers: *Effective STL*. Addison-Wesley 2001.
* [Meyers05](#meyers05) Scott Meyers: *Effective C++, Third Edition*. Addison-Wesley 2005.
* [Meyers15](#meyers15) Scott Meyers: *Effective Modern C++*. O'Reilly 2015.
* [SuttAlex05](#suttalex05) Sutter and Alexandrescu: *C++ Coding Standards*. Addison-Wesley 2005. 与其说是一组规则，不如说是一组元规则。前 C++11 时代。
* [Stroustrup05](#stroustrup05) Bjarne Stroustrup: [A rationale for semantically enhanced library languages](http://www.stroustrup.com/SELLrationale.pdf).
  LCSD05. October 2005.
* [Stroustrup14](#stroustrup05) Stroustrup: [A Tour of C++](http://www.stroustrup.com/Tour.html).
  Addison Wesley 2014.
  每章的结尾都有一个包含一组建议的忠告部分。
* [Stroustrup13](#stroustrup13) Stroustrup: [The C++ Programming Language (4th Edition)](http://www.stroustrup.com/4th.html).
  Addison Wesley 2013.
  每章的结尾都有一个包含一组建议的忠告部分。
* Stroustrup: [Style Guide](http://www.stroustrup.com/Programming/PPP-style.pdf)
  for [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html).
  大多是一些低级的命名和代码布局规则。
  主要作为教学工具。

## <a id="ss-cplusplus"></a>RF.C++: C++ 编程 (C++11/C++14)

* [TC++PL4](http://www.stroustrup.com/4th.html):
  面向有经验的程序员的，对 C++ 语言和标准库的全面彻底的描述。
* [Tour++](http://www.stroustrup.com/Tour.html):
  面向有经验的程序员的，对 C++ 语言和标准库的简介。
* [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html):
  面向初学者和新手们的教材。

## <a id="ss-web"></a>RF.web: 网站

* [isocpp.org](https://isocpp.org)
* [Bjarne Stroustrup 的个人主页](http://www.stroustrup.com)
* [WG21](http://www.open-std.org/jtc1/sc22/wg21/)
* [Boost](http://www.boost.org)<a id="boost"></a>
* [Adobe open source](https://opensource.adobe.com/)
* [Poco libraries](http://pocoproject.org/)
* Sutter's Mill?
* ???

## <a id="ss-vid"></a>RS.video: 有关“当代 C++”的视频

* Bjarne Stroustrup: [C++11?Style](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style). 2012.
* Bjarne Stroustrup: [The Essence of C++: With Examples in C++84, C++98, C++11, and?C++14](http://channel9.msdn.com/Events/GoingNative/2013/Opening-Keynote-Bjarne-Stroustrup). 2013
* [CppCon '14](https://isocpp.org/blog/2014/11/cppcon-videos-c9) 的全部演讲
* Bjarne Stroustrup: [The essence of C++](https://www.youtube.com/watch?v=86xWVb4XIyE) 在爱丁堡大学。2014
* Bjarne Stroustrup: [The Evolution of C++ Past, Present and Future](https://www.youtube.com/watch?v=_wzc7a3McOs). CppCon 2016 keynote.
* Bjarne Stroustrup: [Make Simple Tasks Simple!](https://www.youtube.com/watch?v=nesCaocNjtQ). CppCon 2014 keynote.
* Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/watch?v=1OEu9C51K2A). CppCon 2015 keynote about the Core Guidelines.
* Herb Sutter: [Writing Good C++14... By Default](https://www.youtube.com/watch?v=hEx5DNLWGgA). CppCon 2015 keynote about the Core Guidelines.
* CppCon 15
* ??? C++ Next
* ??? Meting C++
* ??? more ???

## <a id="ss-man"></a>RF.man: 手册

* ISO C++ Standard C++11.
* ISO C++ Standard C++14.
* [ISO C++ Standard C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf). 委员会草案。
* [Palo Alto "Concepts" TR](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf).
* [ISO C++ Concepts TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf).
* [WG21 Ranges report](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf). 草案。


## <a id="ss-core"></a>RF.core: 核心指导方针相关材料

这个部分包含一些用于展示核心指导方针及其背后的思想的有用材料：

* [Our documents directory](https://github.com/isocpp/CppCoreGuidelines/tree/master/docs)
* Stroustrup, Sutter, and Dos Reis: [A brief introduction to C++’s model for type- and resource-safety](http://www.stroustrup.com/resource-model.pdf). A paper with lots of examples.
* Sergey Zubkov: [a Core Guidelines talk](https://www.youtube.com/watch?v=DyLwdl_6vmU)
and here are the [slides](http://2017.cppconf.ru/talks/sergey-zubkov). In Russian. 2017.
* Neil MacIntosh: [The Guideline Support Library: One Year Later](https://www.youtube.com/watch?v=_GhNnCuaEjo). CppCon 2016.
* Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/watch?v=1OEu9C51K2A). CppCon 2015 keynote.
* Herb Sutter: [Writing Good C++14... By Default](https://www.youtube.com/watch?v=hEx5DNLWGgA). CppCon 2015 keynote.
* Peter Sommerlad: [C++ Core Guidelines - Modernize your C++ Code Base](https://www.youtube.com/watch?v=fQ926v4ZzAM). ACCU 2017.
* Bjarne Stroustrup: [No Littering!](https://www.youtube.com/watch?v=01zI9kV4h8c). Bay Area ACCU 2016.
It gives some idea of the ambition level for the Core uidelines.

CppCon 的展示的幻灯片是可以获得的（其链接，还有上传的视频）。

极大欢迎对于这个列表的贡献。

## <a id="ss-ack"></a>鸣谢

感谢对规则、建议、支持信息和参考材料等等作出了各种贡献的许多人：

* Peter Juhl
* Neil MacIntosh
* Axel Naumann
* Andrew Pardoe
* Gabriel Dos Reis
* Zhuang, Jiangang (Jeff)
* Sergey Zubkov

请查看 github 的贡献者列表。

# <a id="s-profile"></a>Pro: 剖面配置

理想情况，我们应当遵循所有这些指导方针。
这样能够得到最简洁，最规范，最少易错性，而且通常是最快的代码。
不幸的是这通常是不可能的，因为我们不得不让代码适合于大型的代码库并使用一些现存的程序库。
常常是，这样的代码已经编写好几十年了，并且并不遵循这些指导方针。
我们必须以[渐次采纳](#s-modernizing)为目标。

无论采用何种渐次采纳的策略，我们都应当能够首先采用一些相关指导方针的集合来
处理某些问题的集合，遗留其他的以后处理。
当发现某些而不是全部的指导方针对于代码库有关时，以及当在某个专门化的应用领域
采用一组专门化的指导方针的集合时，会出现类似的“相关指导方针”的主意。
我们称这样的相关指导方针的集合为一个“剖面配置”。
我们对这种指导方针集合的目标是其内聚性，它们一起可以有助于我们达成某个特定的目标，如“消除范围错误”
或“静态类型安全性”。
每个剖面配置都被设计用于消除一个类别的错误。
而“随意”实施一些独立的规则，相对于提供确定的改善来说，更像是对代码库的破坏。

“剖面配置”是确定的并且可移植实施的规则（限制）子集，它们是专门设计以达成某项特定保证的。
“确定性”意味着它们仅需要进行局部分析，并且可以在一台计算机中进行实现（虽然并不比如此）。
“可移植实施性”表明它们和语言规则相似，因而程序员们可以期望不同实施工具对于相同的代码给出相同的答案。

编写成在这样的语言剖面配置下仍免于警告的代码，可以认为是遵循这个剖面配置的。
而遵从的代码则可以认为对于该剖面配置的目标安全属性来说是安全的。
遵从的代码不会成为这种性质的错误的根本原因，
虽然程序中可能从其他的代码引入这样的错误。
剖面配置还可能会引入一些额外的库类型，以简化遵从性并鼓励编写正确的代码。

剖面配置概览：

* [Pro.type: 类型安全性](#ss-type)
* [Pro.bounds: 边界安全性](#ss-bounds)
* [Pro.lifetime: 生存期安全性](#ss-lifetime)

未来，我们打算定义更多的剖面配置，并向现有剖面配置中添加更多的检查。
候选者有：

* 窄化算术提升和转换（可能会成为一个单独的安全算术剖面配置的一部分）
* 从负浮点数向无符号整型类型进行算术强制转换（同上）
* 经选择的未定义行为：从 Gabriel Dos Reis 为 WG21 研究小组开发的 UB 列表入手
* 经选择的未指明行为：处理可移植性问题。
* `const` 违反：大多数情况已经由编译器完成，但我们可以捕捉不适当的强制转换和 `const` 的不当使用。

剖面配置的开启是由实现所定义的；典型情况下，是在分析工具之中进行的设置。

要抑制对某个剖面配置检查，可以在语言构造上放一个 `suppress` 标注。例如：

    [[suppress(bounds)]] char* raw_find(char* p, int n, char x)    // 在 p[0]..p[n - 1] 中寻找 x
    {
        // ...
    }

这样 `raw_find()` 就可以在内存中到处爬了。
显然，进行抑制应当是非常罕见的。

## <a id="ss-type"></a>Pro.safety: 类型安全性剖面配置

这个剖面配置将能够简化正确使用类型的代码编写，并避免因疏忽产生类型双关。
它是关注于移除各种主要的类型违例的因素（包括对强制转换和联合的不安全使用）而达成这点的。

针对本部分的目的而言，
类型安全性被定义为这样的性质：对变量的使用不会不遵守其所定义的类型的规则。
通过类型 `T` 所访问的内存，不应该是某个实际上包含了无关类型 `U` 的对象的有效内存。
注意，当和[边界安全性](#ss-bounds)、[生存期安全性](#ss-lifetime)组合起来时，安全性才是完整的。

这个剖面配置的实现应当在源代码中识别出下列模式，将之作为不符合并给出诊断信息。

类型安全性剖面配置概览：

* <a id="pro-type-avoidcasts"></a>Type.1: [避免强制转换](#res-casts)：

  1. <a id="pro-type-reinterpretcast"></a>请勿使用 `reinterpret_cast`；此为[避免强制转换](#res-casts)和[优先使用具名的强制转换](#res-casts-named)的严格的版本。
  2. <a id="pro-type-arithmeticcast"></a>请勿在算术类型上使用 `static_cast`；此为[避免强制转换](#res-casts)和[优先使用具名的强制转换](#res-casts-named)的严格的版本。
  3. <a id="pro-type-identitycast"></a>当源指针类型和目标类型相同时，请勿进行指针强制转换；此为[避免强制转换](#res-casts)的严格的版本。
  4. <a id="pro-type-implicitpointercast"></a>当指针转换可以隐式转换时，请勿使用指针强制转换；此为[避免强制转换](#res-casts)的严格的版本。
* <a id="pro-type-downcast"></a>Type.2: 请勿使用 `static_cast` 进行向下强制转换：
[代之以使用 `dynamic_cast`](#rh-dynamic_cast)。
* <a id="pro-type-constcast"></a>Type.3: 请勿使用 `const_cast` 强制掉 `const`（亦即不要这样做）：
[不要强制掉 `const`](#res-casts-const)。
* <a id="pro-type-cstylecast"></a>Type.4: 请勿使用  C 风格的强制转换 `(T)expression` 和函数式风格强制转换 `T(expression)`：
优先使用[构造语法](#res-construct)，[具名的强制转换](#res-casts-named)，或 `T{expression}`。
* <a id="pro-type-init"></a>Type.5: 请勿在初始化之前使用变量：
[坚持进行初始化](#res-always)。
* <a id="pro-type-memberinit"></a>Type.6: 坚持初始化成员变量：
[坚持进行初始化](#res-always)，
可以采用[默认构造函数](#rc-default0)或者
[默认成员初始化式](#rc-in-class-initializer)。
* <a id="pro-type-union"></a>Type.7: 避免裸 union：
[代之以使用 `variant`](#ru-naked)。
* <a id="pro-type-varargs"></a>Type.8: 避免 varargs：
[不要使用 `va_arg` 参数](#f-varargs)。

##### 影响

在类型安全性剖面配置下，你可以相信每个操作都将在有效的对象上进行。
可能抛出异常以报告无法（在编译时）被静态地检测到的错误。
要注意的是，这种类型安全性仅当我们同样具有[边界安全性](#ss-bounds)和[生存期安全性](#ss-lifetime)时才是完整的。
而没有这些保证的话，一个内存区域可能以与其所存储的单个或多个对象，或对象的一部分无关的方式被访问。


## <a id="ss-bounds"></a>Pro.bounds: 边界安全性剖面配置

这个剖面配置将能简化对于在分配的内存块的边界之中进行操作的编码工作。
它是通过关注于移除边界违例的主要根源——即指针算术和数组索引——而做到这点的。
这个剖面配置的核心功能之一就是限制指针只能指向单个对象而不是数组。

我们将边界安全性定义为这样一种性质：程序不通过一个对象来对分配给这个对象的内存范围之外的内存进行访问。
仅当边界安全性与[类型安全性](#ss-type)和[生存期安全性](#ss-lifetime)组合起来时才是完整的，
它们还会包含其他允许发生边界违例的不安全操作。

边界安全性剖面配置概览：

* <a id="pro-bounds-arithmetic"></a>Bounds.1: 请勿使用指针算术。请使用 `span` 代替：
[（仅）传递单个对象的指针](#ri-array)，并[保持指针算术的简单性](#res-ptr)。
* <a id="pro-bounds-arrayindex"></a>Bounds.2: 仅使用常量表达式对数组进行索引操作：
[（仅）传递单个对象的指针](#ri-array)，并[保持指针算术的简单性](#res-ptr)。
* <a id="pro-bounds-decay"></a>Bounds.3: 避免数组向指针的退化：
[（仅）传递单个对象的指针](#ri-array)，并[保持指针算术的简单性](#res-ptr)。
* <a id="pro-bounds-stdlib"></a>Bounds.4: 请勿使用不进行边界检查的标准库函数和类型：
[以类型安全的方式使用标准库](#rsl-bounds)

##### 影响

边界安全性意味着，当访问对象（尤其是数组）时不会越过对象的内存分配范围。
这消除了一大类的隐伏且难于发现的错误，包括（不）著名的“缓冲区溢出”错误。
这避免了安全漏洞，以及（当越界写入时发生）内存损坏错误的大量来源。
即使越界访问“只是读取操作”，它也可能导致不变式的违反（当所访问的不是预期的类型时）
和“神秘的值”。


## <a id="ss-lifetime"></a>Pro.lifetime: 生存期安全性剖面配置

通过已经不指向任何东西的指针进行访问，是错误的一种主要来源，
而且在许多传统的 C 或 C++ 风格的编程中这很难避免。
例如，指针可能未初始化，值为 `nullptr`，指向越过指针范围，或者指向已删除的对象。

[参见此处的设计说明书的当前版本](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf)

生存期安全性剖面配置概览：

* <a id="pro-lifetime-invalid-deref"></a>Lifetime.1: 不要解引用无效指针：
[检测或避免](#res-deref)。

##### 影响

一旦强制实施了编码风格规则，静态分析，以及程序库支持的组合方案之后，本剖面配置将能

* 消除 C++ 中的恶劣错误的一种主要来源
* 消除潜在安全漏洞的一种主要来源
* 通过消除多余的“偏执”检查而改善性能
* 提升代码正确性的信心
* 通过强制遵循一种关键的 C++ 语言规则而避免未定义的行为


# <a id="s-gsl"></a>GSL: 指导方针支持库

GSL 是一个小型的程序库，其中的设施被设计用于支持本指导方针。
不使用这些设施的话，这些指导方针不得不变得对语言细节过于限制。

核心指导方针支持库是定义在 `gsl` 命名空间中的，其中的名字可能是对标准库和其他著名程序库的名字的别名。通过 `gsl` 命名空间进行的（编译期）间接，使我们可以进行试验，以及对这些支持设施提供局部变体。

GSL 只有头文件，可以在 [GSL: 指导方针支持库](https://github.com/Microsoft/GSL)找到。
支持库中的设施被设计为极为轻量化（零开销），它们相比于传统方案并不会带来任何开销。
当需要时，它们还可以用其他功能“工具化”（比如一些检查）来帮助进行诸如调试等任务。

各指导方针中，除了使用 GSL 中的类型之外，还使用了标准程序库（如 C++17）中的类型。
例如，我们假定有一个 `variant` 类型，但它当前尚未在 GSL 中。
总之，请使用[通过表决进入 C++17 的版本](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html)。

由于诸如当前 C++ 版本的限制等技术原因，您所使用的程序库中可能不支持下面列出的某些 GSL 类型。
请查阅您的 GSL 文档以获得更多信息。

对于以下的每个 GSL 类型，我们都为该类型给出了不变式。只要用户代码仅使用类型所提供的成员或自由函数（就是说，用户代码不会以违反任何其他指南规则的方式，绕过类型的接口来改动对象的值或位），该不变式均有效。

GSL 组件概览：

* [GSL.view: 视图](#ss-views)
* [GSL.owner](#ss-ownership)
* [GSL.assert: 断言](#ss-assertions)
* [GSL.util: 工具](#ss-utilities)
* [GSL.concept: 概念](#ss-gsl-concepts)

我们计划提供一个“ISO C++ 标准风格的”半正式的 GSL 规范。

我们依赖于 ISO C++ 标准库，并希望 GSL 的一些部分能够被吸收到标准库之中。

## <a id="ss-views"></a>GSL.view: 视图

这些类型使用户可以区分带有和没有所有权的指针，并区分指向单个对象的指针和指向序列的第一个元素的指针。

“视图”都不是所有者。

引用都不是所有者（参见 [R.4](#rr-ref)）。注意：有许多机会能让引用存活超过其所指代的对象，如按引用返回局部变量，持有 vector 的某个元素的引用然后进行 `push_back`，绑定到  `std::max(x, y + 1)`，等等。生存期安全性剖面配置的目标就是处理这些事情，但即便如此 `owner<T&>` 也没有意义且不建议使用。

它们的名字基本上遵循 ISO 标准库风格（小写字母和下划线）：

* `T*`      // `T*` 不是所有者，可能为 null；假定为指向单个元素。
* `T&`      // `T&` 不是所有者，不可能为“null 引用”；引用总是绑定到对象上。

“原生指针”写法（如 `int*`）假定为具有其最常见的含义；亦即指向一个对象的指针，但并不拥有它。
所有者应当被转换为资源包装（如 `unique_ptr` 或 `vector<T>`），或标为 `owner<T*>`。

* `owner<T*>`   // `T*`，拥有所指向/指代的对象；可能为 `nullptr`。

`owner` 用于对代码中有所有权的指针进行标记，它们无法更改为使用适当的资源包装。
其原因可能包括：

* 转换的成本。
* 需要为某个 ABI 使用指针。
* 这个指针时某种资源包装的实现的一部分。

`owner<T>` 和 `T` 的某种资源包装的区别在于它仍然需要明确进行 `delete`。

`owner<T>` 假定为指代自由存储（堆）上的某个对象。

当某个东西不应当为 `nullptr` 时，可以这样做：

* `not_null<T>`   // `T` 通常是某个指针类型（例如 `not_null<int*>` 和 `not_null<owner<Foo*>>`），且不能为 `nullptr`。
  `T` 可以是 `==nullptr` 有意义的任何类型。

* `span<T>`       // `[p:p+n)`，构造函数接受 `{p, q}` 和 `{p, n}`；`T` 为指针类型
* `span_p<T>`     // `{p, predicate}` `[p:q)`，其中 `q` 为首个使 `predicate(*p)` 为真的元素

`span<T>` 指代零或更多可改动的 `T`，除非 `T` 为 `const` 类型。对 `span` 元素的所有访问，尤其是通过 `operator[]` 进行的访问，默认保证进行边界检查。

> 注：有提案将 GSL 的 `span`（起初叫做 `array_view`）加入 C++ 标准库且已被采纳（名字和接口有改动），唯一不同是 `std::span` 不提供边界检查保证。因此，GSL 修改了 `span` 的名字和接口以跟踪 `std::span`，并应当与 `std::span` 完全相同，而其仅有差别应当为，GSL 的 `span` 默认是完全边界安全的。如果边界检查影响其接口，那么应当通过 ISO C++ 委员会带回改动的提案，以保持 `gsl::span` 和 `std::span` 接口兼容。如果 `std::span` 未来的演化添加了边界检查，则 `gsl::span` 即可移除。

“指针算术”最好在 `span` 之内进行。
指向多个 `char` 但并非 C 风格字符串的 `char*`（比如指向某个输入缓冲区的指针）应当表示为一个 `span`。

* `zstring`    // `char*`，假定为 C 风格字符串；亦即以零结尾的 `char` 的序列或者是 `nullptr`
* `czstring`   // `const char*`，假定为 C 风格字符串；亦即以零结尾的 `const` `char` 的序列或者是 `nullptr`

逻辑上来说，最后两种别名是没有必要的，但我们并不总是依照逻辑的，它们可以在指向单个 `char` 的指针和指向 C 风格字符串的指针之间明确地进行区分。
并未假定为零结尾的字符序列应当是 `span<char>`，或当因 ABI 问题而不可能时是 `char*`，而不是 `zstring`。


对于不能为 `nullptr` 的 C 风格字符串，应使用 `not_null<zstring>`。 ??? 我们需要为 `not_null<zstring>` 命名吗？还是说它的难看是有用的？

## <a id="ss-ownership"></a>GSL.owner: 所有权指针

* `unique_ptr<T>`     // 唯一所有权：`std::unique_ptr<T>`
* `shared_ptr<T>`     // 共享所有权：`std::shared_ptr<T>`（引用计数指针）
* `stack_array<T>`    // 栈分配数组。元素的数量在构造时确定并固定下来。其元素可改变，除非 `T` 为 `const` 类型。
* `dyn_array<T>`      // ??? 有必要吗 ??? 堆分配数组。元素的数量在构造时确定并固定下来。
  其元素可改变，除非 `T` 为 `const` 类型。基本上这是一个进行分配并拥有其元素的 `span`。

## <a id="ss-assertions"></a>GSL.assert: 断言

* `Expects`     // 前条件断言。当前放置于函数体内。今后应当移动到声明中。
                // `Expects(p)` 当不满足 `p == true` 时会终止程序
                // `Expects` 处于一组选项的控制之下（强制，错误消息，对终止程序的替代）
* `Ensures`     // 后条件断言。当前放置于函数体内。今后应当移动到声明中。

现在这些断言还是宏（天呐！）而且必须（只）被用在函数定义式之内。
等待标准委员会对于契约和断言语法的确定。
参见使用属性语法的[契约提案](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)，
比如说，`Expects(p)` 将变为 `[[expects: p]]`。

## <a id="ss-utilities"></a>GSL.util: 工具

* `finally`        // `finally(f)` 创建一个 `final_action{f}`，其析构函数将执行 `f`
* `narrow_cast`    // `narrow_cast<T>(x)` 就是 `static_cast<T>(x)`
* `narrow`         // `narrow<T>(x)` 在满足无符号提升下的 `static_cast<T>(x) == x` 时为 `static_cast<T>(x)`，否则抛出 `narrowing_error`（例如，`narrow<unsigned>(-42)` 会抛出异常）
* `[[implicit]]`   // 放在单参数构造函数上的“记号”，以明确说明它们并非显式构造函数。
* `move_owner`     // `p = move_owner(q)` 含义为 `p = q` 但 ???
* `joining_thread` // RAII 风格版本的进行联结的 `std::thread`
* `index`          // 用于进行所有的容器和数组索引的类型（当前是 `ptrdiff_t` 的别名）

## <a id="ss-gsl-concepts"></a>GSL.concept: 概念

这些概念（类型谓词）借用于
Andrew Sutton 的 Origin 程序库，
Range 提案，
以及 ISO WG21 的 Palo Alto TR。
其中许多都与已在 C++20 中成为 ISO C++ 标准的概念十分相似。

* `String`
* `Number`
* `Boolean`
* `Range`              // C++20 中为 `std::ranges::range`
* `Sortable`           // C++20 中为 `std::sortable`
* `EqualityComparable` // C++20 中为 `std::equality_comparable`
* `Convertible`        // C++20 中为 `std::convertible_to`
* `Common`             // C++20 中为 `std::common_with`
* `Integral`           // C++20 中为 `std::integral`
* `SignedIntegral`     // C++20 中为 `std::signed_integral`
* `SemiRegular`        // C++20 中为 `std::semiregular`
* `Regular`            // C++20 中为 `std::regular`
* `TotallyOrdered`     // C++20 中为 `std::totally_ordered`
* `Function`           // C++20 中为 `std::invocable`
* `RegularFunction`    // C++20 中为 `std::regular_invocable`
* `Predicate`          // C++20 中为 `std::predicate`
* `Relation`           // C++20 中为 `std::relation`
* ...

### <a id="ss-gsl-smartptrconcepts"></a>GSL.ptr: 智能指针概念

* `Pointer`  // 带有 `*`，`->`，`==`，以及默认构造的类型（默认构造被假定为设值为唯一的“null”值）
* `Unique_pointer`  // 符合 `Pointer` 的类型，可移动但不可复制
* `Shared_pointer`   // 符合 `Pointer` 的类型，可复制

# <a id="s-naming"></a>NL: 命名和代码布局建议

维持一致的命名和代码布局是很有用的。
即便不为其他原因，也可以减少“我的代码风格比你的好”这类的纷争。
然而，人们使用许多许多的不同代码风格，并狂热地坚持它们（的优缺点）。
而且，大多数的现实项目都包含来自于许多来源的代码，因而通常不可能把所有的代码都标准化为某个单一的代码风格。
经过许多的用户请求给予指导后，我们给出一组规则，当你没有更好的选择时可以使用它们，但真正的目标在于一致性，而不是任何一组特定的规则。
IDE 和工具可以提供辅助（当然也可能造成妨碍）。

命名和代码布局规则：

* [NL.1: 不要在代码注释中说明可以由代码来清晰表达的东西](#rl-comments)
* [NL.2: 在代码注释中说明意图](#rl-comments-intent)
* [NL.3: 保持代码注释简明干脆](#rl-comments-crisp)
* [NL.4: 保持一种统一的缩进风格](#rl-indent)
* [NL.5: 避免在名字中编码类型信息](#rl-name-type)
* [NL.7: 使名字的长度大约正比于其作用域的长度](#rl-name-length)
* [NL.8: 使用一种统一的命名风格](#rl-name)
* [NL.9: 将 `ALL_CAPS`（全大写）仅用于宏的名字](#rl-all-caps)
* [NL.10: 优先采用 `underscore_style`（下划线风格）的名字](#rl-camel)
* [NL.11: 使字面量可阅读](#rl-literals)
* [NL.15: 节制地使用空格](#rl-space)
* [NL.16: 使用一种常规的类成员声明次序](#rl-order)
* [NL.17: 使用从 K&R 衍生出的代码布局](#rl-knr)
* [NL.18: 使用 C++ 风格的声明符布局](#rl-ptr)
* [NL.19: 避免使用容易误读的名字](#rl-misread)
* [NL.20: 不要把两个语句放在同一行中](#rl-stmt)
* [NL.21: 每个声明式（仅）声明一个名字](#rl-dcl)
* [NL.25: 请勿将 `void` 用作参数类型](#rl-void)
* [NL.26: 采用符合惯例的 `const` 写法](#rl-const)
* [NL.27: 为代码文件使用后缀 `.cpp`，而对接口文件使用后缀 `.h`](#rl-file-suffix)

这些问题的大部分都是审美问题，程序员都有很强的个人倾向。
IDE 也都会提供某些默认方案和一组替代方案。
这些规则是作为缺省建议的，如果没有别的理由，请采用它们。

我们收到一些意见称命名和代码布局非常个人化和任意性，我们不应该试图为之“立法”。
我们并不是在“立法”（参见前一个段落）。
不过，我们也收到了大量的针对某些命名和代码布局约定的请求，要求当没有外来限制的时候应当采用它们。

更专门和详细的规则更加易于强制实施。

这些规则恐怕会和 [PPP Style Guide](http://www.stroustrup.com/Programming/PPP-style.pdf) 中的建议有很强的相似性，
它是为支持 Stroustrup 的 [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html) 而编制的。

### <a id="rl-comments"></a>NL.1: 不要在代码注释中说明可以由代码来清晰表达的东西

##### 理由

编译器不会读注释。
注释没有代码那么精确。
注释不会像代码那样进行一致地更新。

##### 示例，不好

    auto x = m * v1 + vv;   // 将 m 乘以 v1 并将其结果加上 vv

##### 强制实施

构建一个 AI 程序来解释口语英文文字，看看它所说的是否可以用 C++ 来更好地表达。

### <a id="rl-comments-intent"></a>NL.2: 在代码注释中说明意图

##### 理由

代码表示的是做了什么，而不是想要做成什么。通常来说意图比实现能够更清晰简明地进行说明。

##### 示例

    void stable_sort(Sortable& c)
        // 对 c 根据由 < 决定的顺序进行排序，保持相等元素（由 == 定义）的
        // 原始相对顺序
    {
        // ... 相当多的不平常的代码行 ...
    }

##### 注解

如果代码注释和代码有冲突，则它们都可能是错的。

### <a id="rl-comments-crisp"></a>NL.3: 保持代码注释简明干脆

##### 理由

冗长啰嗦会拖慢理解速度，而且到处散布在代码文件里也会让代码难于阅读。

##### 注解

使用明白易懂的英文。
也许我可以流利使用丹麦语，但大多数程序员不行；我的代码的维护者也不行。
避免使用网络用语，注意你的文法，标点，以及大小写。
目标是专业性，而不是“够酷”。

##### 强制实施

不可能。

### <a id="rl-indent"></a>NL.4: 保持一种统一的缩进风格

##### 理由

可读性。避免“微妙的错误”。

##### 示例，不好

    int i;
    for (i = 0; i < max; ++i); // 可能出现的 BUG
    if (i == j)
        return i;

##### 注解

总是把 `if (...)`，`for (...)`，以及 `while (...)` 之后的语句进行缩进是一个好主意：

    if (i < 0) error("negative argument");

    if (i < 0)
        error("negative argument");

##### 强制实施

使用一种工具。

### <a id="rl-name-type"></a>NL.5: 避免在名字中编码类型信息

##### 原理

当名字反映类型而不是功能时，它将变得难于为提供其功能而改变其所使用的类型。
而且，当改变变量的类型时，使用它的代码也得修改。
最小化无意进行的转换。

##### 示例，不好

    void print_int(int i);
    void print_string(const char*);

    print_int(1);          // 重复，人工进行类型匹配
    print_string("xyzzy"); // 重复，人工进行类型匹配

##### 示例，好

    void print(int i);
    void print(string_view);    // 对任意字符串式的序列都能工作

    print(1);              // 简洁，自动类型匹配
    print("xyzzy");        // 简洁，自动类型匹配

##### 注解

带有类型编码的名字要么啰嗦要么难懂。

    printS  // 打印一个 std::string
    prints  // 打印一个 C 风格字符串
    printi  // 打印一个 int

在无类型语言中曾经采用过像匈牙利记法这样的技巧来在名字中编码类型，但在像 C++ 这样的强静态类型语言中，这通常是不必要而且实际上是有害的，因为这些标注会过时（这些累赘和注释类似，而且和它们一样会烂掉），而且它们干扰了语言的恰当用法（应当代之以使用相同的名字和重载决议）。

##### 注解

一些代码风格会使用非常一般性的（而不是特定于类型的）前缀来代表变量的一般用法。

    auto p = new User();
    auto p = make_unique<User>();
    // 注："p" 并非是说“User 类型的原始指针”，
    //     而只是一般性的“这是一次间接访问”

    auto cntHits = calc_total_of_hits(/*...*/);
    // 注："cnt" 并非用于编码某个类型，
    //     而只是一般性的“这是某种东西的一个计数”

这样做是没有害处的，且并不属于本条指导方针，因为其并未编码类型信息。

##### 注解

一些代码风格会对成员和局部变量，以及全局变量之间进行区分。

    struct S {
        int m_;
        S(int m) : m_{abs(m)} { }
    };

这样做是没有害处的，且并不属于本条指导方针，因为其并未编码类型信息。

##### 注解

像 C++ 这样，一些代码风格对类型和非类型之间进行区分。
例如，对类型名字首字母大写，而函数和变量名字则不这样做。

    typename<typename T>
    class HashTable {   // 将 string 映射为 T
        // ...
    };

    HashTable<int> index;

这样做是没有害处的，且并不属于本条指导方针，因为其并未编码类型信息。

### <a id="rl-name-length"></a>NL.7: 使名字的长度大约正比于其作用域的长度

**原理**: 作用域越大，搞混的机会和意外的名字冲突的机会就越大。

##### 示例

    double sqrt(double x);   // 返回 x 的平方根；x 必须是非负数

    int length(const char* p);  // 返回零结尾的 C 风格字符串的字符数量

    int length_of_string(const char zero_terminated_array_of_char[])    // 不好: 啰嗦

    int g;      // 不好: 全局变量具有密秘的名字

    int open;   // 不好: 全局变量使用短小且常用的名字

为指针使用 `p`，以及为浮点变量使用 `x` 是符合惯例的，在受限的作用域中不会造成混乱。

##### 强制实施

???

### <a id="rl-name"></a>NL.8: 使用一种统一的命名风格

**原理**: 命名和命名风格的一致性会提高可读性。

##### 注解

命名风格有好多，当你使用多个程序库时，你无法遵循所有它们不同的命名约定。
应当选用一种“自有风格”，但保持“导入”的程序为其原有风格不变。

##### 示例

ISO 标准仅使用小写字母和数字，并用下划线进行词的连接。

* `int`
* `vector`
* `my_map`

避免使用双下划线 `__`。

##### 示例

[Stroustrup](http://www.stroustrup.com/Programming/PPP-style.pdf)：
采用 ISO 标准，但在自己的类型和概念上采用大写字母：

* `int`
* `vector`
* `My_map`

##### 示例

CamelCase：多词标识符的每个词首字母大写：

* `int`
* `vector`
* `MyMap`
* `myMap`

一些命名约定会将首字母大写，而另一些不会。

##### 注解

应当试图在对缩略词的使用和标识符长度上保持一致风格。

    int mtbf {12};
    int mean_time_between_failures {12}; // 你自己决定

##### 强制实施

除使用具有不同命名约定的程序库之外应当是可能做到的。

### <a id="rl-all-caps"></a>NL.9: 将 `ALL_CAPS`（全大写）仅用于宏的名字

##### 理由

避免在宏和遵循作用域和类型规则的名字之间造成混乱。

##### 示例

    void f()
    {
        const int SIZE{1000};  // 不好，应代之以 'size'
        int v[SIZE];
    }

##### 注解

这条规则适用于非宏的符号常量：

    enum bad { BAD, WORSE, HORRIBLE }; // 不好

##### 强制实施

* 对带有小写字母的宏进行标记
* 对 `ALL_CAPS` 非宏名字进行标记

### <a id="rl-camel"></a>NL.10: 优先采用 `underscore_style`（下划线风格）的名字

##### 理由

用下划线来分隔名字的各部分就是 C 和 C++ 的原始风格，并被用于 C++ 标准库中。

##### 注解

这条规则仅作为当你有选择权时的缺省方案。
通常你是没有什么选择权的，而只能遵循某个已经设立的风格以维持[一致性](#rl-name)。
对一致性的需要优先于个人喜好。

这个推荐适用于[当你没有约束条件或者没有更好的想法时](#s-naming)的情况。
经过很多要求给予指导后，添加这个规则。

##### 示例

[Stroustrup](http://www.stroustrup.com/Programming/PPP-style.pdf)：
采用 ISO 标准，但在自己的类型和概念上采用大写字母：

* `int`
* `vector`
* `My_map`

##### 强制实施

不可能。

### <a id="rl-literals"></a>NL.11: 使字面量可阅读

##### 理由

可读性。

##### 示例

用数字分隔符来避免长串的数字

    auto c = 299'792'458; // m/s2
    auto q2 = 0b0000'1111'0000'0000;
    auto ss_number = 123'456'7890;

##### 示例

需要清晰性时使用字面量后缀

    auto hello = "Hello!"s; // std::string
    auto world = "world";   // C 风格字符串
    auto interval = 100ms;  // 使用 <chrono>

##### 注解

不能在代码中到处当做[“魔法常量”](#res-magic)一样乱用字面量，
但当定义它们时使它们更可读仍是个好主意。
在较长的整数串中很容易出现拼写错误。

##### 强制实施

标记长数字串。麻烦的是“长”的定义；也许应当是 7。

### <a id="rl-space"></a>NL.15: 节制地使用空格

##### 理由

太多的空格会让文本更大更分散。

##### 示例，不好

    #include < map >

    int main(int argc, char * argv [ ])
    {
        // ...
    }

##### 示例

    #include <map>

    int main(int argc, char* argv[])
    {
        // ...
    }

##### 注解

一些 IDE 有其自己的看法，并会添加分散的空格。

这个推荐适用于[当你没有约束条件或者没有更好的想法时](#s-naming)的情况。
经过很多要求给予指导后，添加这个规则。

##### 注解

我们将恰当放置的空白评价为能够明显有助于可读性。但请勿过度。

### <a id="rl-order"></a>NL.16: 使用一种常规的类成员声明次序

##### 理由

一种常规的成员次序会提高可读性。

以如下次序声明类

* 类型：类，枚举，别名（`using`）
* 构造函数，赋值，析构函数
* 函数
* 数据

采用先是 `public`，然后是 `protected`，之后是 `private` 的次序。

这个推荐适用于[当你没有约束条件或者没有更好的想法时](#s-naming)的情况。
经过很多要求给予指导后，添加这个规则。

##### 示例

    class X {
    public:
        // 接口
    protected:
        // 供派生类实现使用的不带检查的函数
    private:
        // 实现细节
    };

##### 示例

有时候，成员的默认顺序，与将公开接口从实现细节中分离出来的需求之间有冲突。
这种情况下，私有类型和函数可以和私有数据放在一起。

    class X {
    public:
        // 接口
    protected:
        // 供派生类实现使用的不带检查的函数
    private:
        // 实现细节（类型，函数和数据）
    };

##### 示例，不好

避免让具有某一种访问（如 `public`）的多个声明块被具有不同访问（如 `private`）的其他声明块分隔开。

    class X {
    public:
        void f();
    public:
        int g();
        // ...
    };

用宏来声明成员组的做法通常会导致违反所有的次序规则。
不过，宏的使用掩盖了其所表达的东西。

##### 强制实施

对背离上述建议次序的代码进行标记。将会有大量的老代码不符合这条规则。

### <a id="rl-knr"></a>NL.17: 使用从 K&R 衍生出的代码布局

##### 理由

这正是 C 和 C++ 的原始代码布局。它很好地保持了纵向空间。它对不同语言构造（如函数和类）进行了很好的区分。

##### 注解

在 C++ 的语境中，这种风格通常被称为“Stroustrup”。

这个推荐适用于[当你没有约束条件或者没有更好的想法时](#s-naming)的情况。
经过很多要求给予指导后，添加这个规则。

##### 示例

    struct Cable {
        int x;
        // ...
    };

    double foo(int x)
    {
        if (0 < x) {
            // ...
        }

        switch (x) {
        case 0:
            // ...
            break;
        case amazing:
            // ...
            break;
        default:
            // ...
            break;
        }

        if (0 < x)
            ++x;

        if (x < 0)
            something();
        else
            something_else();

        return some_value;
    }

注意 `if` 和 `(` 之间有一个空格

##### 注解

每个语句，`if` 的分支，以及 `for` 的代码体都使用单独的代码行。

##### 注解

`class` 和 `struct` 的 `{` *并不*在单独的代码行上，但函数的 `{` 在单独的代码行上。

##### 注解

对你自定义的类型的名字进行首字母大写，以将其与标准库类型相区分。

##### 注解

不要对函数名大写。

##### 强制实施

如果想要强制实施的话，请使用某个 IDE 进行格式化。

### <a id="rl-ptr"></a>NL.18: 使用 C++ 风格的声明符布局

##### 理由

C 风格的布局强调其在表达式中的用法和文法，而 C++ 风格强调的是类型。
对表达式用法的说辞并不适用于引用。

##### 示例

    T& operator[](size_t);   // OK
    T &operator[](size_t);   // 奇怪
    T & operator[](size_t);   // 不确定

##### 注解

这个推荐适用于[当你没有约束条件或者没有更好的想法时](#s-naming)的情况。
经过很多要求给予指导后，添加这个规则。

##### 强制实施

由于历史原因而不可能。


### <a id="rl-misread"></a>NL.19: 避免使用容易误读的名字

##### 理由

可读性。
并非每个人都有能将字符轻易区分开的屏幕和打印机。
我们很容易搞混拼写相似和略微拼错的单词。

##### 示例

    int oO01lL = 6; // 不好

    int splunk = 7;
    int splonk = 8; // 不好：splunk 和 splonk 很容易搞混

##### 强制实施

???

### <a id="rl-stmt"></a>NL.20: 不要把两个语句放在同一行中

##### 理由

可读性。
当一行里有多个语句时，相当容易忽视某个语句。

##### 示例

    int x = 7; char* p = 29;    // 请勿如此
    int x = 7; f(x);  ++x;      // 请勿如此

##### 强制实施

容易。

### <a id="rl-dcl"></a>NL.21: 每个声明式（仅）声明一个名字

##### 理由

可读性。
最小化声明符语法造成的混乱。

##### 注解

相关细节，参见 [ES.10](#res-name-one)、


### <a id="rl-void"></a>NL.25: 请勿将 `void` 用作参数类型

##### 理由

这很啰嗦，而且仅在考虑 C 兼容性是才有必要。

##### 示例

    void f(void);   // 不好

    void g();       // 好多了

##### 注解

即便是 Dennis Ritchie 自己都认为 `void f(void)` 很讨厌。
你可以反驳称，在 C 中当函数原型很少见时禁止这样的代码：

    int f();
    f(1, 2, "weird but valid C89");   // 希望 f() 被定义为 int f(a, b, c) char* c; { /* ... */ }

可能造成很大的问题，但这并不适于 21 世纪和 C++。

### <a id="rl-const"></a>NL.26: 采用符合惯例的 `const` 写法

##### 理由

更多程序员更加熟悉惯例写法。
大型代码库中的一致性。

##### 示例

    const int x = 7;    // OK
    int const y = 9;    // 不好

    const int *const p = nullptr;   // OK, 指向常量 int 的常量指针
    int const *const p = nullptr;   // 不好，指向常量 int 的常量指针

##### 注解

我们知道你可能会说“不好”的例子比标有“OK”的更符合逻辑，
但它们会让更多人搞混，尤其是那些依赖于采用了远为常用，符合惯例的 OK 风格的教学材料的新手们。

一如往常，请记住这些命名和代码布局规则的目标在于一致性，而审美则会有广泛的变化。

这个推荐适用于[当你没有约束条件或者没有更好的想法时](#s-naming)的情况。
经过很多要求给予指导后，添加这个规则。

##### 强制实施

标记用作类型的后缀的 `const`。

### <a id="rl-file-suffix"></a>NL.27: 为代码文件使用后缀 `.cpp`，而对接口文件使用后缀 `.h`

##### 理由

这是一条历史悠久的约定。
不过一致性更加重要，因此如果你的项目用了别的约定的话，应当遵守它。

##### 注解

这项约定反应了一种常见使用模式：
头文件更容易和 C 语言共享使用，并可以作为 C++ 和 C 编译，它们通常用 `.h` 后缀，
并且对于有意要和 C 共用的头文件来说，让所有头文件都使用 `.h` 而不是别的扩展名要更加容易。
另一方面，实现文件则很少会和 C 共用，通常应当和 `.c` 文件相区别，
因此一般最好为所有的 C++ 实现文件用别的扩展名（如 `.cpp`）来命名。

特定的名字 `.h` 和 `.cpp` 并不是必要的（只是作为缺省建议），其他的名字也被广泛采用。
例子包括 `.hh`，`.C`，和 `.cxx` 等。请以类似方式使用这些名字。
本文档中我们把 `.h` 和 `.cpp` 作为头文件和实现文件的简便提法，
虽然实际上的扩展名可能是不同的。

也许你的 IDE（如果你使用的话）对后缀有较强的倾向。

##### 示例

    // foo.h:
    extern int a;   // 声明
    extern void foo();

    // foo.cpp:
    int a;   // 定义
    void foo() { ++a; }

`foo.h` 提供了 `foo.cpp` 的接口。最好避免全局变量。

##### 示例，不好

    // foo.h:
    int a;   // 定义
    void foo() { ++a; }

一个程序中两次 `#include <foo.h>` 将导致因为对唯一定义规则的两次违反而出现一个连接错误。

##### 强制实施

* 对不符合约定的文件名进行标记。
* 检查 `.h` 和 `.cpp`（或等价文件）遵循下列各规则。

# <a id="s-faq"></a>FAQ: 常见问题及其回答

本节中包括了对关于这些指导方针的常见问题的回答。

### <a id="faq-aims"></a>FAQ.1: 这些指导方针的想要达成什么目标？

请参见<a href="#S-abstract">本页面开头</a>。这是一个开源项目，旨在为采用当今的 C++ 标准来编写 C++ 代码而维护的一组现代的权威指导方针。这些指导方针的设计是现代的，尽可能使机器可实施的，并且是为贡献和分支保持开放，以使各种组织机构可以便于将它们整合到其自己组织的编码指导方针之中。

### <a id="faq-announced"></a>FAQ.2: 这项工作是何时何地首次公开的？

是在 [Bjarne Stroustrup 在他为 CppCon 2015 的开场主旨演讲，“Writing Good C++14”](https://isocpp.org/blog/2015/09/stroustrup-cppcon15-keynote)。另请参见[相应的 isocpp.org 博客条目](https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines)，关于类型和内存安全性指导方针的原理请参见 [Herb Sutter 的后续 CppCon 2015 演讲，“Writing Good C++14 ... By Default”](https://isocpp.org/blog/2015/09/sutter-cppcon15-day2plenary)。

### <a id="faq-maintainers"></a>FAQ.3: 谁是这些指导方针的作者和维护者？

最初的主要作者和维护者是 Bjarne Stroustrup 和 Herb Sutter，而迄今为止的指导方针则是由来自 CERN，Microsoft，Morgan Stanley，以及许多其他组织机构的专家所贡献的。指导方针发布时，其正处于 "0.6" 状态，我们欢迎人们进行贡献。正如 Stroustrup 在其声明中所说：“我们需要帮助！”

### <a id="faq-contribute"></a>FAQ.4: 我如何进行贡献呢？

参见 [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md)。我们感激志愿者的帮助！

### <a id="faq-maintainer"></a>FAQ.5: 怎样成为一名编辑或维护者？

通过先进行大量贡献并使你的贡献被认可具有一致的质量。参见 [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md)。我们感激志愿者的帮助！

### <a id="faq-iso"></a>FAQ.6: 这些指导方针被 ISO C++ 标准委员会采纳了吗？它们是否代表委员会的一致意见？

不是这样。这些指导方针不在标准之内。它们是为标准服务的，而当前维护的指导方针是为了更有效地使用当前的标准 C++的。我们的目标是使其与委员会所设计的标准保持同步。

### <a id="faq-isocpp"></a>FAQ.7: 既然这些指导方针并不是委员会所采纳的，它们为何在 `github.com/isocpp` 之下呢？

因为 `isocpp` 是标准 C++ 基金会；而标准委员会的仓库则处于 [github.com/*cplusplus*](https://github.com/cplusplus) 之下。我们需要一个中立组织来持有版权和许可以明确其并不是由某个人或供应商所控制的。这个自然实体就是基金会，其设立是为了推进使用并持续更新对现代标准 C++ 的理解，以及推进标准委员会的工作。其所遵循的正是与 isocpp.org 为 [C++ FAQ](https://isocpp.org/faq) 所做的相同模式，它是有 Bjarne Stroustrup，Marshall Cline，和 Herb Sutter 所发起的工作，并以相同的方式贡献为了开放项目。

### <a id="faq-cpp98"></a>FAQ.8: 会有 C++98 版本的指导方针吗？C++11 版本呢？

不会。这些指导方针的目标是更好地使用现代标准 C++，以及假定你有一个现代的遵循标准的编译器时如何进行代码编写的。

### <a id="faq-language-extensions"></a>FAQ.9: 这些指导方针中会提出新的语言功能吗？

不会。这些指导方针的目标是更好地使用现代标准 C++，它们自我限定为仅建议使用这些功能。

### <a id="faq-markdown"></a>FAQ.10: 这些指导方针的书写使用的是哪个版本的 Markdown？

这些编码指导方针使用的是 [CommonMark](http://commonmark.org)，以及 `<a>` HTML 锚定元素。

我们正在考虑以下这些来自 [GitHub Flavored Markdown (GFM)](https://help.github.com/articles/github-flavored-markdown/) 的扩展：

* 有围栏代码块（正在讨论是否统一使用缩进还是围栏代码块）
* 表格（我们虽然还没用到，但很需要它们，这是一种 GFM 扩展）

避免使用其他 HTML 标签和其他扩展。

注意：我们还没对这种风格达成一致。

### <a id="faq-gsl"></a>FAQ.50: 什么是 GSL（指导方针支持程序库）？

GSL 是在指导方针中所指定的类型和别名的一个小集合。当写下本文时，对它们的说明还过于松散；我们计划添加一个 WG21 风格的接口规范来确保不同实现之间保持一致，并作为一项可能的标准化提案，按常规遵循标准委员会进行采纳、改进、修订或否决。

### <a id="faq-msgsl"></a>FAQ.51: [github.com/Microsoft/GSL](https://github.com/Microsoft/GSL) 是 GSL 吗？

不是。它只是由 Microsoft 所贡献的第一个实现。我们鼓励其他供应商提供其他的实现，对该实现的分支和贡献也是被鼓励的。书写本文作为一项公开项目的一周中，已经出现了至少一个 GPLv3 的开源实现。我们计划制定一个 WG21 风格的接口规范来确保不同实现之间保持一致。

### <a id="faq-gsl-implementation"></a>FAQ.52: 为何不在指导方针之中提供一个真正的 GSL 实现呢？

我们不愿去保佑某个特定的实现，因为我们不希望让人们以为只有一个实现，而疏忽大意地扼杀了其他并行的实现。而如果在指导方针中包含一个真正实现的话，无论是谁提供了它都会变得过于有影响力。我们更倾向于采用委员会的更具长期性的方案，即指定其接口而不是实现。但同时我们也需要至少存在一个实现；希望可以有很多。

### <a id="faq-boost"></a>FAQ.53: 为什么不把 GSL 类型提交给 Boost 呢？

因为我们想要立刻使用它们，也因为我们想要在一旦标准库中出现了满足其需要的类型时立刻将它们撤销掉。

### <a id="faq-gsl-iso"></a>FAQ.54: ISO C++ 标准委员会采纳了 GSL（指导方针支持程序库）吗？

没有。GSL 的存在只为提供少量标准库中还没有的类型和别名。如果委员会决定了（这些类型或者满足其需要的其他类型的）标准化的版本，就可以将它们从 GSL 中删除了。

### <a id="faq-gsl-string-view"></a>FAQ.55: 既然你是尽可能使用标准类型，为什么 GSL 的 `span<char>` 同 Library Fundamentals 1 Technical Specification 和 C++17 工作文本中的 `string_view` 不同呢？为什么不使用委员会采纳的 `string_view`？

有关 C++ 标准库的视图的分类的统一观点是，“视图（view）”意味着“只读”，而“跨距（span）”意味着“可读写”。如果你只需要一组字符的不需要保证边界检查的只读视图，并且你可以用 C++17，那就使用 C++17 的 `std::string_view`。否则，如果你需要的是不需要保证边界检查的可读写视图，并且可以用 C++20，那就用 C++20 的 `std::span<char>`。否则，就用 `gsl::span<char>`。

### <a id="faq-gsl-owner"></a>FAQ.56: `owner` 和提案的 `observer_ptr` 一样吗？

不一样。`owner` 有所有权，它是一个别名，而且适用于任何间接类型。而 `observer_ptr` 的主要意图则是明确某个*没有*所有权的指针。

### <a id="faq-gsl-stack-array"></a>FAQ.57: `stack_array` 和标准的 `array` 一样吗？

不一样。`stack_array` 保证在栈上分配。虽然 `std::array` 直接在其自身内部包含存储，但 `array` 对象可以放在包括堆在内的任何地方。

### <a id="faq-gsl-dyn-array"></a>FAQ.58: `dyn_array` 和 `vector` 或者提案的 `dynarray` 一样吗？

不一样。`dyn_array` 是不可改变大小的，是一种指代堆分配的固定大小数组的一种安全方式。与 `vector` 不同，它是为了取代数组 `new[]` 的。与委员会中提案的 `dynarray` 不同，它并不会参与编译器和语言的魔法，来在当它作为分配于栈上的对象的成员时也在栈上分配；它只不过指代一个“动态的”或基于堆的数组而已。

### <a id="faq-gsl-expects"></a>FAQ.59: `Expects` 和 `assert` 一样吗？

不一样。它是一种对于契约前条件语言支持的占位符。

### <a id="faq-gsl-ensures"></a>FAQ.60: `Ensures` 和 `assert` 一样吗？

不一样。它是一种对于契约后条件语言支持的占位符。

# <a id="s-libraries"></a>附录 A: 程序库

这个部分列出了一些推荐的程序库，并且特别推荐了其中的几个。

??? 这个对一般性指南来说合适吗？我觉得不是 ???

# <a id="s-modernizing"></a>附录 B: 代码的现代化转换

理想情况下，我们的所有代码都应当遵循全部的规则。
而实际情况则是，我们不得不对付大量的老代码：

* 那些在我们的指导方针被建立或者被了解到之前所编写的代码
* 那些依据老的或者不同的标准所编写的程序库
* 那些在“不寻常”的约束下编写的代码
* 那些我们还未来得及使其现代化的代码

如果有上百万行的新代码的话，“立刻改掉它们”的想法一般都是不现实的。
因此，我们需要一种方式能够渐进地对代码库进行现代化转换。

将老代码升级为现代风格可能是很让人却步的工作。
老代码通常即混乱（难于理解）又可以（在当前使用范围内）正确工作。
很有可能，原来的程序员并不在场，而且测试用例也不完整。
代码的混乱性显著地增大了为进行任何改动所需要的工作量和引入错误的风险。
通常，混乱的老代码的运行会有不必要的缓慢，因为它需要过期的编译器，并且无法得益于当代硬件的改进。
许多情况下，都需要某种自动进行“现代化转换”的工具支持来进行主要的升级工作。

对代码现代化转换的目的在于简化新功能的添加，简化维护工作，以及增加性能（吞吐量或延迟），和更好地利用当代的硬件能力。
而让代码“看起来更好”或“遵循现代风格”自身并不能成为改动的理由。
每一种改动都蕴含着风险，而是由过时的代码库则会蕴含一些成本（包含丢失机会带来的成本）。
成本的缩减必须超过风险。

如何做呢？

并不存在唯一的代码现代化转换的方案。
如何最好地执行，依赖于代码，更新的进度压力，开发者的背景，以及可用的工具。
下面是一些（非常一般的）想法：

* 理想情况是“对全部代码一起进行升级”。这将在最短的总时间内获得做大的好处。
  在大多数情况下，这也是不可能的。
* 我们可以对代码库以模块为单位进行转换，不过任何影响接口（尤其是 ABI）的规则，如 [使用 `span`](#ss-views)，都无法按模块来达成。
* 我们可以“自底向上”转换代码，并最先应用我们估计在给定的代码库上将会带来最大好处和最少麻烦的那些规则。
* 我们可以从关注接口开始，比如说，保证没有资源的泄漏，没有指针误用等。
  这可能会导致涉及整个代码库的一些改动，不过它们是最可能会带来巨大好处的改动。
  以后，隐藏在这些接口后面的代码可以渐进地进行现代化转换而不会影响其他的代码。

无论你选择哪种方式，都要注意，对指导方针的最高度的遵循性才会带来大多数的好处。
这些指导方针并不是一组无关规则的随机集合，并不能让你随意选取并期望取得成功。

我们衷心希望听到有关它们的使用经验，以及有关工具是如何使用的。
如果有分析工具（即便是代码变换工具）的支持的话，代码现代化转换后可以变得更快，更简单，而且更安全。

# <a id="s-discussion"></a>附录 C: 讨论

这个部分包含了对规则和规则集合的跟进材料。
尤其是，我们列出了更多的原理说明，更长的例子，以及对替代方案的探讨等。

### <a id="sd-order"></a>讨论: 以成员的声明顺序进行成员变量的定义和初始化

成员变量总是以它们在类定义中的声明顺序进行初始化，因此在构造函数初始化列表中应当以该顺序来书写它们。以别的顺序书写它们只会让代码混淆，因为它并不会以你所见到的顺序来运行，而这会导致难于发现与顺序有关的 BUG。

    class Employee {
        string email, first, last;
    public:
        Employee(const char* firstName, const char* lastName);
        // ...
    };

    Employee::Employee(const char* firstName, const char* lastName)
      : first(firstName),
        last(lastName),
        // 不好: first 和 last 还未构造
        email(first + "." + last + "@acme.com")
    {}

在这个例子中，`email` 比 `first` 和 `last` 构造得早，因为它是先声明的。这意味着其构造函数对 `first` 和 `last` 的使用过早了——不只在它们被设为所需的值之前，而完全是在它们被构造之前就使用了。

如果类定义和构造函数体是在不同文件中的话，这种由成员变量声明顺序对构造函数的正确性造成的远距离影响将更难于发现。

**参考**：

[\[Cline99\]](#cline99) §22.03-11, [\[Dewhurst03\]](#dewhurst03) §52-53, [\[Koenig97\]](#koenig97) §4, [\[Lakos96\]](#lakos96) §10.3.5, [\[Meyers97\]](#meyers97) §13, [\[Murray93\]](#murray93) §2.1.3, [\[Sutter00\]](#sutter00) §47

### <a id="sd-init"></a>讨论：使用 `=`，`{}`，和 `()` 作为初始化式

???

### <a id="sd-factory"></a>讨论: 当需要在初始化过程中使用“虚函数行为”时，使用工厂函数

如果你的设计需要从基类的构造函数或析构函数中对 `f` 或者 `g` 这样的函数向派生类进行虚函数派发的话，你其实需要的是其他技巧，比如后构造函数——一种必须由调用者调用以完成初始化过程的成员函数，它可以安全地调用 `f` 和 `g`，这是由于成员函数中的虚函数调用能够正常工作。“参考”部分中列出了一些这样的技巧。以下是一个不完整的可选项列表：

* *推卸责任：* 仅仅给出文档说明，要求用户代码在对象构造之后必须立刻调用后初始化函数。
* *惰性后初始化：* 在第一个调用的成员函数中进行。用基类中的一个布尔标记说明后初始化是否已经执行过。
* *使用虚基类语义：* 语言规则要求由最终派生类的构造函数来决定调用哪个基类构造函数；你可以利用这点。（参见[\[Taligent94\]](#taligent94)。）
* *使用工厂函数：* 以这种方式，你可以轻易确保进行对后构造函数的调用。

以下是对最后一种选项的一个例子：

    class B {
    public:
        B()
        {
            /* ... */
            f(); // 不好: C.82：不要在构造函数和析构函数中调用虚函数
            /* ... */
        }

        virtual void f() = 0;
    };

    class B {
    protected:
        class Token {};

    public:
        // 需要公开构造函数以使 make_shared 可以访问它。
        // 通过要求一个 Token 达成受保护访问等级。
        explicit B(Token) { /* ... */ }  // 创建不完全初始化的对象
        virtual void f() = 0;

        template<class T>
        static shared_ptr<T> create()    // 创建共享对象的接口
        {
            auto p = make_shared<T>(typename T::Token{});
            p->post_initialize();
            return p;
        }

    protected:
        virtual void post_initialize()   // 构造之后立即调用
            { /* ... */ f(); /* ... */ } // 好: 虚函数分派是安全的
        }
    };


    class D : public B {                 // 某个派生类
    protected:
        class Token {};

    public:
        // 需要公开构造函数以使 make_shared 可以访问它。
        // 通过要求一个 Token 达成受保护访问等级。
        explicit D(Token) : B( B::Token{} ) {}
        void f() override { /* ... */ };

    protected:
        template<class T>
        friend shared_ptr<T> B::create();
    };

    shared_ptr<D> p = D::Create<D>();    // 创建一个 D 对象

这种设计需要遵守以下纪律：

* 像 `D` 这样的派生类不能暴露可公开调用的构造函数。否则的话，`D` 的使用者就能够创建 `D` 对象而不调用 `post_initialize` 了。
* 分配被限定为使用 `operator new`。不过，`B` 可以覆盖 `new`（参见 [SuttAlex05](#suttalex05) 条款 45 和 46）。
* `D` 必须定义一个带有与 `B` 所选择的相同的参数的构造函数。不过，定义多个重载的 `create` 可以缓和这个问题；而且还可以是这些重载对参数类型进行模板化。

一旦满足了上述要求，这个设计就可以保证对于任意完全构造的 `B` 的派生类对象，都将调用 `post_initialize`。`post_initialize` 不必是虚函数；它可以随意进行虚函数调用。

总之，不存在完美的后构造技巧。最差的方式是完全回避问题而只是让调用方来人工调用后构造函数。即便是最佳方案也需要采用一种不同的对象构造语法（易于进行编译期检查）以及需要派生类的作者的协作（这无法进行编译期进行检查）。

**参考**: [\[Alexandrescu01\]](#alexandrescu01) §3, [\[Boost\]](#boost), [\[Dewhurst03\]](#dewhurst03) §75, [\[Meyers97\]](#meyers97) §46, [\[Stroustrup00\]](#stroustrup00) §15.4.3, [\[Taligent94\]](#taligent94)

### <a id="sd-dtor"></a>讨论: 基类的析构函数应当要么是 public 和 virtual，要么是 protected 且非 virtual

析构应不应该表现为虚函数？就是说，是否允许通过指向 `base` 类的指针来进行析构呢？如果是的话，`base` 的析构函数为被调用则必须是 public 的，而且必须 virtual，否则调用就会导致未定义行为。否则的话，它应当是 protected 的，这样就只有派生类可以在它们自己的析构函数中调用它，且应当是非 virtual 的，因为它并不需要表现为虚函数的行为。

##### 示例

基类的一般情况是为了具有 public 的派生类，因而调用方代码基本上可以确定要用到某种比如 `shared_ptr<base>` 这样的东西：

    class Base {
    public:
        ~Base();                   // 不好, 非 virtual
        virtual ~Base();           // 好
        // ...
    };

    class Derived : public Base { /* ... */ };

    {
        unique_ptr<Base> pb = make_unique<Derived>();
        // ...
    } // 只有当 ~Base 是虚函数时 ~pb 才会调用正确的析构函数

少数比如策略类这类的情况下，类被用作基类是为方便起见，而并非是其多态行为。建议将它们的析构函数作为 protected 和非 virtual 函数：

    class My_policy {
    public:
        virtual ~My_policy();      // 不好, public 并且 virtual
    protected:
        ~My_policy();              // 好
        // ...
    };

    template<class Policy>
    class customizable : Policy { /* ... */ }; // 注: private 继承

##### 注解

这个简单的指导方针演示了一种微妙的问题，而且反映了继承的现代用法以及面向对象的设计原则。

对于某个基类 `Base`，调用方代码可能通过指向 `Base` 的指针来销毁派生类对象，比如使用一个 `unique_ptr<Base>`。如果 `Base` 的析构函数是 public 的且非 virtual（默认情况），它就可能意外地在实际指向一个派生类对象的指针上进行调用，这种情况下想要进行的删除的行为是未定义的。这种状况曾导致一些老编码标准提出通用的要求，让所有基类析构函数都必须 virtual。这种做法杀伤力过大了（虽然这是常见的情况）；其实，规则应当是当且仅当基类析构函数是 public 时才要求它是 virtual 的。

编写一个基类就是在定义一种抽象（参见条款 35 到 37）。注意对于参与这个抽象的每个成员函数来说，你都需要作出以下决定：

* 它是否应当表现为虚函数。
* 它是应当对所有使用 `Base` 指针的调用方公开，还是作为隐藏的内部实现细节。

如条款 39 中所述，对于普通成员函数来说，其选择可以是：允许通过 `Base` 指针对其进行非虚调用（但当它调用了虚函数时可具有虚行为，比如在 NVI 或者模板方法模式中那样），进行虚调用，或者完全不能调用。NVI 模式是一种避免公开虚函数的技巧。

析构可以仅仅被看做是另一种操作，虽然它带有特殊的语义，并且非虚调用要么很危险要么是错误的。因而，对于基类析构函数来说，其选择有：允许通过 `Base` 指针进行虚函数调用，或者完全不能调用；“非虚调用”是不行的。这样的话，基类析构函数当其可以被调用（即为 public）时应当是 virtual 的，否则就为非 virtual。

注意 NVI 模式并不适用于析构函数，因为构造函数和析构函数无法进行深析构调用。（参见条款 39 和 55。）

推论：当编写基类时，一定要明确编写析构函数，因为隐式生成的析构函数是 public 和非 virtual 的。当预置函数体没问题是你当然可以用 `=default`，而仅仅为其指定正确的可见性和虚函数性质即可。

##### 例外

某些组件体系架构（如 COM 和 CORBA）并不适用标准的删除机制，而是为对象的处置设立了不同的方案。请遵循相应的模式和惯用法，并在适当时采纳本条指导方针。

再考虑一下这种罕见情况：

* `B` 既是一个基类，也是可以被实例化的具体类，因而其析构函数必须为 public 以便 `B` 的对象可以创建和销毁。
* 而 `B` 也没有虚函数，且并不打算按多态方式使用，因此虽然其析构函数是 public 它也不必是 virtual 的。

这样的话，虽然析构函数必须为 public，也会有很强的压力来阻止它变为 virtual，因为作为第一个 virtual 函数，若其所添加的功能永远不会被利用的话，它就会损害所有的运行时类型开销。

在这种罕见情况下，可以是析构函数 public 且非 virtual，但要明确说明其派生类对象绝不能当作 `B` 来多态地使用。我们对 `std::unary_function` 正是这样做的。

不过，一般来说应当避免具体的基类（参见条款 35）。例如，`unary_function` 不过是聚合了一组 typedef，它不可能会被有意单独实例化。给它提供 public 的析构函数完全没有任何意义；更好的设计应当是遵循本条款的建议来给它一个 protected 非虚析构函数猜到。

**参考**: [\[SuttAlex05\]](#suttalex05) Item 50, [\[Cargill92\]](#cargill92) pp. 77-79, 207? [\[Cline99\]](#cline99) §21.06, 21.12-13? [\[Henricson97\]](#henricson97) pp. 110-114? [\[Koenig97\]](#koenig97) Chapters 4, 11? [\[Meyers97\]](#meyers97) §14? [\[Stroustrup00\]](#stroustrup00) §12.4.2? [\[Sutter02\]](#sutter02) §27? [\[Sutter04\]](#sutter04) §18

### <a id="sd-noexcept"></a>讨论: noexcept 的用法

???

### <a id="sd-never-fail"></a>讨论: 虚构函数，回收函数和 swap 不允许失败

绝不能允许从虚构函数，资源回收函数（如 `operator delete`），或者 `swap` 函数中用 `throw` 来报告错误。如果这些操作可以失败的话，就几乎不可能编写有用的代码了，而且即便真的发生了某种错误，也几乎不可能有进行重试的任何意义。特别是，C++ 标准库是直截了当地禁止使用可能在析构函数中抛出异常的类型的。现在，大多数析构函数缺省就隐含带有 `noexcept` 了。

##### 示例

    class Nefarious {
    public:
        Nefarious() { /* 可能抛出异常的代码 */ }    // 好
        ~Nefarious() { /* 可能抛出异常的代码 */ }   // 不好, 可能抛出异常
        // ...
    };

1. `Nefarious` 对象很难安全地使用，即便是作为局部变量也是如此：


        void test(string& s)
        {
            Nefarious n;          // 要有麻烦了
            string copy = s;      // 复制 string
        } // 先后销毁 copy 和 n

    这里，对 `s` 的复制可能抛出异常，且当其抛出了异常而 `n` 的析构函数也抛出了异常时，程序就会因调用 `std::terminate` 而退出，因为无法同时传播两个异常。

2. 以 `Nefarious` 为成员或者基类的类同样很难安全地使用，因为它们的析构函数必须调用 `Nefarious` 的析构函数，且同样遭受其糟糕行为的毒害：


        class Innocent_bystander {
            Nefarious member;     // 噢，毒害了外围类的析构函数
            // ...
        };

        void test(string& s)
        {
            Innocent_bystander i;  // 要有更多麻烦了
            string copy2 = s;      // 复制 string
        } // 依次销毁 copy 和 i

    这里，当 `copy2` 的构造中抛出了异常时，我们会遇到同样的问题，因为 `i` 的析构函数现在也会抛出异常，且因此会使我们调用 `std::terminate`。

3. 你也无法可靠地创建全局或静态的 `Nefarious` 对象：


        static Nefarious n;       // 噢，无法捕获任何析构函数异常

4. 你无法可靠地创建 `Nefarious` 的数组：


        void test()
        {
            std::array<Nefarious, 10> arr; // 这行代码会导致 std::terminate()
        }

    当出现可能抛出异常的析构函数时，数组的行为是未定义的，因为根本不可能发明出合理的回退行为。请想象一下：编译器如何才能生成用来构造 `arr` 的代码，如果第四个对象的构造函数抛出了异常，这段代码必须放弃，且在其清理模式中将试图调用已经构造完成的每个对象的析构函数……而这些析构函数中的一个或更多会抛出异常呢？不存在令人满意的答案。

5. 你无法在标准容器中使用 `Nefarious`：


        std::vector<Nefarious> vec(10);   // 这行代码会导致 std::terminate()

    标准库禁止其所使用的任何析构函数抛出异常。你无法把 `Nefarious` 对象存储到标准容器中，或者在标准库的任何其他组件上使用它们。

##### 注解

它们是绝不能失败的关键函数，因为在事务性编程中需要它们提供两种关键操作：当处理过程中遇到问题时撤回工作，以及当未发生问题时提交工作。如果没有办法可以用无失败操作来安全地撤回的话，就不可能实现无失败的回滚操作。如果没有办法可以用无失败操作（显然 `swap` 可以，但并不仅限于它）来安全地提交状态的改变的话，就不可能实现无失败的提交操作。

请考虑以下在 C++ 标准中所找到的建议和要求：

> 当在栈回溯过程中所调用的析构函数因为异常而退出时，将调用 terminate (15.5.1)。因此析构函数通常应当捕获异常，并防止它们被传播出析构函数。 --[\[C++03\]](#cplusplus03) §15.2(3)
>
> C++ 标准库中所定义的任何析构函数（也包括用于实例化标准库模板的任何类型的析构函数）的操作都不会抛出异常。 --[\[C++03\]](#cplusplus03) §17.4.4.8(3)

包括专门重载的 `operator delete` 和 `operator delete[]` 在内的回收函数也属于这一类别，因为一般它们也被用在清理过程，尤其是在异常处理过程中，用以对部分完成的工作进行撤回。
除了析构函数和回收函数之外，一般的错误安全性技术也依赖于永不失败的 `swap` 操作——这种情况下，它们不仅用于实现确保成功的回滚操作，也用于实现确保成功的提交操作。例如，以下是对类型 `T` 的一种惯用的 `operator=` 实现，它在复制构造之后，调用了无失败的 `swap`：

    T& T::operator=(const T& other)
    {
        auto temp = other;
        swap(temp);
        return *this;
    }

(另见条款 56。 ???)

幸运的是，当进行资源释放时，发生故障的范围肯定会比较小。如果使用异常作为错误报告机制的话，请确保这样的函数会处理其内部的处理中可能会产生的所有异常和其他错误。（对于异常，可以直接把你的析构函数中的所有相关部分都包围到一个 `try/catch(...)` 块中。）这点非常重要，因为析构函数可能会在某种紧要关头被调用，比如当无法分配某种系统资源（如内存、文件、锁、端口、窗口，或者其他系统对象）的时候。

当使用异常作为错误处理机制的时候，请始终明示这种行为，将这些函数声明为 `noexcept`。（参见条款 75。）

**参考**: [\[SuttAlex05\]](#suttalex05) Item 51; [\[C++03\]](#cplusplus03) §15.2(3), §17.4.4.8(3)? [\[Meyers96\]](#meyers96) §11? [\[Stroustrup00\]](#stroustrup00) §14.4.7, §E.2-4? [\[Sutter00\]](#sutter00) §8, §16? [\[Sutter02\]](#sutter02) §18-19

## <a id="sd-consistent"></a>统一对复制、移动和销毁操作进行定义

##### 理由

 ???

##### 注解

一旦定义了复制构造函数，就也得定义复制赋值运算符。

##### 注解

一旦定义了移动构造函数，就也得定义移动赋值运算符。

##### 示例

    class X {
    public:
        X(const x&) { /* stuff */ }

        // 不好: 未同时定义复制赋值运算符

        X(x&&) noexcept { /* stuff */ }

        // 不好: 未同时定义移动赋值运算符

        // ...
    };

    X x1;
    X x2 = x1; // ok
    x2 = x1;   // 陷阱：要么不能通过编译，要么会做出不好的事

一旦定义了析构函数，就不能再使用编译器所生成的复制或移动操作了；你可能需要定义或者抑制掉移动或复制操作。

    class X {
        HANDLE hnd;
        // ...
    public:
        ~X() { /* 自定义的行为，比如关闭 hnd */ }
        // 可疑: 未提到过复制或移动操作——hnd 会怎么样？
    };

    X x1;
    X x2 = x1; // 陷阱：要么不能通过编译，要么会做出不好的事
    x2 = x1;   // 陷阱：要么不能通过编译，要么会做出不好的事

如果定义了复制操作，且有任何基类或成员的诶性定义了移动操作的话，应当同样定义移动操作。

    class X {
        string s; // 定义了更高效的移动操作
        // ... 其他数据成员 ...
    public:
        X(const X&) { /* stuff */ }
        X& operator=(const X&) { /* stuff */ }

        //    不好: 并未一同定义移动构造函数和移动赋值
        //   （为何不把那些自定义的“stuff”重复一下呢？）
    };

    X test()
    {
        X local;
        // ...
        return local;  // 陷阱：可能会低效甚或产生错误的行为
    }

一旦定义了复制构造函数，复制赋值运算符，或者析构函数中额任何一个，你就可能需要也定义其他的。

##### 注解

如果需要定义这五个函数中的任何一个，这就意味着你需要得到与其预置行为不同的行为——而这五者则是非对称相关的。如下所述：

* 当编写或禁用复制构造函数或复制赋值运算符之一时，很可能需要对另一个同样对待：若其中之一有“特别的”任务，则很可能另一个也应当如此，因为这两个函数应当具有相似的效果。（参见条款 53，其中对这点进行专门的展开说明。）
* 当明确编写复制函数时，很可能需要编写析构函数：若复制构造函数所做的“特别的”任务为分配或复制某中资源（诸如内存、文件、socket等），则需要在析构函数中对其进行回收。
* 当明确编写析构函数时，很可能需要明确编写或禁用复制操作：若不得不编写一个不平凡的析构函数的话，这通常是由于你需要人工释放对象所持有的某个资源。若是如此的话，很可能需要特别小心这些资源的复制，而你就需要关注对象进行复制和赋值的方式，或者完全禁止复制操作。

许多情况下，持有以 RAII 的“拥有者”对象恰当封装了的资源，是能够把自己编写这些操作的需要消除掉的。（参见条款 13。）

应当优先采用编译器生成（包括 `=default`）的特殊成员；只有它们才被归类为“平凡的”，而且至少有一家主要的标准库供应商针对带有平凡特殊成员的类进行了大量地优化。这可能会成为一种常规实践。

**例外**: 当特殊函数的声明仅为了使其非公开或者为虚函数而没有特殊的语义时，它并不导致需要其他的特殊成员。
少数情况下，带有奇怪类型的成员（诸如引用成员）的类也是例外，因为它们的复制语义很古怪。
在持有引用的类中，你可能需要编写复制构造函数和赋值运算符，但预置的析构函数仍能够做出正确的处理。（需要注意，基本上使用引用成员几乎总是错误的。）

**参考**: [\[SuttAlex05\]](#suttalex05) Item 52; [\[Cline99\]](#cline99) §30.01-14? [\[Koenig97\]](#koenig97) §4? [\[Stroustrup00\]](#stroustrup00) §5.5, §10.4? [\[SuttHysl04b\]](#sutthysl04b)

资源管理规则概览：

* [提供强资源安全性；亦即，绝不让你认为是资源的任何东西发生泄漏](#cr-safety)
* [绝不在持有未被句柄所拥有的资源时返回或抛出异常](#cr-never)
* [“原生”的指针或引用不可能是资源句柄](#cr-raw)
* [绝不让指针的生存期超过其所指向的对象](#cr-outlive)
* [用模板来表现容器（和其他资源句柄）](#cr-templates)
* [按值返回容器（依靠移动或复制消除来获得性能）](#cr-value-return)
* [若类为资源句柄，则它需要构造函数，析构函数，复制以及移动操作](#cr-handle)
* [若类为容器，则应为其提供一个初始化式列表构造函数](#cr-list)

### <a id="cr-safety"></a>讨论：提供强资源安全性；亦即，绝不让你认为是资源的任何东西发生泄漏

##### 理由

避免泄漏。泄漏会导致性能损耗，发生神秘的错误，系统崩溃，以及安全性的违犯。

**其他形式**: 使所有资源都表示为某种可以自我管理生存期的类的对象。

##### 示例

    template<class T>
    class Vector {
    private:
        T* elem;   // 自由存储中的 sz 个元素，由类对象所拥有
        int sz;
        // ...
    };

这个类是一个资源句柄。它管理各个 `T` 对象的生存期。为此，`Vector` 必然要对[一组特殊操作](???)（几个构造函数，析构函数，等等）进行定义或弃置。

##### 示例

    ??? “奇异的”非内存资源 ???

##### 强制实施

防止泄漏的基本技巧是让所有的资源都被某种带有回档析构函数的资源句柄所拥有。检查工具能够查找出“裸 `new`”。给定一组 C 风格的分配函数（如 `fopen()`），检查工具也能够查找出未被资源句柄管理的使用点。一般来说，可以带着怀疑看待“裸指针”，对其进行标记和分析。如果没有人为输入的话，时无法产生资源的完整列表的（“资源”的定义有些过于宽泛），不过可以用一个资源列表来对工具进行“参数化”。

### <a id="cr-never"></a>讨论：绝不在持有未被句柄所拥有的资源时返回或抛出异常

##### 理由

这会导致泄漏。

##### 示例

    void f(int i)
    {
        FILE* f = fopen("a file", "r");
        ifstream is { "another file" };
        // ...
        if (i == 0) return;
        // ...
        fclose(f);
    }

当 `i == 0` 时 `a file` 的文件句柄就会泄漏。另一方面，`another file` 的 `ifstream` 则将会（在销毁时）正确关闭它的文件。如果你必须显式使用指针而不是带有特定语义的资源句柄的话，可以使用带有自定义删除器的 `unique_ptr` 或 `shared_ptr`：

    void f(int i)
    {
        unique_ptr<FILE, int(*)(FILE*)> f(fopen("a file", "r"), fclose);
        // ...
        if (i == 0) return;
        // ...
    }

这样更好：

    void f(int i)
    {
        ifstream input {"a file"};
        // ...
        if (i == 0) return;
        // ...
    }

##### 强制实施

检查器必须将任何“裸指针”当作可疑处理。
检查器可能必须依赖于人工提供的资源列表进行工作。
上手时，我们知道标准库容器，`string`，以及智能指针。
`span` 和 `string_view` 的使用能够提供巨大的帮助（它们并非资源句柄）。

### <a id="cr-raw"></a>讨论：“原生”的指针或引用不可能是资源句柄

##### 理由

使得能够区分所有者和视图。

##### 注解

这和你如何“拼写”指针是两回事：`T*`，`T&`，`Ptr<T>` 和 `Range<T>` 都不是所有者。

### <a id="cr-outlive"></a>讨论：绝不让指针的生存期超过其所指向的对象

##### 理由

避免极难找到的错误。这种指针的解引用时未定义行为，能够导致发生对类型系统的违犯。

##### 示例

    string* bad()   // 确实很坏
    {
        vector<string> v = { "This", "will", "cause", "trouble", "!" };
        // 导致指向已经销毁的对象（v）的已经销毁的成员的一个指针被泄漏出去
        return &v[0];
    }

    void use()
    {
        string* p = bad();
        vector<int> xx = {7, 8, 9};
        // 未定义行为: x 可能不是字符串 "This"
        string x = *p;
        // 未定义行为: 我们不知道在位置 p 上分配的到底是什么（如果有的话）
        *p = "Evil!";
    }

`v` 中的各个 `string` 都在 `bad()` 退出之时被销毁了， `v` 自身也是如此。其所返回的指针指向自由存储上的未分配内存。（由 `p` 所指向的）这块内存，在执行 `*p` 之时可能已经被重新分配了。此时很可能并不存在可以读取的 `string` 对象，而通过 `p` 进行写入则会轻易损坏某些无关类型的对象。

##### 强制实施

大多数编译器已经能对简单情况进行警告，而且它们带有可以更进一步的信息。将函数所返回的任何指针都当作是可疑的。用容器、资源句柄和视图（例如 `span`，它不是资源句柄）来减少需要检查的情形。上手时，可将带有析构函数的类都当作是资源句柄处理。

### <a id="cr-templates"></a>讨论：用模板来表现容器（和其他资源句柄）

##### 理由

提供静态类型安全的元素操作。

##### 示例

    template<typename T> class Vector {
        // ...
        T* elem;   // 指向 sz 个 T 类型的元素
        int sz;
    };

### <a id="cr-value-return"></a>讨论：按值返回容器（依靠移动或复制消除来获得性能）

##### 理由

简化代码并消除一种进行显式内存管理的需要。将对象递交给外围作用域，由此扩展其生存期。

**参见**：[F.20，有关“输出（Out）”值的一般条款](#rf-out)

##### 示例

    vector<int> get_large_vector()
    {
        return ...;
    }

    auto v = get_large_vector(); //  按值返回没有问题，大多数现代编译器都会进行复制消除

##### 例外

见 [F.20](#rf-out) 中的例外。

##### 强制实施

检查函数所返回额指针和引用，看看它们是否被赋值给资源句柄（如 `unique_ptr`）。

### <a id="cr-handle"></a>讨论：若类为资源句柄，则它需要构造函数，析构函数，复制以及移动操作

##### 理由

以提供对资源的生存期的完全控制。以提供一组协调的对资源的操作。

##### 示例

    ??? 折腾指针

##### 注解

若所有的成员都为资源句柄，则尽可能要依赖预置的特殊操作。

    template<typename T> struct Named {
        string name;
        T value;
    };

现在 `Named` 带有一个默认构造函数，一个析构函数，以及高效的复制和移动操作，只要 `T` 也提供了它们。

##### 强制实施

一般来说，工具是无法知道类是否是资源句柄的。不过，如果类带有某种[默认操作](#ss-ctor)的话, 它就得拥有全部，而如果类中有成员为资源句柄的话，它也应被当做是资源句柄。

### <a id="cr-list"></a>讨论：若类为容器，则应为其提供一个初始化式列表构造函数

##### 理由

提供一组初始元素是一种常见情形。

##### 示例

    template<typename T> class Vector {
    public:
        Vector(std::initializer_list<T>);
        // ...
    };

    Vector<string> vs { "Nygaard", "Ritchie" };

##### 强制实施

类怎么算作是容器呢？ ???

# <a id="s-tools"></a>附录 D: 支持工具

这个部分列出了直接支持采用 C++ 核心指导方针的一些工具。这个列表并非要穷尽那些有助于编写良好的 C++ 代码的工具。
如果一个工具被专门设计以支持并关联到 C++ 核心指导方针，那它就是包括进来的候选者。

### <a id="st-clangtidy"></a>工具: [Clang-tidy](http://clang.llvm.org/extra/clang-tidy/checks/list.html)

Clang-tidy 有一组专门用于强制实施 C++ 核心指导方针的规则。这些规则的命名模式为 `cppcoreguidelines-*`。

### <a id="st-cppcorecheck"></a>工具: [CppCoreCheck](https://docs.microsoft.com/en-us/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers)

微软编译器的 C++ 代码分析中包含一组专门用于强制实施 C++ 核心指导方针的规则。

# <a id="s-glossary"></a>词汇表

这是在指导方针中用到的一些术语的相对非正式的定义
（基于 [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html) 中的词汇表）。

有关 C++ 的许多主题的更多信息，可以在[标准 C++ 基金会的网站](https://isocpp.org) 找到。

* *ABI*: 应用二进制接口，对于特定硬件平台与操作系统的组合的一种规范。与 API 相对。
* *抽象类（abstract class）*: 不能直接用于创建对象的类；通常用于为派生类定义接口。
  当类带有纯虚函数或只有受保护的构造函数时，它就是抽象的。
* *抽象（abstraction）*: 对事物的描述，有选择并有意忽略（隐藏）了细节（如实现细节）；选择性忽略。
* *地址（address）*: 用以在计算机的内存中找到某个对象的值。
* *算法（algorithm）*: 用以解决某个问题的过程或公式；有限的一系列计算步骤以产生一个结果。
* *别名（alias）*: 指代某个对象的替代方式；通常为名字，指针，或者引用。
* *API*: 应用编程接口，一组构成不同软件之间之间的交互的函数。与 ABI 相对。
* *应用程序（application）*: 程序或程序的集合，用户将其看作一个实体。
* *近似（approximation）*: 事物（比如值或者设计），接近于完美的或者理想的（值或设计）。
  通常近似都是在理想情形中进行各种权衡的结果。
* *参数/实参（argument）*: 传递给函数或模板的值，其中以形参来进行访问。
* *数组（array）*: 同质元素序列，通常是数值，例如 `[0:max)`。
* *断言（assertion）*: 插入到程序中的语句，以声称（断言）在程序的这个位置某事物必定为真。
* *基类（base class）*: 目的是为从其进行派生的类型（比如它带有非 `final` 的虚函数），且有意仅间接使用该类型的对象（如通过指针）。\[严格地说，“基类”可被定义为“从之进行派生的类型”，但我们这里以类设计者意图的角度来给出定义\] 通常基类带有一个或更多的虚函数。
* *位（bit）*: 计算机中信息的基本单位。一个位的值可以为 0 或 1。
* *bug*: 程序中的错误。
* *字节（byte）*: 大多数计算机中进行寻址的基本单位。通常一个字节有 8 位。
* *类（class）*: 一种用户定义的类型，可以包含数据成员，函数成员，以及成员类型。
* *代码（code）*: 程序或程序的部分；有歧义地同时用于源代码和目标代码。
* *编译器（compiler）*: 一种将源代码变为目标代码的程序。
* *复杂度（complexity）*: 对某个问题构造解决方案的难度，或解决方案自身的一种难于精确定义的记法或度量。
  有时候复杂度只是（简单地）表示对执行某个算法所需操作的数量的估计。
* *计算（computation）*: 执行一些代码，通常接受一些输入并产生一些输出。
* *概念（concept）*: (1) 提法，想法；(2) 一组要求，通常针对模板参数。
* *具体类（concrete type）*: 并非基类的类型，且有意直接使用该类型的对象（而非仅通过指针/间接），其大小是已知的，通常可以按程序员的意图在任何地方分配（比如静态地在运行栈上分配）。
* *常量（constant）*: （在给定作用域中）不能改变的值；不可变。
* *构造函数（constructor）*: 初始化（“构造”）一个对象的操作。
  通常构造函数会建立起不变式，并且通常会获取对象被使用时所需的资源（并通常将由析构函数所释放）。
* *容器（container）*: 持有一些元素（其他对象）的对象。
* *复制（copy）*: 制造两个对象使其值比较为相等的操作。另见移动。
* *正确性（correctness）*: 如果程序或程序片段符合其说明，则其为正确的。
  不幸的是，说明可能不完整或不一致，或者也可能无法满足用户的合理预期。
  因此为了产生可接受的代码，我们有时候比仅仅遵守形式说明要做更多的事。
* *成本（cost）*: 产生一个程序，或者执行它的耗费（如开发时间，执行时间或空间等）。
  理想情况下，成本应当是复杂度的函数。
* *定制点（customization point）*:
* *数据（data）*: 计算中所用到的值。
* *调试（debugging）*: 寻找并移除程序中的错误的行为；通常远没有测试那样系统化。
* *声明式（declaration）*: 程序中对一个名字及其类型的说明。
* *定义式（definition）*: 实体的声明式，提供了程序使用该实体所需的所有信息。
  简化版定义：分配了内存额声明。
* *派生类（derived class）*: 派生自一个或多个基类的类。
* *设计（design）*: 对软件的某个片段应当如何运作以满足其说明的一个总体描述。
* *析构函数（destructor）*: 当对象销毁（如在作用域结束时）被隐式执行（调用）的操作。它通常进行资源的释放。
* *封装（encapsulation）*: 将某些事物（如实现细节）保护为私有的，不接受未授权的访问。
* *错误（error）*: 对程序行为的合理期望（通常表现为某种需求或者一份用户指南）和程序的实际行为之间的不一致。
* *可执行程序（executable）*: 预备在计算机上运行（执行）的程序。
* *功能蔓延（feature creep）*: 为“预防万一”而向程序添加过量的功能的倾向。
* *文件（file）*: 计算机中的持久信息的容器。
* *浮点数（floating-point number）*: 计算机对实数（如 7.93 和 10.78e–3）的近似。
* *函数（function）*: 命名的代码单元，可以从程序的不同部分执行（调用）；计算的逻辑单元。
* *泛型编程（generic programming）*: 关注于算法的设计和高效实现的一种编程风格。
  泛型算法能够对所有符合其要求的参数类型正确工作。在 C++ 中，泛型编程通常使用模板进行。
* *全局变量（global variable）*: 技术上说，命名空间作用域中的具名对象。
* *句柄（handle）*: 一个类，允许通过一个成员指针或引用来访问另一个对象。另见资源，复制，移动。
* *头文件（header）*: 包含用于在程序的各个部分中共享接口的声明的文件。
* *隐藏（hiding）*: 防止一个信息片段被直接看到或访问的行为。
  例如，嵌套（内部）作用域中的名字会防止外部（外围）作用域中相同的名字被直接使用。
* *理想的（ideal）*: 我们力争达成的事物的完美版本。我们经常不得不进行各种权衡最后获得一个近似。
* *实现（implementation）*: (1) 编写代码并测试的活动；(2) 用以实现一个程序的代码。
* *无限循环（infinite loop）*: 终止条件永不为真的循环。参见重复。
* *无限递归（infinite recursion）*: 无法终止的递归，直到机器耗尽内存无法维持其调用。
  在现实中这种递归不可能是无限的，它会因某种硬件错误而终止。
* *信息隐藏（information hiding）*: 分离接口和实现，以此将用户不感兴趣的实现细节隐藏起来，并提供一种抽象的活动。
* *初始化（initialize）*: 为一个对象给定其第一个（初始）值。
* *输入（input）*: 计算中所使用的值（比如函数参数以及通过键盘所输入的字符）。
* *整数（integer）*: 整数，比如 42 和 –99。
* *接口（interface）*: 一个或一组声明，说明了一个代码片段（比如函数或者类）应当如何进行调用。
* *不变式（invariant）*: 程序中的某些点必然总为真的事物；通常用于描述对象的状态（值的集合），或者循环进入其重复的语句之前的状态。
* *重复（iteration）*: 重复执行代码片段的行为；参见递归。
* *迭代器（iterator）*: 用以标识序列中的一个元素的对象。
* *ISO*: 国际标准化组织。C++ 语言是一项 ISO 标准：ISO/IEC 14882。更多信息请参考 [iso.org](http://iso.org)。
* *程序库（library）*: 类型、函数、类等等的集合，它们实现了一组设施（抽象），预备可能被用作不止一个程序的组成部分。
* *生存期（lifetime）*: 从对象的初始化直到它变为不可用（离开作用域，被删除，或程序终止）的时间。
* *连接器（linker）*: 用以将目标代码文件和程序库合并构成一个可执行程序的程序。
* *字面量（literal）*: 直接指定一个值的写法，比如 12 指定的是整数值“十二”。
* *循环（loop）*: 重复执行的代码片段；在 C++ 中，通常是 `for` 语句或者 `while` 语句。
* *移动（move）*: 将值从一个对象转移到另一个对象，并遗留一个表示“空”的值的操作。另见复制。
* *仅可移动类型（move-only type）*：可以移动但不能复制的具体类型。
* *可变的（mutable）*: 可以改动；不可变、常量和不变量的反义词。
* *对象（object）*: (1) 已经初始化的一块具有已知类型的内存区域，持有该类型的一个值；(2) 一块内存区域。
* *目标代码（object code）*: 编译器的输出，预备作为连接器的输入（连接器以其产生可执行代码）。
* *目标文件（object file）*: 包含目标代码的文件。
* *面向对象编程（object-oriented programming）*: （OOP）一种关注类和类层次的设计和使用的编程风格。
* *操作（operation）*: 能够实施某种活动的事物，比如函数或运算符。
* *输出（output）*: 由计算所产生的值（例如函数的结果，或者在屏幕上写下的一行行字符等）。
* *溢出（overflow）*: 产生无法被其预期目标所存储的值。
* *重载（overload）*: 定义两个函数或运算符，使其具有相同名字但不同的参数（操作数）类型。
* *覆盖（override）*: 在派生类中用声明和基类中的某个虚函数具有相同名字和参数类型的函数，以此使该函数可以通过由基类所定义的接口来进行调用。
* *所有者（owner）*: 负责释放某个资源的对象。
* *范式（paradigm）*: 设计和编程风格的一种多少有些做作的术语；通常会被用于（错误地）暗示有一种范式被其他的都更优秀。
* *形参（parameter）*: 对函数或模板的一个明确输入的声明。当进行调用时，函数可以通过其形参的名字来访问向其所传递的各个实参。
* *指针（pointer）*: (1) 值，用于标识内存中的一个有类型的对象；(2) 持有这种值的变量。
* *后条件（post-condition）*: 当从一个代码片段（如函数或者循环）退出时必须满足的条件。
* *前条件（pre-condition）*: 当进入一个代码片段（如函数或者循环）时必须满足的条件。
* *程序（program）*: 足够完整以便能够在计算机上执行的代码（可能带有关联的数据）。
* *编程（programming）*: 将问题的解决方案表现为代码的工艺。
* *编程语言（programming language）*: 用于表达程序的语言。
* *伪代码（pseudo code）*: 以非正式的写法而非编程语言所编写的对计算的一种描述。
* *纯虚函数（pure virtual function）*: 必须在派生类中予以覆盖的虚函数。
* *RAII*: （“资源获取即初始化，Resource Acquisition Is Initialization”）一种基于作用域进行资源管理的基本技术。
* *范围（range）*: 值的序列，可以以一个开始点和一个结尾点进行描述。例如，`[0:5)` 的意思是值 0，1，2，3，和 4。
* *递归（recursion）*: 函数调用其自身的行为；另见重复。
* *引用（reference）*: (1) 一种值，描述内存中具有类型的值的位置；(2) 持有这种值的变量。
* *正则表达式（regular expression）*: 对字符串的模式的一种表示法。
* *正规*: 可以进行相等性比较的半正规类型（参见 `std::regular` 概念）。进行复制之后，副本对象与原对象比较为相等。正规类型的行为与如 `int` 这样的内建类型相似，且可以用 `==` 进行比较。
特别是，正规类型的对象可以进行复制，且复制的结果是与原对象比较为相等的一个独立对象。另见*半正规类型*。
* *要求（requirement）*: (1) 对程序或程序的一部分的预期行为的描述；(2) 对函数或模板对其参数所作出的假设的描述。
* *资源（resource）*: 获取而得的并随后必须被释放的事物，比如文件句柄，锁，或者内存。另见句柄，所有者。
* *舍入（rounding）*: 将一个值转换为某个较不精确类型的数学上最接近的值。
* *RTTI*: 运行时类型信息（Run-Time Type Information）。 ???
* *作用域（scope）*: 程序文本（源代码）的区域，在其中可以对一个名字进行涉指。
* *半正规（semiregular）*: 可复制的（也包括可移动的）且可默认构造的具体类型（参见 `std::semiregular` 概念）。复制的结果是一个与原对象具有相同的值的独立类型。半正规类型的行为与像 `int` 这样内建类型大致相似，但可能没有 `==` 运算符。另见*正规类型*。
* *序列（sequence）*: 可以以线性的顺序访问的一组元素。
* *软件（software）*: 代码片段及其关联数据的集合；通常可以和程序互换运用。
* *源代码（source code）*: 由程序员所生产的代码，（原则上）可以被其他程序员阅读。
* *源文件（source file）*: 包含源代码的文件。
* *规范（specification）*: 对代码片段应当做什么的描述。
* *标准（standard）*: 由官方承认的对某事物的定义，比如编程语言。
* *状态（state）*: 一组值。
* *STL*: 标准库中的容器，迭代器，以及算法部分。
* *字符串（string）*: 字符的序列。
* *风格（style）*: 旨在统一语言功能特征的使用的一组编程技巧；有时候以非常限定的方式来仅代表诸如命名和代码展现等的低层次规则。
* *子类型（subtype）*: 派生类型；一个类型具有另一个类型的所有（可能更多）的性质。
* *超类型（supertype）*: 基类型；一个类型具有另一个类型的性质的子集。
* *系统（system）*: (1) 用以在计算机上实施某种任务的一个或一组程序；(2) 对“操作系统”的简称，即计算机的基本执行环境及工具。
* *TS*: [技术规范](https://www.iso.org/deliverables-all.html type=ts)。技术规范所处理的是仍处于技术开发之中的工作，或者是认为这项工作以后可能会被同意采纳为国际标准，但并不会立即处理。技术规范的出版是为了其立即可用，也是为了提供一种获得反馈的方法。其目标是最终能够被转化并重新作为国际标准来出版。
* *模板（template）*: 由一个或多个的类型或（编译时）值进行参数化的类或函数；支持泛型编程的基本 C++ 语言构造。
* *测试（testing）*: 系统化地查找程序中的错误。
* *权衡（trade-off）*: 对多个设计和实现准则进行平衡的结果。
* *截断（truncation）*: 从一个类型转换为另一个无法精确表示被转换的值的类型时发生的信息损失。
* *类型（type）*: 为一个对象定义了一组可能的值和一组操作的事物。
* *未初始化的（uninitialized）*: 对象在初始化之前的（未定义的）状态。
* *单元（unit）*: (1) 为值赋予含义的一种标准度量（例如，距离单位 km）；(2) 较大的整体中的一个可区分的（比如命名的）部分。
* *用例（use case）*: 程序的某个特定（通常简化的）使用，以测试其功能并演示其目的。
* *值（value）*: 根据某个类型所解释的一组内存中的位。
* *值类型（value type）*：一些人用这个术语来表示正规或半正规类型。
* *变量（variable）*: 给定类型的具名对象；除非未初始化否则包含一个值。
* *虚函数（virtual function）*: 可在派生类中进行覆盖的成员函数。
* *字（word）*: 计算机中内存的基本单元，通常是用以持有一个整数的单元。

# <a id="s-unclassified"></a>To-do: 未分类的规则原型

这是我们的未完成列表。
以下各条目最终将成为规则或者规则的一部分。
或者，我们也会决定不需要做出改动并将条目移除。

* 禁止远距离友元关系
* 应不应该处理物理设计（文件里有什么）和大规模设计（程序库，程序库的组合）？
* 命名空间
* 避免在全局作用域中使用 using 指令（但允许如 std 或其他的“基础”命名空间（如 experimental））
* 命名空间应当有什么粒度？是（如 Sutter/Alexandrescu 所定义的）所有被设计为一同工作或者一同发布的类和函数，还是应该更窄或是更宽？
* 应该用内联命名空间吗（比如 `std::literals::*_literals`）？
* 避免隐式转换
* Const 成员函数应当是线程安全的……aka, 但我并不想真的改掉变量，只是在第一次调用它的时候向它赋一个值……argh
* 始终初始化变量，为成员变量使用初始化列表。
* 无论谁编写了接受或返回 `void*` 的公开接口，都应该上火刑。我曾经好多年都以它作为自己的个人喜好来着。 :)
* 尽可能应用 `const`：成员函数，变量，以及 `const_iterators`
* 使用 `auto`
* `(size)` vs. `{initializers}` vs. `{Extent{size}}`
* 不要过度抽象
* 不要沿着调用栈向下传递指针
* 通过函数底部退出
* 应当提供在多态之间进行选择的指导方针吗？是的。经典的（虚函数，引用语义） vs. Sean Parent 风格（值语义，类型擦除，类似 `std::function`）  vs. CRTP/静态的？也许还需要 vs. 标签派发？
* 我们的指导方针是否应当在构造函数或析构函数中禁止进行虚函数调用？是的。许多人都禁止了，虽然我觉得这是 C++ 的一大优势 ??? -保留意见（D 走向 Java 之路太让我失望了）。有好的例子吗？
* 在 lambda 方面，在算法调用和其他回调场景中什么因素会影响决定使用 lambda 还是（局部？）类？
* 讨论一下 `std::bind`，Stephen T. Lavavej 对它有太多批评，使我开始觉得它是不是真的会在未来消失掉。应该建议以 lambda 代替它吗？
* 怎么处理泄漏的临时变量？ : `p = (s1 + s2).c_str();`
* 指针和迭代器的失效会导致悬挂指针：

        void bad()
        {
            int* p = new int[700];
            int* q = &p[7];
            delete p;

            vector<int> v(700);
            int* q2 = &v[7];
            v.resize(900);

            // ... 使用 q 和 q2 ...
        }

* LSP
* 私有继承 vs/and 成员
* 避免静态类成员变量（竞争条件，几乎就是全局变量）

* 使用 RAII 锁定保护（`lock_guard`，`unique_lock`，`shared_lock`），绝不直接调用 `mutex.lock` 和 `mutex.unlock`（RAII）
* 优先使用非递归锁（它们通常用作不良情况的变通手段，有开销）
* 联结（join）你的每个线程！（因为如果没被联结或脱离（detach）的话，析构函数会调用 `std::terminate`……有什么好理由来脱离线程吗？） -- ??? 支持库该不该为 `std::thread` 提供一个 RAII 包装呢？
* 当必须同时获取两个或更多的互斥体时，应当使用 `std::lock`（或者别的死锁免除算法？）
* 当使用 `condition_variable` 时，始终用一个互斥体来保护它（在互斥体外面设置原子 bool 的值的做法是错误的！），并对条件变量自身使用同一个互斥体。
* 绝不对 `std::atomic<user-defined-struct>` 使用 `atomic_compare_exchange_strong`（填充位中的区别会造成影响，而在循环中使用 `compare_exchange_weak` 则能够归于稳定的填充位）
* 单独的 `shared_future` 对象不是线程安全的：两个线程不能等待同一个 `shared_future` 对象（它们可以等待指代相同共享状态的 `shared_future` 的副本）
* 单独的 `shared_ptr` 对象不是线程安全的：不同的线程可以调用指代相同共享对象的*不同* `shared_ptr` 的非 `const` 成员函数，但当一个线程访问一个 `shared_ptr` 对象时，另一个线程不能调用相同 `shared_ptr` 对象的非 `const` 成员函数（如果确实需要，考虑代之以 `atomic_shared_ptr`）

* 算术相关规则

# 参考文献

* <a id="abrahams01"></a>
  \[Abrahams01]:  D. Abrahams. [Exception-Safety in Generic Components](http://www.boost.org/community/exception_safety.html).
* <a id="alexandrescu01"></a>
  \[Alexandrescu01]:  A. Alexandrescu. Modern C++ Design (Addison-Wesley, 2001).
* <a id="cplusplus03"></a>
  \[C++03]:           ISO/IEC 14882:2003(E), Programming Languages — C++ (updated ISO and ANSI C++ Standard including the contents of (C++98) plus errata corrections).
* <a id="cargill92"></a>
  \[Cargill92]:       T. Cargill. C++ Programming Style (Addison-Wesley, 1992).
* <a id="cline99"></a>
  \[Cline99]:         M. Cline, G. Lomow, and M. Girou. C++ FAQs (2ndEdition) (Addison-Wesley, 1999).
* <a id="dewhurst03"></a>
  \[Dewhurst03]:      S. Dewhurst. C++ Gotchas (Addison-Wesley, 2003).
* <a id="henricson97"></a>
  \[Henricson97]:     M. Henricson and E. Nyquist. Industrial Strength C++ (Prentice Hall, 1997).
* <a id="koenig97"></a>
  \[Koenig97]:        A. Koenig and B. Moo. Ruminations on C++ (Addison-Wesley, 1997).
* <a id="lakos96"></a>
  \[Lakos96]:         J. Lakos. Large-Scale C++ Software Design (Addison-Wesley, 1996).
* <a id="meyers96"></a>
  \[Meyers96]:        S. Meyers. More Effective C++ (Addison-Wesley, 1996).
* <a id="meyers97"></a>
  \[Meyers97]:        S. Meyers. Effective C++ (2nd Edition) (Addison-Wesley, 1997).
* <a id="meyers01"></a>
  \[Meyers01]:        S. Meyers. Effective STL (Addison-Wesley, 2001).
* <a id="meyers05"></a>
  \[Meyers05]:        S. Meyers. Effective C++ (3rd Edition) (Addison-Wesley, 2005).
* <a id="meyers15"></a>
  \[Meyers15]:        S. Meyers. Effective Modern C++ (O'Reilly, 2015).
* <a id="murray93"></a>
  \[Murray93]:        R. Murray. C++ Strategies and Tactics (Addison-Wesley, 1993).
* <a id="stroustrup94"></a>
  \[Stroustrup94]:    B. Stroustrup. The Design and Evolution of C++ (Addison-Wesley, 1994).
* <a id="stroustrup00"></a>
  \[Stroustrup00]:    B. Stroustrup. The C++ Programming Language (Special 3rdEdition) (Addison-Wesley, 2000).
* <a id="stroustrup05"></a>
  \[Stroustrup05]:    B. Stroustrup. [A rationale for semantically enhanced library languages](http://www.stroustrup.com/SELLrationale.pdf).
* <a id="stroustrup13"></a>
  \[Stroustrup13]:    B. Stroustrup. [The C++ Programming Language (4th Edition)](http://www.stroustrup.com/4th.html). Addison Wesley 2013.
* <a id="stroustrup14"></a>
  \[Stroustrup14]:    B. Stroustrup. [A Tour of C++](http://www.stroustrup.com/Tour.html).
  Addison Wesley 2014.
* <a id="Stroustrup15></a>
  \[Stroustrup15]:    B. Stroustrup, Herb Sutter, and G. Dos Reis: [A brief introduction to C++'s model for type- and resource-safety](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Introduction%20to%20type%20and%20resource%20safety.pdf).
* <a id="sutthysl04b"></a>
  \[SuttHysl04b]:     H. Sutter and J. Hyslop. [Collecting Shared Objects](https://web.archive.org/web/20120926011837/http://www.drdobbs.com/collecting-shared-objects/184401839) (C/C++ Users Journal, 22(8), August 2004).
* <a id="suttalex05"></a>
  \[SuttAlex05]:      H. Sutter and  A. Alexandrescu. C++ Coding Standards. Addison-Wesley 2005.
* <a id="sutter00"></a>
  \[Sutter00]:        H. Sutter. Exceptional C++ (Addison-Wesley, 2000).
* <a id="sutter02"></a>
  \[Sutter02]:        H. Sutter. More Exceptional C++ (Addison-Wesley, 2002).
* <a id="sutter04"></a>
  \[Sutter04]:        H. Sutter. Exceptional C++ Style (Addison-Wesley, 2004).
* <a id="taligent94"></a>
  \[Taligent94]: Taligent's Guide to Designing Programs (Addison-Wesley, 1994).
